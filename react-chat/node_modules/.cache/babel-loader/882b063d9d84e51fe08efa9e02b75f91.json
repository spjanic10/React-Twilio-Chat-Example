{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.apply = exports.InvalidOperationError = exports.test = exports.copy = exports.move = exports.replace = exports.remove = exports.add = exports.TestError = exports.MissingError = void 0;\n\nvar pointer_1 = require(\"./pointer\");\n\nvar util_1 = require(\"./util\");\n\nvar equal_1 = require(\"./equal\");\n\nvar MissingError =\n/** @class */\nfunction (_super) {\n  __extends(MissingError, _super);\n\n  function MissingError(path) {\n    var _this = _super.call(this, \"Value required at path: \" + path) || this;\n\n    _this.path = path;\n    _this.name = 'MissingError';\n    return _this;\n  }\n\n  return MissingError;\n}(Error);\n\nexports.MissingError = MissingError;\n\nvar TestError =\n/** @class */\nfunction (_super) {\n  __extends(TestError, _super);\n\n  function TestError(actual, expected) {\n    var _this = _super.call(this, \"Test failed: \" + actual + \" != \" + expected) || this;\n\n    _this.actual = actual;\n    _this.expected = expected;\n    _this.name = 'TestError';\n    return _this;\n  }\n\n  return TestError;\n}(Error);\n\nexports.TestError = TestError;\n\nfunction _add(object, key, value) {\n  if (Array.isArray(object)) {\n    // `key` must be an index\n    if (key == '-') {\n      object.push(value);\n    } else {\n      var index = parseInt(key, 10);\n      object.splice(index, 0, value);\n    }\n  } else {\n    object[key] = value;\n  }\n}\n\nfunction _remove(object, key) {\n  if (Array.isArray(object)) {\n    // '-' syntax doesn't make sense when removing\n    var index = parseInt(key, 10);\n    object.splice(index, 1);\n  } else {\n    // not sure what the proper behavior is when path = ''\n    delete object[key];\n  }\n}\n/**\n>  o  If the target location specifies an array index, a new value is\n>     inserted into the array at the specified index.\n>  o  If the target location specifies an object member that does not\n>     already exist, a new member is added to the object.\n>  o  If the target location specifies an object member that does exist,\n>     that member's value is replaced.\n*/\n\n\nfunction add(object, operation) {\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object); // it's not exactly a \"MissingError\" in the same way that `remove` is -- more like a MissingParent, or something\n\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  _add(endpoint.parent, endpoint.key, util_1.clone(operation.value));\n\n  return null;\n}\n\nexports.add = add;\n/**\n> The \"remove\" operation removes the value at the target location.\n> The target location MUST exist for the operation to be successful.\n*/\n\nfunction remove(object, operation) {\n  // endpoint has parent, key, and value properties\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.value === undefined) {\n    return new MissingError(operation.path);\n  } // not sure what the proper behavior is when path = ''\n\n\n  _remove(endpoint.parent, endpoint.key);\n\n  return null;\n}\n\nexports.remove = remove;\n/**\n> The \"replace\" operation replaces the value at the target location\n> with a new value.  The operation object MUST contain a \"value\" member\n> whose content specifies the replacement value.\n> The target location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to a \"remove\" operation for\n> a value, followed immediately by an \"add\" operation at the same\n> location with the replacement value.\n\nEven more simply, it's like the add operation with an existence check.\n*/\n\nfunction replace(object, operation) {\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.parent === null) {\n    return new MissingError(operation.path);\n  } // this existence check treats arrays as a special case\n\n\n  if (Array.isArray(endpoint.parent)) {\n    if (parseInt(endpoint.key, 10) >= endpoint.parent.length) {\n      return new MissingError(operation.path);\n    }\n  } else if (endpoint.value === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  endpoint.parent[endpoint.key] = operation.value;\n  return null;\n}\n\nexports.replace = replace;\n/**\n> The \"move\" operation removes the value at a specified location and\n> adds it to the target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to move the value from.\n> This operation is functionally identical to a \"remove\" operation on\n> the \"from\" location, followed immediately by an \"add\" operation at\n> the target location with the value that was just removed.\n\n> The \"from\" location MUST NOT be a proper prefix of the \"path\"\n> location; i.e., a location cannot be moved into one of its children.\n\nTODO: throw if the check described in the previous paragraph fails.\n*/\n\nfunction move(object, operation) {\n  var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n\n  if (from_endpoint.value === undefined) {\n    return new MissingError(operation.from);\n  }\n\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  _remove(from_endpoint.parent, from_endpoint.key);\n\n  _add(endpoint.parent, endpoint.key, from_endpoint.value);\n\n  return null;\n}\n\nexports.move = move;\n/**\n> The \"copy\" operation copies the value at a specified location to the\n> target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to copy the value from.\n> The \"from\" location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to an \"add\" operation at the\n> target location using the value specified in the \"from\" member.\n\nAlternatively, it's like 'move' without the 'remove'.\n*/\n\nfunction copy(object, operation) {\n  var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n\n  if (from_endpoint.value === undefined) {\n    return new MissingError(operation.from);\n  }\n\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path);\n  }\n\n  _add(endpoint.parent, endpoint.key, util_1.clone(from_endpoint.value));\n\n  return null;\n}\n\nexports.copy = copy;\n/**\n> The \"test\" operation tests that a value at the target location is\n> equal to a specified value.\n> The operation object MUST contain a \"value\" member that conveys the\n> value to be compared to the target location's value.\n> The target location MUST be equal to the \"value\" value for the\n> operation to be considered successful.\n*/\n\nfunction test(object, operation) {\n  var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n  var result = equal_1.compare(endpoint.value, operation.value);\n\n  if (!result) {\n    return new TestError(endpoint.value, operation.value);\n  }\n\n  return null;\n}\n\nexports.test = test;\n\nvar InvalidOperationError =\n/** @class */\nfunction (_super) {\n  __extends(InvalidOperationError, _super);\n\n  function InvalidOperationError(operation) {\n    var _this = _super.call(this, \"Invalid operation: \" + operation.op) || this;\n\n    _this.operation = operation;\n    _this.name = 'InvalidOperationError';\n    return _this;\n  }\n\n  return InvalidOperationError;\n}(Error);\n\nexports.InvalidOperationError = InvalidOperationError;\n/**\nSwitch on `operation.op`, applying the corresponding patch function for each\ncase to `object`.\n*/\n\nfunction apply(object, operation) {\n  // not sure why TypeScript can't infer typesafety of:\n  //   {add, remove, replace, move, copy, test}[operation.op](object, operation)\n  // (seems like a bug)\n  switch (operation.op) {\n    case 'add':\n      return add(object, operation);\n\n    case 'remove':\n      return remove(object, operation);\n\n    case 'replace':\n      return replace(object, operation);\n\n    case 'move':\n      return move(object, operation);\n\n    case 'copy':\n      return copy(object, operation);\n\n    case 'test':\n      return test(object, operation);\n  }\n\n  return new InvalidOperationError(operation);\n}\n\nexports.apply = apply;","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/rfc6902/patch.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","apply","InvalidOperationError","test","copy","move","replace","remove","add","TestError","MissingError","pointer_1","require","util_1","equal_1","_super","path","_this","call","name","Error","actual","expected","_add","object","key","isArray","push","index","parseInt","splice","_remove","operation","endpoint","Pointer","fromJSON","evaluate","parent","undefined","clone","length","from_endpoint","from","result","compare","op"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.apply = exports.InvalidOperationError = exports.test = exports.copy = exports.move = exports.replace = exports.remove = exports.add = exports.TestError = exports.MissingError = void 0;\nvar pointer_1 = require(\"./pointer\");\nvar util_1 = require(\"./util\");\nvar equal_1 = require(\"./equal\");\nvar MissingError = /** @class */ (function (_super) {\n    __extends(MissingError, _super);\n    function MissingError(path) {\n        var _this = _super.call(this, \"Value required at path: \" + path) || this;\n        _this.path = path;\n        _this.name = 'MissingError';\n        return _this;\n    }\n    return MissingError;\n}(Error));\nexports.MissingError = MissingError;\nvar TestError = /** @class */ (function (_super) {\n    __extends(TestError, _super);\n    function TestError(actual, expected) {\n        var _this = _super.call(this, \"Test failed: \" + actual + \" != \" + expected) || this;\n        _this.actual = actual;\n        _this.expected = expected;\n        _this.name = 'TestError';\n        return _this;\n    }\n    return TestError;\n}(Error));\nexports.TestError = TestError;\nfunction _add(object, key, value) {\n    if (Array.isArray(object)) {\n        // `key` must be an index\n        if (key == '-') {\n            object.push(value);\n        }\n        else {\n            var index = parseInt(key, 10);\n            object.splice(index, 0, value);\n        }\n    }\n    else {\n        object[key] = value;\n    }\n}\nfunction _remove(object, key) {\n    if (Array.isArray(object)) {\n        // '-' syntax doesn't make sense when removing\n        var index = parseInt(key, 10);\n        object.splice(index, 1);\n    }\n    else {\n        // not sure what the proper behavior is when path = ''\n        delete object[key];\n    }\n}\n/**\n>  o  If the target location specifies an array index, a new value is\n>     inserted into the array at the specified index.\n>  o  If the target location specifies an object member that does not\n>     already exist, a new member is added to the object.\n>  o  If the target location specifies an object member that does exist,\n>     that member's value is replaced.\n*/\nfunction add(object, operation) {\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    // it's not exactly a \"MissingError\" in the same way that `remove` is -- more like a MissingParent, or something\n    if (endpoint.parent === undefined) {\n        return new MissingError(operation.path);\n    }\n    _add(endpoint.parent, endpoint.key, util_1.clone(operation.value));\n    return null;\n}\nexports.add = add;\n/**\n> The \"remove\" operation removes the value at the target location.\n> The target location MUST exist for the operation to be successful.\n*/\nfunction remove(object, operation) {\n    // endpoint has parent, key, and value properties\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.value === undefined) {\n        return new MissingError(operation.path);\n    }\n    // not sure what the proper behavior is when path = ''\n    _remove(endpoint.parent, endpoint.key);\n    return null;\n}\nexports.remove = remove;\n/**\n> The \"replace\" operation replaces the value at the target location\n> with a new value.  The operation object MUST contain a \"value\" member\n> whose content specifies the replacement value.\n> The target location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to a \"remove\" operation for\n> a value, followed immediately by an \"add\" operation at the same\n> location with the replacement value.\n\nEven more simply, it's like the add operation with an existence check.\n*/\nfunction replace(object, operation) {\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.parent === null) {\n        return new MissingError(operation.path);\n    }\n    // this existence check treats arrays as a special case\n    if (Array.isArray(endpoint.parent)) {\n        if (parseInt(endpoint.key, 10) >= endpoint.parent.length) {\n            return new MissingError(operation.path);\n        }\n    }\n    else if (endpoint.value === undefined) {\n        return new MissingError(operation.path);\n    }\n    endpoint.parent[endpoint.key] = operation.value;\n    return null;\n}\nexports.replace = replace;\n/**\n> The \"move\" operation removes the value at a specified location and\n> adds it to the target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to move the value from.\n> This operation is functionally identical to a \"remove\" operation on\n> the \"from\" location, followed immediately by an \"add\" operation at\n> the target location with the value that was just removed.\n\n> The \"from\" location MUST NOT be a proper prefix of the \"path\"\n> location; i.e., a location cannot be moved into one of its children.\n\nTODO: throw if the check described in the previous paragraph fails.\n*/\nfunction move(object, operation) {\n    var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n    if (from_endpoint.value === undefined) {\n        return new MissingError(operation.from);\n    }\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.parent === undefined) {\n        return new MissingError(operation.path);\n    }\n    _remove(from_endpoint.parent, from_endpoint.key);\n    _add(endpoint.parent, endpoint.key, from_endpoint.value);\n    return null;\n}\nexports.move = move;\n/**\n> The \"copy\" operation copies the value at a specified location to the\n> target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to copy the value from.\n> The \"from\" location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to an \"add\" operation at the\n> target location using the value specified in the \"from\" member.\n\nAlternatively, it's like 'move' without the 'remove'.\n*/\nfunction copy(object, operation) {\n    var from_endpoint = pointer_1.Pointer.fromJSON(operation.from).evaluate(object);\n    if (from_endpoint.value === undefined) {\n        return new MissingError(operation.from);\n    }\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    if (endpoint.parent === undefined) {\n        return new MissingError(operation.path);\n    }\n    _add(endpoint.parent, endpoint.key, util_1.clone(from_endpoint.value));\n    return null;\n}\nexports.copy = copy;\n/**\n> The \"test\" operation tests that a value at the target location is\n> equal to a specified value.\n> The operation object MUST contain a \"value\" member that conveys the\n> value to be compared to the target location's value.\n> The target location MUST be equal to the \"value\" value for the\n> operation to be considered successful.\n*/\nfunction test(object, operation) {\n    var endpoint = pointer_1.Pointer.fromJSON(operation.path).evaluate(object);\n    var result = equal_1.compare(endpoint.value, operation.value);\n    if (!result) {\n        return new TestError(endpoint.value, operation.value);\n    }\n    return null;\n}\nexports.test = test;\nvar InvalidOperationError = /** @class */ (function (_super) {\n    __extends(InvalidOperationError, _super);\n    function InvalidOperationError(operation) {\n        var _this = _super.call(this, \"Invalid operation: \" + operation.op) || this;\n        _this.operation = operation;\n        _this.name = 'InvalidOperationError';\n        return _this;\n    }\n    return InvalidOperationError;\n}(Error));\nexports.InvalidOperationError = InvalidOperationError;\n/**\nSwitch on `operation.op`, applying the corresponding patch function for each\ncase to `object`.\n*/\nfunction apply(object, operation) {\n    // not sure why TypeScript can't infer typesafety of:\n    //   {add, remove, replace, move, copy, test}[operation.op](object, operation)\n    // (seems like a bug)\n    switch (operation.op) {\n        case 'add': return add(object, operation);\n        case 'remove': return remove(object, operation);\n        case 'replace': return replace(object, operation);\n        case 'move': return move(object, operation);\n        case 'copy': return copy(object, operation);\n        case 'test': return test(object, operation);\n    }\n    return new InvalidOperationError(operation);\n}\nexports.apply = apply;\n"]},"metadata":{},"sourceType":"script"}