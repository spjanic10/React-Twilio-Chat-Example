{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TwilsockImpl = exports.TwilsockChannel = exports.Response = void 0;\n\nvar events_1 = require(\"events\");\n\nvar StateMachine = require(\"javascript-state-machine\");\n\nvar logger_1 = require(\"./logger\");\n\nvar Messages = require(\"./protocol/messages\");\n\nvar parser_1 = require(\"./parser\");\n\nvar twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\n\nvar backoffretrier_1 = require(\"./backoffretrier\");\n\nvar DISCONNECTING_TIMEOUT = 3000; // Wraps asynchronous rescheduling\n// Just makes it simpler to find these hacks over the code\n\nfunction trampoline(f) {\n  setTimeout(f, 0);\n}\n/**\n * Makes sure that body is properly stringified\n */\n\n\nfunction preparePayload(payload) {\n  switch (typeof payload) {\n    case 'undefined':\n      return '';\n\n    case 'object':\n      return JSON.stringify(payload);\n\n    default:\n      return payload;\n  }\n}\n\nvar Request = function Request() {\n  _classCallCheck(this, Request);\n};\n\nvar Response = function Response() {\n  _classCallCheck(this, Response);\n};\n\nexports.Response = Response;\n/**\n * Twilsock channel level protocol implementation\n */\n\nvar TwilsockChannel = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(TwilsockChannel, _events_1$EventEmitte);\n\n  var _super = _createSuper(TwilsockChannel);\n\n  function TwilsockChannel(websocket, transport, config) {\n    var _this;\n\n    _classCallCheck(this, TwilsockChannel);\n\n    _this = _super.call(this);\n    _this.terminalStates = ['disconnected', 'rejected'];\n    _this.lastEmittedState = undefined;\n    _this.tokenExpiredSasCode = 20104;\n    _this.terminationReason = 'Connection is not initialized';\n    _this.websocket = websocket;\n\n    _this.websocket.on('connected', function () {\n      return _this.fsm.socketConnected();\n    });\n\n    _this.websocket.on('disconnected', function (e) {\n      return _this.fsm.socketClosed();\n    });\n\n    _this.websocket.on('message', function (message) {\n      return _this.onIncomingMessage(message);\n    });\n\n    _this.websocket.on('socketError', function (e) {\n      return _this.emit('connectionError', {\n        terminal: false,\n        message: e.message,\n        httpStatusCode: null,\n        errorCode: null\n      });\n    });\n\n    _this.transport = transport;\n    _this.config = config;\n    _this.retrier = new backoffretrier_1.BackoffRetrier(config.retryPolicy);\n\n    _this.retrier.on('attempt', function () {\n      return _this.retry();\n    });\n\n    _this.retrier.on('failed', function (err) {\n      logger_1.log.warn(\"Retrying failed: \".concat(err.message));\n\n      _this.disconnect();\n    });\n\n    if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n      window.addEventListener('online', function () {\n        logger_1.log.debug('Browser reported connectivity state: online');\n\n        _this.fsm.systemOnline();\n      });\n      window.addEventListener('offline', function () {\n        logger_1.log.debug('Browser reported connectivity state: offline');\n\n        _this.websocket.close();\n\n        _this.fsm.socketClosed();\n      });\n    }\n\n    _this.fsm = new StateMachine({\n      init: 'disconnected',\n      transitions: [{\n        name: 'userConnect',\n        from: ['disconnected', 'rejected'],\n        to: 'connecting'\n      }, {\n        name: 'userConnect',\n        from: ['connecting', 'connected']\n      }, {\n        name: 'userDisconnect',\n        from: ['connecting', 'initialising', 'connected', 'updating', 'retrying', 'rejected', 'waitSocketClosed', 'waitOffloadSocketClosed'],\n        to: 'disconnecting'\n      }, {\n        name: 'userRetry',\n        from: ['retrying'],\n        to: 'connecting'\n      }, {\n        name: 'socketConnected',\n        from: ['connecting'],\n        to: 'initialising'\n      }, {\n        name: 'socketClosed',\n        from: ['connecting', 'initialising', 'connected', 'updating', 'error', 'waitOffloadSocketClosed'],\n        to: 'retrying'\n      }, {\n        name: 'socketClosed',\n        from: ['disconnecting'],\n        to: 'disconnected'\n      }, {\n        name: 'socketClosed',\n        from: ['waitSocketClosed'],\n        to: 'disconnected'\n      }, {\n        name: 'socketClosed',\n        from: ['rejected'],\n        to: 'rejected'\n      }, {\n        name: 'initSuccess',\n        from: ['initialising'],\n        to: 'connected'\n      }, {\n        name: 'initError',\n        from: ['initialising'],\n        to: 'error'\n      }, {\n        name: 'tokenRejected',\n        from: ['initialising', 'updating'],\n        to: 'rejected'\n      }, {\n        name: 'protocolError',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'error'\n      }, {\n        name: 'receiveClose',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'waitSocketClosed'\n      }, {\n        name: 'receiveOffload',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'waitOffloadSocketClosed'\n      }, {\n        name: 'unsupportedProtocol',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'unsupported'\n      }, {\n        name: 'receiveFatalClose',\n        from: ['initialising', 'connected', 'updating'],\n        to: 'unsupported'\n      }, {\n        name: 'userUpdateToken',\n        from: ['disconnected', 'rejected', 'connecting', 'retrying'],\n        to: 'connecting'\n      }, {\n        name: 'userUpdateToken',\n        from: ['connected'],\n        to: 'updating'\n      }, {\n        name: 'updateSuccess',\n        from: ['updating'],\n        to: 'connected'\n      }, {\n        name: 'updateError',\n        from: ['updating'],\n        to: 'error'\n      }, {\n        name: 'userSend',\n        from: ['connected'],\n        to: 'connected'\n      }, {\n        name: 'systemOnline',\n        from: ['retrying'],\n        to: 'connecting'\n      }],\n      methods: {\n        onConnecting: function onConnecting() {\n          _this.setupSocket();\n\n          _this.emit('connecting');\n        },\n        onEnterInitialising: function onEnterInitialising() {\n          _this.sendInit();\n        },\n        onLeaveInitialising: function onLeaveInitialising() {\n          _this.cancelInit();\n        },\n        onEnterUpdating: function onEnterUpdating() {\n          _this.sendUpdate();\n        },\n        onLeaveUpdating: function onLeaveUpdating() {\n          _this.cancelUpdate();\n        },\n        onEnterRetrying: function onEnterRetrying() {\n          _this.initRetry();\n\n          _this.emit('connecting');\n        },\n        onEnterConnected: function onEnterConnected() {\n          _this.resetBackoff();\n\n          _this.onConnected();\n        },\n        onUserUpdateToken: function onUserUpdateToken() {\n          _this.resetBackoff();\n        },\n        onTokenRejected: function onTokenRejected() {\n          _this.resetBackoff();\n\n          _this.closeSocket(true);\n\n          _this.finalizeSocket();\n        },\n        onUserDisconnect: function onUserDisconnect() {\n          _this.closeSocket(true);\n        },\n        onEnterDisconnecting: function onEnterDisconnecting() {\n          _this.startDisconnectTimer();\n        },\n        onLeaveDisconnecting: function onLeaveDisconnecting() {\n          _this.cancelDisconnectTimer();\n        },\n        onEnterWaitSocketClosed: function onEnterWaitSocketClosed() {\n          _this.startDisconnectTimer();\n        },\n        onLeaveWaitSocketClosed: function onLeaveWaitSocketClosed() {\n          _this.cancelDisconnectTimer();\n        },\n        onEnterWaitOffloadSocketClosed: function onEnterWaitOffloadSocketClosed() {\n          _this.startDisconnectTimer();\n        },\n        onLeaveWaitOffloadSocketClosed: function onLeaveWaitOffloadSocketClosed() {\n          _this.cancelDisconnectTimer();\n        },\n        onDisconnected: function onDisconnected() {\n          _this.resetBackoff();\n\n          _this.finalizeSocket();\n        },\n        onReceiveClose: function onReceiveClose(event, args) {\n          _this.onCloseReceived(args);\n        },\n        onReceiveOffload: function onReceiveOffload(event, args) {\n          logger_1.log.debug('onreceiveoffload: ', args);\n\n          _this.modifyBackoff(args.body);\n\n          _this.onCloseReceived(args.status);\n        },\n        onUnsupported: function onUnsupported() {\n          _this.closeSocket(true);\n\n          _this.finalizeSocket();\n        },\n        onError: function onError(lifecycle, graceful) {\n          _this.closeSocket(graceful);\n\n          _this.finalizeSocket();\n        },\n        onEnterState: function onEnterState(event) {\n          if (event.from !== 'none') {\n            _this.changeState(event);\n          }\n        },\n        onInvalidTransition: function onInvalidTransition(transition, from, to) {\n          logger_1.log.warn('FSM: unexpected transition', from, to);\n        }\n      }\n    });\n    return _this;\n  }\n\n  _createClass(TwilsockChannel, [{\n    key: \"changeState\",\n    value: function changeState(event) {\n      logger_1.log.debug(\"FSM: \".concat(event.transition, \": \").concat(event.from, \" --> \").concat(event.to));\n\n      if (this.lastEmittedState !== this.state) {\n        this.lastEmittedState = this.state;\n        this.emit('stateChanged', this.state);\n      }\n    }\n  }, {\n    key: \"resetBackoff\",\n    value: function resetBackoff() {\n      logger_1.log.trace('resetBackoff');\n      this.retrier.stop();\n    }\n  }, {\n    key: \"modifyBackoff\",\n    value: function modifyBackoff(body) {\n      logger_1.log.trace('modifyBackoff', body);\n      var backoffPolicy = body ? body.backoff_policy : null;\n\n      if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === 'number') {\n        this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);\n      }\n    }\n  }, {\n    key: \"startDisconnectTimer\",\n    value: function startDisconnectTimer() {\n      var _this2 = this;\n\n      logger_1.log.trace('startDisconnectTimer');\n\n      if (this.disconnectingTimer) {\n        clearTimeout(this.disconnectingTimer);\n        this.disconnectingTimer = null;\n      }\n\n      this.disconnectingTimer = setTimeout(function () {\n        logger_1.log.debug('disconnecting is timed out');\n\n        _this2.closeSocket(true);\n      }, DISCONNECTING_TIMEOUT);\n    }\n  }, {\n    key: \"cancelDisconnectTimer\",\n    value: function cancelDisconnectTimer() {\n      logger_1.log.trace('cancelDisconnectTimer');\n\n      if (this.disconnectingTimer) {\n        clearTimeout(this.disconnectingTimer);\n        this.disconnectingTimer = null;\n      }\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      return this.state === 'connected' && this.websocket.isConnected;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      switch (this.fsm.state) {\n        case 'connecting':\n        case 'initialising':\n        case 'retrying':\n        case 'error':\n          return 'connecting';\n\n        case 'updating':\n        case 'connected':\n          return 'connected';\n\n        case 'rejected':\n          return 'rejected';\n\n        case 'disconnecting':\n        case 'waitSocketClosed':\n        case 'waitOffloadSocketClosed':\n          return 'disconnecting';\n\n        case 'disconnected':\n        default:\n          return 'disconnected';\n      }\n    }\n  }, {\n    key: \"initRetry\",\n    value: function initRetry() {\n      logger_1.log.debug('initRetry');\n\n      if (this.retrier.inProgress) {\n        this.retrier.attemptFailed();\n      } else {\n        this.retrier.start();\n      }\n    }\n  }, {\n    key: \"retry\",\n    value: function retry() {\n      if (this.fsm.state != 'connecting') {\n        logger_1.log.trace('retry');\n        this.websocket.close();\n        this.fsm.userRetry();\n      } else {\n        logger_1.log.trace('can\\t retry as already connecting');\n      }\n    }\n  }, {\n    key: \"onConnected\",\n    value: function onConnected() {\n      this.emit('connected');\n    }\n  }, {\n    key: \"finalizeSocket\",\n    value: function finalizeSocket() {\n      logger_1.log.trace('finalizeSocket');\n      this.websocket.close();\n      this.emit('disconnected');\n\n      if (this.disconnectedPromiseResolve) {\n        this.disconnectedPromiseResolve();\n        this.disconnectedPromiseResolve = null;\n      }\n    }\n  }, {\n    key: \"setupSocket\",\n    value: function setupSocket() {\n      logger_1.log.trace('setupSocket:', this.config.token);\n      this.emit('beforeConnect'); // This is used by client to record startup telemetry event\n\n      this.websocket.connect();\n    }\n  }, {\n    key: \"onIncomingMessage\",\n    value: function onIncomingMessage(message) {\n      var _parser_1$Parser$pars = parser_1.Parser.parse(message),\n          method = _parser_1$Parser$pars.method,\n          header = _parser_1$Parser$pars.header,\n          payload = _parser_1$Parser$pars.payload;\n\n      if (method !== 'reply') {\n        this.confirmReceiving(header);\n      }\n\n      if (method === 'notification') {\n        this.emit('message', header.message_type, payload);\n      } else if (header.method === 'reply') {\n        this.transport.processReply({\n          id: header.id,\n          status: header.status,\n          header: header,\n          body: payload\n        });\n      } else if (header.method === 'client_update') {\n        if (header.client_update_type === 'token_about_to_expire') {\n          this.emit('tokenAboutToExpire');\n        }\n      } else if (header.method === 'close') {\n        if (header.status.code === 308) {\n          logger_1.log.debug('Connection has been offloaded');\n          this.fsm.receiveOffload({\n            status: header.status.status,\n            body: payload\n          });\n        } else if (header.status.code === 406) {\n          // Not acceptable message\n          var _message = \"Server closed connection because can't parse protocol: \".concat(JSON.stringify(header.status));\n\n          this.emitReplyConnectionError(_message, header, true);\n          logger_1.log.error(_message);\n          this.fsm.receiveFatalClose();\n        } else if (header.status.code === 417) {\n          // Protocol error\n          logger_1.log.error(\"Server closed connection because can't parse client reply: \".concat(JSON.stringify(header.status)));\n          this.fsm.receiveFatalClose(header.status.status);\n        } else if (header.status.code === 410) {\n          // Expired token\n          logger_1.log.warn(\"Server closed connection: \".concat(JSON.stringify(header.status)));\n          this.fsm.receiveClose(header.status.status);\n          this.emit('tokenExpired');\n        } else if (header.status.code === 401) {\n          // Authentication fail\n          logger_1.log.error(\"Server closed connection: \".concat(JSON.stringify(header.status)));\n          this.fsm.receiveClose(header.status.status);\n        } else {\n          logger_1.log.warn('unexpected message: ', header.status); // Try to reconnect\n\n          this.fsm.receiveOffload({\n            status: header.status.status,\n            body: null\n          });\n        }\n      }\n    }\n  }, {\n    key: \"sendInit\",\n    value: function () {\n      var _sendInit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var reply, isTerminalError;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger_1.log.trace('sendInit');\n                _context.prev = 1;\n                this.emit('beforeSendInit'); // This is used by client to record startup telemetry event\n\n                _context.next = 5;\n                return this.transport.sendInit();\n\n              case 5:\n                reply = _context.sent;\n                this.config.updateContinuationToken(reply.continuationToken);\n                this.config.confirmedCapabilities = reply.confirmedCapabilities;\n                this.fsm.initSuccess(reply);\n                this.emit('initialized', reply);\n                this.emit('tokenUpdated');\n                _context.next = 17;\n                break;\n\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](1);\n\n                if (_context.t0 instanceof twilsockreplyerror_1.TwilsockReplyError) {\n                  isTerminalError = false;\n                  logger_1.log.warn(\"Init rejected by server: \".concat(JSON.stringify(_context.t0.reply.status)));\n                  this.emit('sendInitFailed'); // This is used by client to record startup telemetry event\n                  // @todo emit telemetry from inside \"if\" below for more granularity...\n\n                  if (_context.t0.reply.status.code === 401 || _context.t0.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(_context.t0.reply.status);\n\n                    if (_context.t0.reply.status.errorCode === this.tokenExpiredSasCode) {\n                      this.emit('tokenExpired');\n                    }\n                  } else if (_context.t0.reply.status.code === 429) {\n                    this.modifyBackoff(_context.t0.reply.body);\n                    this.fsm.initError(true);\n                  } else if (_context.t0.reply.status.code === 500) {\n                    this.fsm.initError(false);\n                  } else {\n                    this.fsm.initError(true);\n                  }\n\n                  this.emitReplyConnectionError(_context.t0.message, _context.t0.reply, isTerminalError);\n                } else {\n                  this.terminationReason = _context.t0.message;\n                  this.emit('connectionError', {\n                    terminal: true,\n                    message: _context.t0.message,\n                    httpStatusCode: null,\n                    errorCode: null\n                  });\n                  this.fsm.initError(true);\n                }\n\n                this.emit('tokenUpdated', _context.t0);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 13]]);\n      }));\n\n      function sendInit() {\n        return _sendInit.apply(this, arguments);\n      }\n\n      return sendInit;\n    }()\n  }, {\n    key: \"sendUpdate\",\n    value: function () {\n      var _sendUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var message, reply, isTerminalError;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                logger_1.log.trace('sendUpdate');\n                message = new Messages.Update(this.config.token);\n                _context2.prev = 2;\n                _context2.next = 5;\n                return this.transport.sendWithReply(message);\n\n              case 5:\n                reply = _context2.sent;\n                this.fsm.updateSuccess(reply.body);\n                this.emit('tokenUpdated');\n                _context2.next = 14;\n                break;\n\n              case 10:\n                _context2.prev = 10;\n                _context2.t0 = _context2[\"catch\"](2);\n\n                if (_context2.t0 instanceof twilsockreplyerror_1.TwilsockReplyError) {\n                  isTerminalError = false;\n                  logger_1.log.warn(\"Token update rejected by server: \".concat(JSON.stringify(_context2.t0.reply.status)));\n\n                  if (_context2.t0.reply.status.code === 401 || _context2.t0.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(_context2.t0.reply.status);\n\n                    if (_context2.t0.reply.status.errorCode === this.tokenExpiredSasCode) {\n                      this.emit('tokenExpired');\n                    }\n                  } else if (_context2.t0.reply.status.code === 429) {\n                    this.modifyBackoff(_context2.t0.reply.body);\n                    this.fsm.updateError(_context2.t0.reply.status);\n                  } else {\n                    this.fsm.updateError(_context2.t0.reply.status);\n                  }\n\n                  this.emitReplyConnectionError(_context2.t0.message, _context2.t0.reply, isTerminalError);\n                } else {\n                  this.emit('error', false, _context2.t0.message, null, null);\n                  this.fsm.updateError(_context2.t0);\n                }\n\n                this.emit('tokenUpdated', _context2.t0);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 10]]);\n      }));\n\n      function sendUpdate() {\n        return _sendUpdate.apply(this, arguments);\n      }\n\n      return sendUpdate;\n    }()\n  }, {\n    key: \"emitReplyConnectionError\",\n    value: function emitReplyConnectionError(message, header, terminal) {\n      var description = header.status && header.status.description ? header.status.description : message;\n      var httpStatusCode = header.status.code;\n      var errorCode = header.status && header.status.errorCode ? header.status.errorCode : null;\n\n      if (terminal) {\n        this.terminationReason = description;\n      }\n\n      this.emit('connectionError', {\n        terminal: terminal,\n        message: description,\n        httpStatusCode: httpStatusCode,\n        errorCode: errorCode\n      });\n    }\n  }, {\n    key: \"cancelInit\",\n    value: function cancelInit() {\n      logger_1.log.trace('cancelInit'); // TODO: implement\n    }\n  }, {\n    key: \"cancelUpdate\",\n    value: function cancelUpdate() {\n      logger_1.log.trace('cancelUpdate'); // TODO: implement\n    }\n    /**\n     * Should be called for each message to confirm it received\n     */\n\n  }, {\n    key: \"confirmReceiving\",\n    value: function confirmReceiving(messageHeader) {\n      logger_1.log.trace('confirmReceiving');\n\n      try {\n        //@todo send telemetry events AnyEvents\n        this.transport.send(new Messages.Reply(messageHeader.id));\n      } catch (e) {\n        logger_1.log.debug('failed to confirm packet receiving', e);\n      }\n    }\n    /**\n     * Shutdown connection\n     */\n\n  }, {\n    key: \"closeSocket\",\n    value: function closeSocket(graceful) {\n      var _this3 = this;\n\n      logger_1.log.trace(\"closeSocket (graceful: \".concat(graceful, \")\"));\n\n      if (graceful && this.transport.isConnected) {\n        this.transport.sendClose();\n      }\n\n      this.websocket.close();\n      trampoline(function () {\n        return _this3.fsm.socketClosed();\n      });\n    }\n    /**\n     * Initiate the twilsock connection\n     * If already connected, it does nothing\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      logger_1.log.trace('connect');\n      this.fsm.userConnect();\n    }\n    /**\n     * Close twilsock connection\n     * If already disconnected, it does nothing\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _this4 = this;\n\n      logger_1.log.trace('disconnect');\n\n      if (this.fsm.is('disconnected')) {\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve) {\n        _this4.disconnectedPromiseResolve = resolve;\n\n        _this4.fsm.userDisconnect();\n      });\n    }\n    /**\n     * Update fpa token for twilsock connection\n     */\n\n  }, {\n    key: \"updateToken\",\n    value: function updateToken(token) {\n      var _this5 = this;\n\n      logger_1.log.trace('updateToken:', token);\n      return new Promise(function (resolve, reject) {\n        _this5.once('tokenUpdated', function (e) {\n          if (e) {\n            reject(e);\n          } else {\n            resolve();\n          }\n        });\n\n        _this5.fsm.userUpdateToken();\n      });\n    }\n  }, {\n    key: \"isTerminalState\",\n    get: function get() {\n      return this.terminalStates.indexOf(this.fsm.state) !== -1;\n    }\n  }, {\n    key: \"getTerminationReason\",\n    get: function get() {\n      return this.terminationReason;\n    }\n  }, {\n    key: \"onCloseReceived\",\n    value: function onCloseReceived(reason) {\n      this.websocket.close();\n    }\n  }]);\n\n  return TwilsockChannel;\n}(events_1.EventEmitter);\n\nexports.TwilsockChannel = TwilsockChannel;\nexports.TwilsockImpl = TwilsockChannel;","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilsock/lib/twilsock.js"],"names":["Object","defineProperty","exports","value","TwilsockImpl","TwilsockChannel","Response","events_1","require","StateMachine","logger_1","Messages","parser_1","twilsockreplyerror_1","backoffretrier_1","DISCONNECTING_TIMEOUT","trampoline","f","setTimeout","preparePayload","payload","JSON","stringify","Request","websocket","transport","config","terminalStates","lastEmittedState","undefined","tokenExpiredSasCode","terminationReason","on","fsm","socketConnected","e","socketClosed","message","onIncomingMessage","emit","terminal","httpStatusCode","errorCode","retrier","BackoffRetrier","retryPolicy","retry","err","log","warn","disconnect","window","addEventListener","debug","systemOnline","close","init","transitions","name","from","to","methods","onConnecting","setupSocket","onEnterInitialising","sendInit","onLeaveInitialising","cancelInit","onEnterUpdating","sendUpdate","onLeaveUpdating","cancelUpdate","onEnterRetrying","initRetry","onEnterConnected","resetBackoff","onConnected","onUserUpdateToken","onTokenRejected","closeSocket","finalizeSocket","onUserDisconnect","onEnterDisconnecting","startDisconnectTimer","onLeaveDisconnecting","cancelDisconnectTimer","onEnterWaitSocketClosed","onLeaveWaitSocketClosed","onEnterWaitOffloadSocketClosed","onLeaveWaitOffloadSocketClosed","onDisconnected","onReceiveClose","event","args","onCloseReceived","onReceiveOffload","modifyBackoff","body","status","onUnsupported","onError","lifecycle","graceful","onEnterState","changeState","onInvalidTransition","transition","state","trace","stop","backoffPolicy","backoff_policy","reconnect_min_ms","disconnectingTimer","clearTimeout","isConnected","inProgress","attemptFailed","start","userRetry","disconnectedPromiseResolve","token","connect","Parser","parse","method","header","confirmReceiving","message_type","processReply","id","client_update_type","code","receiveOffload","emitReplyConnectionError","error","receiveFatalClose","receiveClose","reply","updateContinuationToken","continuationToken","confirmedCapabilities","initSuccess","TwilsockReplyError","isTerminalError","tokenRejected","initError","Update","sendWithReply","updateSuccess","updateError","description","messageHeader","send","Reply","sendClose","userConnect","is","Promise","resolve","userDisconnect","reject","once","userUpdateToken","indexOf","reason","EventEmitter"],"mappings":"AAAA;;;;;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,YAAR,GAAuBF,OAAO,CAACG,eAAR,GAA0BH,OAAO,CAACI,QAAR,GAAmB,KAAK,CAAzE;;AACA,IAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,IAAMC,YAAY,GAAGD,OAAO,CAAC,0BAAD,CAA5B;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAMG,QAAQ,GAAGH,OAAO,CAAC,qBAAD,CAAxB;;AACA,IAAMI,QAAQ,GAAGJ,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAMK,oBAAoB,GAAGL,OAAO,CAAC,4BAAD,CAApC;;AACA,IAAMM,gBAAgB,GAAGN,OAAO,CAAC,kBAAD,CAAhC;;AACA,IAAMO,qBAAqB,GAAG,IAA9B,C,CACA;AACA;;AACA,SAASC,UAAT,CAAoBC,CAApB,EAAuB;AACnBC,EAAAA,UAAU,CAACD,CAAD,EAAI,CAAJ,CAAV;AACH;AACD;AACA;AACA;;;AACA,SAASE,cAAT,CAAwBC,OAAxB,EAAiC;AAC7B,UAAQ,OAAOA,OAAf;AACI,SAAK,WAAL;AACI,aAAO,EAAP;;AACJ,SAAK,QAAL;AACI,aAAOC,IAAI,CAACC,SAAL,CAAeF,OAAf,CAAP;;AACJ;AACI,aAAOA,OAAP;AANR;AAQH;;IACKG,O;;;;IAEAjB,Q;;;;AAENJ,OAAO,CAACI,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;;IACMD,e;;;;;AACF,2BAAYmB,SAAZ,EAAuBC,SAAvB,EAAkCC,MAAlC,EAA0C;AAAA;;AAAA;;AACtC;AACA,UAAKC,cAAL,GAAsB,CAAC,cAAD,EAAiB,UAAjB,CAAtB;AACA,UAAKC,gBAAL,GAAwBC,SAAxB;AACA,UAAKC,mBAAL,GAA2B,KAA3B;AACA,UAAKC,iBAAL,GAAyB,+BAAzB;AACA,UAAKP,SAAL,GAAiBA,SAAjB;;AACA,UAAKA,SAAL,CAAeQ,EAAf,CAAkB,WAAlB,EAA+B;AAAA,aAAM,MAAKC,GAAL,CAASC,eAAT,EAAN;AAAA,KAA/B;;AACA,UAAKV,SAAL,CAAeQ,EAAf,CAAkB,cAAlB,EAAkC,UAACG,CAAD;AAAA,aAAO,MAAKF,GAAL,CAASG,YAAT,EAAP;AAAA,KAAlC;;AACA,UAAKZ,SAAL,CAAeQ,EAAf,CAAkB,SAAlB,EAA6B,UAACK,OAAD;AAAA,aAAa,MAAKC,iBAAL,CAAuBD,OAAvB,CAAb;AAAA,KAA7B;;AACA,UAAKb,SAAL,CAAeQ,EAAf,CAAkB,aAAlB,EAAiC,UAAAG,CAAC;AAAA,aAAI,MAAKI,IAAL,CAAU,iBAAV,EAA6B;AAAEC,QAAAA,QAAQ,EAAE,KAAZ;AAAmBH,QAAAA,OAAO,EAAEF,CAAC,CAACE,OAA9B;AAAuCI,QAAAA,cAAc,EAAE,IAAvD;AAA6DC,QAAAA,SAAS,EAAE;AAAxE,OAA7B,CAAJ;AAAA,KAAlC;;AACA,UAAKjB,SAAL,GAAiBA,SAAjB;AACA,UAAKC,MAAL,GAAcA,MAAd;AACA,UAAKiB,OAAL,GAAe,IAAI7B,gBAAgB,CAAC8B,cAArB,CAAoClB,MAAM,CAACmB,WAA3C,CAAf;;AACA,UAAKF,OAAL,CAAaX,EAAb,CAAgB,SAAhB,EAA2B;AAAA,aAAM,MAAKc,KAAL,EAAN;AAAA,KAA3B;;AACA,UAAKH,OAAL,CAAaX,EAAb,CAAgB,QAAhB,EAA0B,UAAAe,GAAG,EAAI;AAC7BrC,MAAAA,QAAQ,CAACsC,GAAT,CAAaC,IAAb,4BAAsCF,GAAG,CAACV,OAA1C;;AACA,YAAKa,UAAL;AACH,KAHD;;AAIA,QAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiC,OAAOA,MAAM,CAACC,gBAAd,KAAmC,WAAxE,EAAqF;AACjFD,MAAAA,MAAM,CAACC,gBAAP,CAAwB,QAAxB,EAAkC,YAAM;AACpC1C,QAAAA,QAAQ,CAACsC,GAAT,CAAaK,KAAb,CAAmB,6CAAnB;;AACA,cAAKpB,GAAL,CAASqB,YAAT;AACH,OAHD;AAIAH,MAAAA,MAAM,CAACC,gBAAP,CAAwB,SAAxB,EAAmC,YAAM;AACrC1C,QAAAA,QAAQ,CAACsC,GAAT,CAAaK,KAAb,CAAmB,8CAAnB;;AACA,cAAK7B,SAAL,CAAe+B,KAAf;;AACA,cAAKtB,GAAL,CAASG,YAAT;AACH,OAJD;AAKH;;AACD,UAAKH,GAAL,GAAW,IAAIxB,YAAJ,CAAiB;AACxB+C,MAAAA,IAAI,EAAE,cADkB;AAExBC,MAAAA,WAAW,EAAE,CACT;AAAEC,QAAAA,IAAI,EAAE,aAAR;AAAuBC,QAAAA,IAAI,EAAE,CAAC,cAAD,EAAiB,UAAjB,CAA7B;AAA2DC,QAAAA,EAAE,EAAE;AAA/D,OADS,EAET;AAAEF,QAAAA,IAAI,EAAE,aAAR;AAAuBC,QAAAA,IAAI,EAAE,CAAC,YAAD,EAAe,WAAf;AAA7B,OAFS,EAGT;AAAED,QAAAA,IAAI,EAAE,gBAAR;AAA0BC,QAAAA,IAAI,EAAE,CAAC,YAAD,EAAe,cAAf,EAA+B,WAA/B,EAA4C,UAA5C,EAAwD,UAAxD,EAAoE,UAApE,EACxB,kBADwB,EACJ,yBADI,CAAhC;AACwDC,QAAAA,EAAE,EAAE;AAD5D,OAHS,EAKT;AAAEF,QAAAA,IAAI,EAAE,WAAR;AAAqBC,QAAAA,IAAI,EAAE,CAAC,UAAD,CAA3B;AAAyCC,QAAAA,EAAE,EAAE;AAA7C,OALS,EAMT;AAAEF,QAAAA,IAAI,EAAE,iBAAR;AAA2BC,QAAAA,IAAI,EAAE,CAAC,YAAD,CAAjC;AAAiDC,QAAAA,EAAE,EAAE;AAArD,OANS,EAOT;AAAEF,QAAAA,IAAI,EAAE,cAAR;AAAwBC,QAAAA,IAAI,EAAE,CAAC,YAAD,EAAe,cAAf,EAA+B,WAA/B,EAA4C,UAA5C,EAAwD,OAAxD,EACtB,yBADsB,CAA9B;AACoCC,QAAAA,EAAE,EAAE;AADxC,OAPS,EAST;AAAEF,QAAAA,IAAI,EAAE,cAAR;AAAwBC,QAAAA,IAAI,EAAE,CAAC,eAAD,CAA9B;AAAiDC,QAAAA,EAAE,EAAE;AAArD,OATS,EAUT;AAAEF,QAAAA,IAAI,EAAE,cAAR;AAAwBC,QAAAA,IAAI,EAAE,CAAC,kBAAD,CAA9B;AAAoDC,QAAAA,EAAE,EAAE;AAAxD,OAVS,EAWT;AAAEF,QAAAA,IAAI,EAAE,cAAR;AAAwBC,QAAAA,IAAI,EAAE,CAAC,UAAD,CAA9B;AAA4CC,QAAAA,EAAE,EAAE;AAAhD,OAXS,EAYT;AAAEF,QAAAA,IAAI,EAAE,aAAR;AAAuBC,QAAAA,IAAI,EAAE,CAAC,cAAD,CAA7B;AAA+CC,QAAAA,EAAE,EAAE;AAAnD,OAZS,EAaT;AAAEF,QAAAA,IAAI,EAAE,WAAR;AAAqBC,QAAAA,IAAI,EAAE,CAAC,cAAD,CAA3B;AAA6CC,QAAAA,EAAE,EAAE;AAAjD,OAbS,EAcT;AAAEF,QAAAA,IAAI,EAAE,eAAR;AAAyBC,QAAAA,IAAI,EAAE,CAAC,cAAD,EAAiB,UAAjB,CAA/B;AAA6DC,QAAAA,EAAE,EAAE;AAAjE,OAdS,EAeT;AAAEF,QAAAA,IAAI,EAAE,eAAR;AAAyBC,QAAAA,IAAI,EAAE,CAAC,cAAD,EAAiB,WAAjB,EAA8B,UAA9B,CAA/B;AAA0EC,QAAAA,EAAE,EAAE;AAA9E,OAfS,EAgBT;AAAEF,QAAAA,IAAI,EAAE,cAAR;AAAwBC,QAAAA,IAAI,EAAE,CAAC,cAAD,EAAiB,WAAjB,EAA8B,UAA9B,CAA9B;AAAyEC,QAAAA,EAAE,EAAE;AAA7E,OAhBS,EAiBT;AAAEF,QAAAA,IAAI,EAAE,gBAAR;AAA0BC,QAAAA,IAAI,EAAE,CAAC,cAAD,EAAiB,WAAjB,EAA8B,UAA9B,CAAhC;AAA2EC,QAAAA,EAAE,EAAE;AAA/E,OAjBS,EAkBT;AAAEF,QAAAA,IAAI,EAAE,qBAAR;AAA+BC,QAAAA,IAAI,EAAE,CAAC,cAAD,EAAiB,WAAjB,EAA8B,UAA9B,CAArC;AAAgFC,QAAAA,EAAE,EAAE;AAApF,OAlBS,EAmBT;AAAEF,QAAAA,IAAI,EAAE,mBAAR;AAA6BC,QAAAA,IAAI,EAAE,CAAC,cAAD,EAAiB,WAAjB,EAA8B,UAA9B,CAAnC;AAA8EC,QAAAA,EAAE,EAAE;AAAlF,OAnBS,EAoBT;AAAEF,QAAAA,IAAI,EAAE,iBAAR;AAA2BC,QAAAA,IAAI,EAAE,CAAC,cAAD,EAAiB,UAAjB,EAA6B,YAA7B,EAA2C,UAA3C,CAAjC;AAAyFC,QAAAA,EAAE,EAAE;AAA7F,OApBS,EAqBT;AAAEF,QAAAA,IAAI,EAAE,iBAAR;AAA2BC,QAAAA,IAAI,EAAE,CAAC,WAAD,CAAjC;AAAgDC,QAAAA,EAAE,EAAE;AAApD,OArBS,EAsBT;AAAEF,QAAAA,IAAI,EAAE,eAAR;AAAyBC,QAAAA,IAAI,EAAE,CAAC,UAAD,CAA/B;AAA6CC,QAAAA,EAAE,EAAE;AAAjD,OAtBS,EAuBT;AAAEF,QAAAA,IAAI,EAAE,aAAR;AAAuBC,QAAAA,IAAI,EAAE,CAAC,UAAD,CAA7B;AAA2CC,QAAAA,EAAE,EAAE;AAA/C,OAvBS,EAwBT;AAAEF,QAAAA,IAAI,EAAE,UAAR;AAAoBC,QAAAA,IAAI,EAAE,CAAC,WAAD,CAA1B;AAAyCC,QAAAA,EAAE,EAAE;AAA7C,OAxBS,EAyBT;AAAEF,QAAAA,IAAI,EAAE,cAAR;AAAwBC,QAAAA,IAAI,EAAE,CAAC,UAAD,CAA9B;AAA4CC,QAAAA,EAAE,EAAE;AAAhD,OAzBS,CAFW;AA6BxBC,MAAAA,OAAO,EAAE;AACLC,QAAAA,YAAY,EAAE,wBAAM;AAChB,gBAAKC,WAAL;;AACA,gBAAKxB,IAAL,CAAU,YAAV;AACH,SAJI;AAKLyB,QAAAA,mBAAmB,EAAE,+BAAM;AACvB,gBAAKC,QAAL;AACH,SAPI;AAQLC,QAAAA,mBAAmB,EAAE,+BAAM;AACvB,gBAAKC,UAAL;AACH,SAVI;AAWLC,QAAAA,eAAe,EAAE,2BAAM;AACnB,gBAAKC,UAAL;AACH,SAbI;AAcLC,QAAAA,eAAe,EAAE,2BAAM;AACnB,gBAAKC,YAAL;AACH,SAhBI;AAiBLC,QAAAA,eAAe,EAAE,2BAAM;AACnB,gBAAKC,SAAL;;AACA,gBAAKlC,IAAL,CAAU,YAAV;AACH,SApBI;AAqBLmC,QAAAA,gBAAgB,EAAE,4BAAM;AACpB,gBAAKC,YAAL;;AACA,gBAAKC,WAAL;AACH,SAxBI;AAyBLC,QAAAA,iBAAiB,EAAE,6BAAM;AACrB,gBAAKF,YAAL;AACH,SA3BI;AA4BLG,QAAAA,eAAe,EAAE,2BAAM;AACnB,gBAAKH,YAAL;;AACA,gBAAKI,WAAL,CAAiB,IAAjB;;AACA,gBAAKC,cAAL;AACH,SAhCI;AAiCLC,QAAAA,gBAAgB,EAAE,4BAAM;AACpB,gBAAKF,WAAL,CAAiB,IAAjB;AACH,SAnCI;AAoCLG,QAAAA,oBAAoB,EAAE,gCAAM;AACxB,gBAAKC,oBAAL;AACH,SAtCI;AAuCLC,QAAAA,oBAAoB,EAAE,gCAAM;AACxB,gBAAKC,qBAAL;AACH,SAzCI;AA0CLC,QAAAA,uBAAuB,EAAE,mCAAM;AAC3B,gBAAKH,oBAAL;AACH,SA5CI;AA6CLI,QAAAA,uBAAuB,EAAE,mCAAM;AAC3B,gBAAKF,qBAAL;AACH,SA/CI;AAgDLG,QAAAA,8BAA8B,EAAE,0CAAM;AAClC,gBAAKL,oBAAL;AACH,SAlDI;AAmDLM,QAAAA,8BAA8B,EAAE,0CAAM;AAClC,gBAAKJ,qBAAL;AACH,SArDI;AAsDLK,QAAAA,cAAc,EAAE,0BAAM;AAClB,gBAAKf,YAAL;;AACA,gBAAKK,cAAL;AACH,SAzDI;AA0DLW,QAAAA,cAAc,EAAE,wBAACC,KAAD,EAAQC,IAAR,EAAiB;AAC7B,gBAAKC,eAAL,CAAqBD,IAArB;AACH,SA5DI;AA6DLE,QAAAA,gBAAgB,EAAE,0BAACH,KAAD,EAAQC,IAAR,EAAiB;AAC/BnF,UAAAA,QAAQ,CAACsC,GAAT,CAAaK,KAAb,CAAmB,oBAAnB,EAAyCwC,IAAzC;;AACA,gBAAKG,aAAL,CAAmBH,IAAI,CAACI,IAAxB;;AACA,gBAAKH,eAAL,CAAqBD,IAAI,CAACK,MAA1B;AACH,SAjEI;AAkELC,QAAAA,aAAa,EAAE,yBAAM;AACjB,gBAAKpB,WAAL,CAAiB,IAAjB;;AACA,gBAAKC,cAAL;AACH,SArEI;AAsELoB,QAAAA,OAAO,EAAE,iBAACC,SAAD,EAAYC,QAAZ,EAAyB;AAC9B,gBAAKvB,WAAL,CAAiBuB,QAAjB;;AACA,gBAAKtB,cAAL;AACH,SAzEI;AA0ELuB,QAAAA,YAAY,EAAE,sBAAAX,KAAK,EAAI;AACnB,cAAIA,KAAK,CAACjC,IAAN,KAAe,MAAnB,EAA2B;AACvB,kBAAK6C,WAAL,CAAiBZ,KAAjB;AACH;AACJ,SA9EI;AA+ELa,QAAAA,mBAAmB,EAAE,6BAACC,UAAD,EAAa/C,IAAb,EAAmBC,EAAnB,EAA0B;AAC3ClD,UAAAA,QAAQ,CAACsC,GAAT,CAAaC,IAAb,CAAkB,4BAAlB,EAAgDU,IAAhD,EAAsDC,EAAtD;AACH;AAjFI;AA7Be,KAAjB,CAAX;AA9BsC;AA+IzC;;;;WACD,qBAAYgC,KAAZ,EAAmB;AACflF,MAAAA,QAAQ,CAACsC,GAAT,CAAaK,KAAb,gBAA2BuC,KAAK,CAACc,UAAjC,eAAgDd,KAAK,CAACjC,IAAtD,kBAAkEiC,KAAK,CAAChC,EAAxE;;AACA,UAAI,KAAKhC,gBAAL,KAA0B,KAAK+E,KAAnC,EAA0C;AACtC,aAAK/E,gBAAL,GAAwB,KAAK+E,KAA7B;AACA,aAAKpE,IAAL,CAAU,cAAV,EAA0B,KAAKoE,KAA/B;AACH;AACJ;;;WACD,wBAAe;AACXjG,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,cAAnB;AACA,WAAKjE,OAAL,CAAakE,IAAb;AACH;;;WACD,uBAAcZ,IAAd,EAAoB;AAChBvF,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,eAAnB,EAAoCX,IAApC;AACA,UAAIa,aAAa,GAAGb,IAAI,GAAGA,IAAI,CAACc,cAAR,GAAyB,IAAjD;;AACA,UAAID,aAAa,IAAI,OAAOA,aAAa,CAACE,gBAArB,KAA0C,QAA/D,EAAyE;AACrE,aAAKrE,OAAL,CAAaqD,aAAb,CAA2Bc,aAAa,CAACE,gBAAzC;AACH;AACJ;;;WACD,gCAAuB;AAAA;;AACnBtG,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,sBAAnB;;AACA,UAAI,KAAKK,kBAAT,EAA6B;AACzBC,QAAAA,YAAY,CAAC,KAAKD,kBAAN,CAAZ;AACA,aAAKA,kBAAL,GAA0B,IAA1B;AACH;;AACD,WAAKA,kBAAL,GAA0B/F,UAAU,CAAC,YAAM;AACvCR,QAAAA,QAAQ,CAACsC,GAAT,CAAaK,KAAb,CAAmB,4BAAnB;;AACA,QAAA,MAAI,CAAC0B,WAAL,CAAiB,IAAjB;AACH,OAHmC,EAGjChE,qBAHiC,CAApC;AAIH;;;WACD,iCAAwB;AACpBL,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,uBAAnB;;AACA,UAAI,KAAKK,kBAAT,EAA6B;AACzBC,QAAAA,YAAY,CAAC,KAAKD,kBAAN,CAAZ;AACA,aAAKA,kBAAL,GAA0B,IAA1B;AACH;AACJ;;;SACD,eAAkB;AACd,aAAO,KAAKN,KAAL,KAAe,WAAf,IAA8B,KAAKnF,SAAL,CAAe2F,WAApD;AACH;;;SACD,eAAY;AACR,cAAQ,KAAKlF,GAAL,CAAS0E,KAAjB;AACI,aAAK,YAAL;AACA,aAAK,cAAL;AACA,aAAK,UAAL;AACA,aAAK,OAAL;AACI,iBAAO,YAAP;;AACJ,aAAK,UAAL;AACA,aAAK,WAAL;AACI,iBAAO,WAAP;;AACJ,aAAK,UAAL;AACI,iBAAO,UAAP;;AACJ,aAAK,eAAL;AACA,aAAK,kBAAL;AACA,aAAK,yBAAL;AACI,iBAAO,eAAP;;AACJ,aAAK,cAAL;AACA;AACI,iBAAO,cAAP;AAjBR;AAmBH;;;WACD,qBAAY;AACRjG,MAAAA,QAAQ,CAACsC,GAAT,CAAaK,KAAb,CAAmB,WAAnB;;AACA,UAAI,KAAKV,OAAL,CAAayE,UAAjB,EAA6B;AACzB,aAAKzE,OAAL,CAAa0E,aAAb;AACH,OAFD,MAGK;AACD,aAAK1E,OAAL,CAAa2E,KAAb;AACH;AACJ;;;WACD,iBAAQ;AACJ,UAAI,KAAKrF,GAAL,CAAS0E,KAAT,IAAkB,YAAtB,EAAoC;AAChCjG,QAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,OAAnB;AACA,aAAKpF,SAAL,CAAe+B,KAAf;AACA,aAAKtB,GAAL,CAASsF,SAAT;AACH,OAJD,MAKK;AACD7G,QAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,mCAAnB;AACH;AACJ;;;WACD,uBAAc;AACV,WAAKrE,IAAL,CAAU,WAAV;AACH;;;WACD,0BAAiB;AACb7B,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,gBAAnB;AACA,WAAKpF,SAAL,CAAe+B,KAAf;AACA,WAAKhB,IAAL,CAAU,cAAV;;AACA,UAAI,KAAKiF,0BAAT,EAAqC;AACjC,aAAKA,0BAAL;AACA,aAAKA,0BAAL,GAAkC,IAAlC;AACH;AACJ;;;WACD,uBAAc;AACV9G,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,cAAnB,EAAmC,KAAKlF,MAAL,CAAY+F,KAA/C;AACA,WAAKlF,IAAL,CAAU,eAAV,EAFU,CAEkB;;AAC5B,WAAKf,SAAL,CAAekG,OAAf;AACH;;;WACD,2BAAkBrF,OAAlB,EAA2B;AAAA,kCACWzB,QAAQ,CAAC+G,MAAT,CAAgBC,KAAhB,CAAsBvF,OAAtB,CADX;AAAA,UACjBwF,MADiB,yBACjBA,MADiB;AAAA,UACTC,MADS,yBACTA,MADS;AAAA,UACD1G,OADC,yBACDA,OADC;;AAEvB,UAAIyG,MAAM,KAAK,OAAf,EAAwB;AACpB,aAAKE,gBAAL,CAAsBD,MAAtB;AACH;;AACD,UAAID,MAAM,KAAK,cAAf,EAA+B;AAC3B,aAAKtF,IAAL,CAAU,SAAV,EAAqBuF,MAAM,CAACE,YAA5B,EAA0C5G,OAA1C;AACH,OAFD,MAGK,IAAI0G,MAAM,CAACD,MAAP,KAAkB,OAAtB,EAA+B;AAChC,aAAKpG,SAAL,CAAewG,YAAf,CAA4B;AACxBC,UAAAA,EAAE,EAAEJ,MAAM,CAACI,EADa;AAExBhC,UAAAA,MAAM,EAAE4B,MAAM,CAAC5B,MAFS;AAGxB4B,UAAAA,MAAM,EAAEA,MAHgB;AAIxB7B,UAAAA,IAAI,EAAE7E;AAJkB,SAA5B;AAMH,OAPI,MAQA,IAAI0G,MAAM,CAACD,MAAP,KAAkB,eAAtB,EAAuC;AACxC,YAAIC,MAAM,CAACK,kBAAP,KAA8B,uBAAlC,EAA2D;AACvD,eAAK5F,IAAL,CAAU,oBAAV;AACH;AACJ,OAJI,MAKA,IAAIuF,MAAM,CAACD,MAAP,KAAkB,OAAtB,EAA+B;AAChC,YAAIC,MAAM,CAAC5B,MAAP,CAAckC,IAAd,KAAuB,GAA3B,EAAgC;AAC5B1H,UAAAA,QAAQ,CAACsC,GAAT,CAAaK,KAAb,CAAmB,+BAAnB;AACA,eAAKpB,GAAL,CAASoG,cAAT,CAAwB;AAAEnC,YAAAA,MAAM,EAAE4B,MAAM,CAAC5B,MAAP,CAAcA,MAAxB;AAAgCD,YAAAA,IAAI,EAAE7E;AAAtC,WAAxB;AACH,SAHD,MAIK,IAAI0G,MAAM,CAAC5B,MAAP,CAAckC,IAAd,KAAuB,GAA3B,EAAgC;AAAE;AACnC,cAAM/F,QAAO,oEAA6DhB,IAAI,CAACC,SAAL,CAAewG,MAAM,CAAC5B,MAAtB,CAA7D,CAAb;;AACA,eAAKoC,wBAAL,CAA8BjG,QAA9B,EAAuCyF,MAAvC,EAA+C,IAA/C;AACApH,UAAAA,QAAQ,CAACsC,GAAT,CAAauF,KAAb,CAAmBlG,QAAnB;AACA,eAAKJ,GAAL,CAASuG,iBAAT;AACH,SALI,MAMA,IAAIV,MAAM,CAAC5B,MAAP,CAAckC,IAAd,KAAuB,GAA3B,EAAgC;AAAE;AACnC1H,UAAAA,QAAQ,CAACsC,GAAT,CAAauF,KAAb,sEAAiFlH,IAAI,CAACC,SAAL,CAAewG,MAAM,CAAC5B,MAAtB,CAAjF;AACA,eAAKjE,GAAL,CAASuG,iBAAT,CAA2BV,MAAM,CAAC5B,MAAP,CAAcA,MAAzC;AACH,SAHI,MAIA,IAAI4B,MAAM,CAAC5B,MAAP,CAAckC,IAAd,KAAuB,GAA3B,EAAgC;AAAE;AACnC1H,UAAAA,QAAQ,CAACsC,GAAT,CAAaC,IAAb,qCAA+C5B,IAAI,CAACC,SAAL,CAAewG,MAAM,CAAC5B,MAAtB,CAA/C;AACA,eAAKjE,GAAL,CAASwG,YAAT,CAAsBX,MAAM,CAAC5B,MAAP,CAAcA,MAApC;AACA,eAAK3D,IAAL,CAAU,cAAV;AACH,SAJI,MAKA,IAAIuF,MAAM,CAAC5B,MAAP,CAAckC,IAAd,KAAuB,GAA3B,EAAgC;AAAE;AACnC1H,UAAAA,QAAQ,CAACsC,GAAT,CAAauF,KAAb,qCAAgDlH,IAAI,CAACC,SAAL,CAAewG,MAAM,CAAC5B,MAAtB,CAAhD;AACA,eAAKjE,GAAL,CAASwG,YAAT,CAAsBX,MAAM,CAAC5B,MAAP,CAAcA,MAApC;AACH,SAHI,MAIA;AACDxF,UAAAA,QAAQ,CAACsC,GAAT,CAAaC,IAAb,CAAkB,sBAAlB,EAA0C6E,MAAM,CAAC5B,MAAjD,EADC,CAED;;AACA,eAAKjE,GAAL,CAASoG,cAAT,CAAwB;AAAEnC,YAAAA,MAAM,EAAE4B,MAAM,CAAC5B,MAAP,CAAcA,MAAxB;AAAgCD,YAAAA,IAAI,EAAE;AAAtC,WAAxB;AACH;AACJ;AACJ;;;;+EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AACIvF,gBAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,UAAnB;AADJ;AAGQ,qBAAKrE,IAAL,CAAU,gBAAV,EAHR,CAGqC;;AAHrC;AAAA,uBAI0B,KAAKd,SAAL,CAAewC,QAAf,EAJ1B;;AAAA;AAIYyE,gBAAAA,KAJZ;AAKQ,qBAAKhH,MAAL,CAAYiH,uBAAZ,CAAoCD,KAAK,CAACE,iBAA1C;AACA,qBAAKlH,MAAL,CAAYmH,qBAAZ,GAAoCH,KAAK,CAACG,qBAA1C;AACA,qBAAK5G,GAAL,CAAS6G,WAAT,CAAqBJ,KAArB;AACA,qBAAKnG,IAAL,CAAU,aAAV,EAAyBmG,KAAzB;AACA,qBAAKnG,IAAL,CAAU,cAAV;AATR;AAAA;;AAAA;AAAA;AAAA;;AAYQ,oBAAI,uBAAc1B,oBAAoB,CAACkI,kBAAvC,EAA2D;AACnDC,kBAAAA,eADmD,GACjC,KADiC;AAEvDtI,kBAAAA,QAAQ,CAACsC,GAAT,CAAaC,IAAb,oCAA8C5B,IAAI,CAACC,SAAL,CAAe,YAAGoH,KAAH,CAASxC,MAAxB,CAA9C;AACA,uBAAK3D,IAAL,CAAU,gBAAV,EAHuD,CAG1B;AAC7B;;AACA,sBAAI,YAAGmG,KAAH,CAASxC,MAAT,CAAgBkC,IAAhB,KAAyB,GAAzB,IAAgC,YAAGM,KAAH,CAASxC,MAAT,CAAgBkC,IAAhB,KAAyB,GAA7D,EAAkE;AAC9DY,oBAAAA,eAAe,GAAG,IAAlB;AACA,yBAAK/G,GAAL,CAASgH,aAAT,CAAuB,YAAGP,KAAH,CAASxC,MAAhC;;AACA,wBAAI,YAAGwC,KAAH,CAASxC,MAAT,CAAgBxD,SAAhB,KAA8B,KAAKZ,mBAAvC,EAA4D;AACxD,2BAAKS,IAAL,CAAU,cAAV;AACH;AACJ,mBAND,MAOK,IAAI,YAAGmG,KAAH,CAASxC,MAAT,CAAgBkC,IAAhB,KAAyB,GAA7B,EAAkC;AACnC,yBAAKpC,aAAL,CAAmB,YAAG0C,KAAH,CAASzC,IAA5B;AACA,yBAAKhE,GAAL,CAASiH,SAAT,CAAmB,IAAnB;AACH,mBAHI,MAIA,IAAI,YAAGR,KAAH,CAASxC,MAAT,CAAgBkC,IAAhB,KAAyB,GAA7B,EAAkC;AACnC,yBAAKnG,GAAL,CAASiH,SAAT,CAAmB,KAAnB;AACH,mBAFI,MAGA;AACD,yBAAKjH,GAAL,CAASiH,SAAT,CAAmB,IAAnB;AACH;;AACD,uBAAKZ,wBAAL,CAA8B,YAAGjG,OAAjC,EAA0C,YAAGqG,KAA7C,EAAoDM,eAApD;AACH,iBAvBD,MAwBK;AACD,uBAAKjH,iBAAL,GAAyB,YAAGM,OAA5B;AACA,uBAAKE,IAAL,CAAU,iBAAV,EAA6B;AAAEC,oBAAAA,QAAQ,EAAE,IAAZ;AAAkBH,oBAAAA,OAAO,EAAE,YAAGA,OAA9B;AAAuCI,oBAAAA,cAAc,EAAE,IAAvD;AAA6DC,oBAAAA,SAAS,EAAE;AAAxE,mBAA7B;AACA,uBAAKT,GAAL,CAASiH,SAAT,CAAmB,IAAnB;AACH;;AACD,qBAAK3G,IAAL,CAAU,cAAV;;AAzCR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;iFA4CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACI7B,gBAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,YAAnB;AACIvE,gBAAAA,OAFR,GAEkB,IAAI1B,QAAQ,CAACwI,MAAb,CAAoB,KAAKzH,MAAL,CAAY+F,KAAhC,CAFlB;AAAA;AAAA;AAAA,uBAI0B,KAAKhG,SAAL,CAAe2H,aAAf,CAA6B/G,OAA7B,CAJ1B;;AAAA;AAIYqG,gBAAAA,KAJZ;AAKQ,qBAAKzG,GAAL,CAASoH,aAAT,CAAuBX,KAAK,CAACzC,IAA7B;AACA,qBAAK1D,IAAL,CAAU,cAAV;AANR;AAAA;;AAAA;AAAA;AAAA;;AASQ,oBAAI,wBAAc1B,oBAAoB,CAACkI,kBAAvC,EAA2D;AACnDC,kBAAAA,eADmD,GACjC,KADiC;AAEvDtI,kBAAAA,QAAQ,CAACsC,GAAT,CAAaC,IAAb,4CAAsD5B,IAAI,CAACC,SAAL,CAAe,aAAGoH,KAAH,CAASxC,MAAxB,CAAtD;;AACA,sBAAI,aAAGwC,KAAH,CAASxC,MAAT,CAAgBkC,IAAhB,KAAyB,GAAzB,IAAgC,aAAGM,KAAH,CAASxC,MAAT,CAAgBkC,IAAhB,KAAyB,GAA7D,EAAkE;AAC9DY,oBAAAA,eAAe,GAAG,IAAlB;AACA,yBAAK/G,GAAL,CAASgH,aAAT,CAAuB,aAAGP,KAAH,CAASxC,MAAhC;;AACA,wBAAI,aAAGwC,KAAH,CAASxC,MAAT,CAAgBxD,SAAhB,KAA8B,KAAKZ,mBAAvC,EAA4D;AACxD,2BAAKS,IAAL,CAAU,cAAV;AACH;AACJ,mBAND,MAOK,IAAI,aAAGmG,KAAH,CAASxC,MAAT,CAAgBkC,IAAhB,KAAyB,GAA7B,EAAkC;AACnC,yBAAKpC,aAAL,CAAmB,aAAG0C,KAAH,CAASzC,IAA5B;AACA,yBAAKhE,GAAL,CAASqH,WAAT,CAAqB,aAAGZ,KAAH,CAASxC,MAA9B;AACH,mBAHI,MAIA;AACD,yBAAKjE,GAAL,CAASqH,WAAT,CAAqB,aAAGZ,KAAH,CAASxC,MAA9B;AACH;;AACD,uBAAKoC,wBAAL,CAA8B,aAAGjG,OAAjC,EAA0C,aAAGqG,KAA7C,EAAoDM,eAApD;AACH,iBAlBD,MAmBK;AACD,uBAAKzG,IAAL,CAAU,OAAV,EAAmB,KAAnB,EAA0B,aAAGF,OAA7B,EAAsC,IAAtC,EAA4C,IAA5C;AACA,uBAAKJ,GAAL,CAASqH,WAAT;AACH;;AACD,qBAAK/G,IAAL,CAAU,cAAV;;AAhCR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAmCA,kCAAyBF,OAAzB,EAAkCyF,MAAlC,EAA0CtF,QAA1C,EAAoD;AAChD,UAAM+G,WAAW,GAAGzB,MAAM,CAAC5B,MAAP,IAAiB4B,MAAM,CAAC5B,MAAP,CAAcqD,WAA/B,GACdzB,MAAM,CAAC5B,MAAP,CAAcqD,WADA,GAEdlH,OAFN;AAGA,UAAMI,cAAc,GAAGqF,MAAM,CAAC5B,MAAP,CAAckC,IAArC;AACA,UAAM1F,SAAS,GAAGoF,MAAM,CAAC5B,MAAP,IAAiB4B,MAAM,CAAC5B,MAAP,CAAcxD,SAA/B,GACZoF,MAAM,CAAC5B,MAAP,CAAcxD,SADF,GAEZ,IAFN;;AAGA,UAAIF,QAAJ,EAAc;AACV,aAAKT,iBAAL,GAAyBwH,WAAzB;AACH;;AACD,WAAKhH,IAAL,CAAU,iBAAV,EAA6B;AAAEC,QAAAA,QAAQ,EAAEA,QAAZ;AAAsBH,QAAAA,OAAO,EAAEkH,WAA/B;AAA4C9G,QAAAA,cAAc,EAAEA,cAA5D;AAA4EC,QAAAA,SAAS,EAAEA;AAAvF,OAA7B;AACH;;;WACD,sBAAa;AACThC,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,YAAnB,EADS,CAET;AACH;;;WACD,wBAAe;AACXlG,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,cAAnB,EADW,CAEX;AACH;AACD;AACJ;AACA;;;;WACI,0BAAiB4C,aAAjB,EAAgC;AAC5B9I,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,kBAAnB;;AACA,UAAI;AACA;AACA,aAAKnF,SAAL,CAAegI,IAAf,CAAoB,IAAI9I,QAAQ,CAAC+I,KAAb,CAAmBF,aAAa,CAACtB,EAAjC,CAApB;AACH,OAHD,CAIA,OAAO/F,CAAP,EAAU;AACNzB,QAAAA,QAAQ,CAACsC,GAAT,CAAaK,KAAb,CAAmB,oCAAnB,EAAyDlB,CAAzD;AACH;AACJ;AACD;AACJ;AACA;;;;WACI,qBAAYmE,QAAZ,EAAsB;AAAA;;AAClB5F,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,kCAA6CN,QAA7C;;AACA,UAAIA,QAAQ,IAAI,KAAK7E,SAAL,CAAe0F,WAA/B,EAA4C;AACxC,aAAK1F,SAAL,CAAekI,SAAf;AACH;;AACD,WAAKnI,SAAL,CAAe+B,KAAf;AACAvC,MAAAA,UAAU,CAAC;AAAA,eAAM,MAAI,CAACiB,GAAL,CAASG,YAAT,EAAN;AAAA,OAAD,CAAV;AACH;AACD;AACJ;AACA;AACA;;;;WACI,mBAAU;AACN1B,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,SAAnB;AACA,WAAK3E,GAAL,CAAS2H,WAAT;AACH;AACD;AACJ;AACA;AACA;;;;WACI,sBAAa;AAAA;;AACTlJ,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,YAAnB;;AACA,UAAI,KAAK3E,GAAL,CAAS4H,EAAT,CAAY,cAAZ,CAAJ,EAAiC;AAC7B,eAAOC,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,aAAO,IAAID,OAAJ,CAAY,UAACC,OAAD,EAAa;AAC5B,QAAA,MAAI,CAACvC,0BAAL,GAAkCuC,OAAlC;;AACA,QAAA,MAAI,CAAC9H,GAAL,CAAS+H,cAAT;AACH,OAHM,CAAP;AAIH;AACD;AACJ;AACA;;;;WACI,qBAAYvC,KAAZ,EAAmB;AAAA;;AACf/G,MAAAA,QAAQ,CAACsC,GAAT,CAAa4D,KAAb,CAAmB,cAAnB,EAAmCa,KAAnC;AACA,aAAO,IAAIqC,OAAJ,CAAY,UAACC,OAAD,EAAUE,MAAV,EAAqB;AACpC,QAAA,MAAI,CAACC,IAAL,CAAU,cAAV,EAA0B,UAAA/H,CAAC,EAAI;AAC3B,cAAIA,CAAJ,EAAO;AACH8H,YAAAA,MAAM,CAAC9H,CAAD,CAAN;AACH,WAFD,MAGK;AACD4H,YAAAA,OAAO;AACV;AACJ,SAPD;;AAQA,QAAA,MAAI,CAAC9H,GAAL,CAASkI,eAAT;AACH,OAVM,CAAP;AAWH;;;SACD,eAAsB;AAClB,aAAO,KAAKxI,cAAL,CAAoByI,OAApB,CAA4B,KAAKnI,GAAL,CAAS0E,KAArC,MAAgD,CAAC,CAAxD;AACH;;;SACD,eAA2B;AACvB,aAAO,KAAK5E,iBAAZ;AACH;;;WACD,yBAAgBsI,MAAhB,EAAwB;AACpB,WAAK7I,SAAL,CAAe+B,KAAf;AACH;;;;EAhdyBhD,QAAQ,CAAC+J,Y;;AAkdvCpK,OAAO,CAACG,eAAR,GAA0BA,eAA1B;AACAH,OAAO,CAACE,YAAR,GAAuBC,eAAvB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TwilsockImpl = exports.TwilsockChannel = exports.Response = void 0;\nconst events_1 = require(\"events\");\nconst StateMachine = require(\"javascript-state-machine\");\nconst logger_1 = require(\"./logger\");\nconst Messages = require(\"./protocol/messages\");\nconst parser_1 = require(\"./parser\");\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\nconst backoffretrier_1 = require(\"./backoffretrier\");\nconst DISCONNECTING_TIMEOUT = 3000;\n// Wraps asynchronous rescheduling\n// Just makes it simpler to find these hacks over the code\nfunction trampoline(f) {\n    setTimeout(f, 0);\n}\n/**\n * Makes sure that body is properly stringified\n */\nfunction preparePayload(payload) {\n    switch (typeof payload) {\n        case 'undefined':\n            return '';\n        case 'object':\n            return JSON.stringify(payload);\n        default:\n            return payload;\n    }\n}\nclass Request {\n}\nclass Response {\n}\nexports.Response = Response;\n/**\n * Twilsock channel level protocol implementation\n */\nclass TwilsockChannel extends events_1.EventEmitter {\n    constructor(websocket, transport, config) {\n        super();\n        this.terminalStates = ['disconnected', 'rejected'];\n        this.lastEmittedState = undefined;\n        this.tokenExpiredSasCode = 20104;\n        this.terminationReason = 'Connection is not initialized';\n        this.websocket = websocket;\n        this.websocket.on('connected', () => this.fsm.socketConnected());\n        this.websocket.on('disconnected', (e) => this.fsm.socketClosed());\n        this.websocket.on('message', (message) => this.onIncomingMessage(message));\n        this.websocket.on('socketError', e => this.emit('connectionError', { terminal: false, message: e.message, httpStatusCode: null, errorCode: null }));\n        this.transport = transport;\n        this.config = config;\n        this.retrier = new backoffretrier_1.BackoffRetrier(config.retryPolicy);\n        this.retrier.on('attempt', () => this.retry());\n        this.retrier.on('failed', err => {\n            logger_1.log.warn(`Retrying failed: ${err.message}`);\n            this.disconnect();\n        });\n        if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n            window.addEventListener('online', () => {\n                logger_1.log.debug('Browser reported connectivity state: online');\n                this.fsm.systemOnline();\n            });\n            window.addEventListener('offline', () => {\n                logger_1.log.debug('Browser reported connectivity state: offline');\n                this.websocket.close();\n                this.fsm.socketClosed();\n            });\n        }\n        this.fsm = new StateMachine({\n            init: 'disconnected',\n            transitions: [\n                { name: 'userConnect', from: ['disconnected', 'rejected'], to: 'connecting' },\n                { name: 'userConnect', from: ['connecting', 'connected'] },\n                { name: 'userDisconnect', from: ['connecting', 'initialising', 'connected', 'updating', 'retrying', 'rejected',\n                        'waitSocketClosed', 'waitOffloadSocketClosed'], to: 'disconnecting' },\n                { name: 'userRetry', from: ['retrying'], to: 'connecting' },\n                { name: 'socketConnected', from: ['connecting'], to: 'initialising' },\n                { name: 'socketClosed', from: ['connecting', 'initialising', 'connected', 'updating', 'error',\n                        'waitOffloadSocketClosed'], to: 'retrying' },\n                { name: 'socketClosed', from: ['disconnecting'], to: 'disconnected' },\n                { name: 'socketClosed', from: ['waitSocketClosed'], to: 'disconnected' },\n                { name: 'socketClosed', from: ['rejected'], to: 'rejected' },\n                { name: 'initSuccess', from: ['initialising'], to: 'connected' },\n                { name: 'initError', from: ['initialising'], to: 'error' },\n                { name: 'tokenRejected', from: ['initialising', 'updating'], to: 'rejected' },\n                { name: 'protocolError', from: ['initialising', 'connected', 'updating'], to: 'error' },\n                { name: 'receiveClose', from: ['initialising', 'connected', 'updating'], to: 'waitSocketClosed' },\n                { name: 'receiveOffload', from: ['initialising', 'connected', 'updating'], to: 'waitOffloadSocketClosed' },\n                { name: 'unsupportedProtocol', from: ['initialising', 'connected', 'updating'], to: 'unsupported' },\n                { name: 'receiveFatalClose', from: ['initialising', 'connected', 'updating'], to: 'unsupported' },\n                { name: 'userUpdateToken', from: ['disconnected', 'rejected', 'connecting', 'retrying'], to: 'connecting' },\n                { name: 'userUpdateToken', from: ['connected'], to: 'updating' },\n                { name: 'updateSuccess', from: ['updating'], to: 'connected' },\n                { name: 'updateError', from: ['updating'], to: 'error' },\n                { name: 'userSend', from: ['connected'], to: 'connected' },\n                { name: 'systemOnline', from: ['retrying'], to: 'connecting' }\n            ],\n            methods: {\n                onConnecting: () => {\n                    this.setupSocket();\n                    this.emit('connecting');\n                },\n                onEnterInitialising: () => {\n                    this.sendInit();\n                },\n                onLeaveInitialising: () => {\n                    this.cancelInit();\n                },\n                onEnterUpdating: () => {\n                    this.sendUpdate();\n                },\n                onLeaveUpdating: () => {\n                    this.cancelUpdate();\n                },\n                onEnterRetrying: () => {\n                    this.initRetry();\n                    this.emit('connecting');\n                },\n                onEnterConnected: () => {\n                    this.resetBackoff();\n                    this.onConnected();\n                },\n                onUserUpdateToken: () => {\n                    this.resetBackoff();\n                },\n                onTokenRejected: () => {\n                    this.resetBackoff();\n                    this.closeSocket(true);\n                    this.finalizeSocket();\n                },\n                onUserDisconnect: () => {\n                    this.closeSocket(true);\n                },\n                onEnterDisconnecting: () => {\n                    this.startDisconnectTimer();\n                },\n                onLeaveDisconnecting: () => {\n                    this.cancelDisconnectTimer();\n                },\n                onEnterWaitSocketClosed: () => {\n                    this.startDisconnectTimer();\n                },\n                onLeaveWaitSocketClosed: () => {\n                    this.cancelDisconnectTimer();\n                },\n                onEnterWaitOffloadSocketClosed: () => {\n                    this.startDisconnectTimer();\n                },\n                onLeaveWaitOffloadSocketClosed: () => {\n                    this.cancelDisconnectTimer();\n                },\n                onDisconnected: () => {\n                    this.resetBackoff();\n                    this.finalizeSocket();\n                },\n                onReceiveClose: (event, args) => {\n                    this.onCloseReceived(args);\n                },\n                onReceiveOffload: (event, args) => {\n                    logger_1.log.debug('onreceiveoffload: ', args);\n                    this.modifyBackoff(args.body);\n                    this.onCloseReceived(args.status);\n                },\n                onUnsupported: () => {\n                    this.closeSocket(true);\n                    this.finalizeSocket();\n                },\n                onError: (lifecycle, graceful) => {\n                    this.closeSocket(graceful);\n                    this.finalizeSocket();\n                },\n                onEnterState: event => {\n                    if (event.from !== 'none') {\n                        this.changeState(event);\n                    }\n                },\n                onInvalidTransition: (transition, from, to) => {\n                    logger_1.log.warn('FSM: unexpected transition', from, to);\n                }\n            }\n        });\n    }\n    changeState(event) {\n        logger_1.log.debug(`FSM: ${event.transition}: ${event.from} --> ${event.to}`);\n        if (this.lastEmittedState !== this.state) {\n            this.lastEmittedState = this.state;\n            this.emit('stateChanged', this.state);\n        }\n    }\n    resetBackoff() {\n        logger_1.log.trace('resetBackoff');\n        this.retrier.stop();\n    }\n    modifyBackoff(body) {\n        logger_1.log.trace('modifyBackoff', body);\n        let backoffPolicy = body ? body.backoff_policy : null;\n        if (backoffPolicy && typeof backoffPolicy.reconnect_min_ms === 'number') {\n            this.retrier.modifyBackoff(backoffPolicy.reconnect_min_ms);\n        }\n    }\n    startDisconnectTimer() {\n        logger_1.log.trace('startDisconnectTimer');\n        if (this.disconnectingTimer) {\n            clearTimeout(this.disconnectingTimer);\n            this.disconnectingTimer = null;\n        }\n        this.disconnectingTimer = setTimeout(() => {\n            logger_1.log.debug('disconnecting is timed out');\n            this.closeSocket(true);\n        }, DISCONNECTING_TIMEOUT);\n    }\n    cancelDisconnectTimer() {\n        logger_1.log.trace('cancelDisconnectTimer');\n        if (this.disconnectingTimer) {\n            clearTimeout(this.disconnectingTimer);\n            this.disconnectingTimer = null;\n        }\n    }\n    get isConnected() {\n        return this.state === 'connected' && this.websocket.isConnected;\n    }\n    get state() {\n        switch (this.fsm.state) {\n            case 'connecting':\n            case 'initialising':\n            case 'retrying':\n            case 'error':\n                return 'connecting';\n            case 'updating':\n            case 'connected':\n                return 'connected';\n            case 'rejected':\n                return 'rejected';\n            case 'disconnecting':\n            case 'waitSocketClosed':\n            case 'waitOffloadSocketClosed':\n                return 'disconnecting';\n            case 'disconnected':\n            default:\n                return 'disconnected';\n        }\n    }\n    initRetry() {\n        logger_1.log.debug('initRetry');\n        if (this.retrier.inProgress) {\n            this.retrier.attemptFailed();\n        }\n        else {\n            this.retrier.start();\n        }\n    }\n    retry() {\n        if (this.fsm.state != 'connecting') {\n            logger_1.log.trace('retry');\n            this.websocket.close();\n            this.fsm.userRetry();\n        }\n        else {\n            logger_1.log.trace('can\\t retry as already connecting');\n        }\n    }\n    onConnected() {\n        this.emit('connected');\n    }\n    finalizeSocket() {\n        logger_1.log.trace('finalizeSocket');\n        this.websocket.close();\n        this.emit('disconnected');\n        if (this.disconnectedPromiseResolve) {\n            this.disconnectedPromiseResolve();\n            this.disconnectedPromiseResolve = null;\n        }\n    }\n    setupSocket() {\n        logger_1.log.trace('setupSocket:', this.config.token);\n        this.emit('beforeConnect'); // This is used by client to record startup telemetry event\n        this.websocket.connect();\n    }\n    onIncomingMessage(message) {\n        let { method, header, payload } = parser_1.Parser.parse(message);\n        if (method !== 'reply') {\n            this.confirmReceiving(header);\n        }\n        if (method === 'notification') {\n            this.emit('message', header.message_type, payload);\n        }\n        else if (header.method === 'reply') {\n            this.transport.processReply({\n                id: header.id,\n                status: header.status,\n                header: header,\n                body: payload\n            });\n        }\n        else if (header.method === 'client_update') {\n            if (header.client_update_type === 'token_about_to_expire') {\n                this.emit('tokenAboutToExpire');\n            }\n        }\n        else if (header.method === 'close') {\n            if (header.status.code === 308) {\n                logger_1.log.debug('Connection has been offloaded');\n                this.fsm.receiveOffload({ status: header.status.status, body: payload });\n            }\n            else if (header.status.code === 406) { // Not acceptable message\n                const message = `Server closed connection because can't parse protocol: ${JSON.stringify(header.status)}`;\n                this.emitReplyConnectionError(message, header, true);\n                logger_1.log.error(message);\n                this.fsm.receiveFatalClose();\n            }\n            else if (header.status.code === 417) { // Protocol error\n                logger_1.log.error(`Server closed connection because can't parse client reply: ${JSON.stringify(header.status)}`);\n                this.fsm.receiveFatalClose(header.status.status);\n            }\n            else if (header.status.code === 410) { // Expired token\n                logger_1.log.warn(`Server closed connection: ${JSON.stringify(header.status)}`);\n                this.fsm.receiveClose(header.status.status);\n                this.emit('tokenExpired');\n            }\n            else if (header.status.code === 401) { // Authentication fail\n                logger_1.log.error(`Server closed connection: ${JSON.stringify(header.status)}`);\n                this.fsm.receiveClose(header.status.status);\n            }\n            else {\n                logger_1.log.warn('unexpected message: ', header.status);\n                // Try to reconnect\n                this.fsm.receiveOffload({ status: header.status.status, body: null });\n            }\n        }\n    }\n    async sendInit() {\n        logger_1.log.trace('sendInit');\n        try {\n            this.emit('beforeSendInit'); // This is used by client to record startup telemetry event\n            let reply = await this.transport.sendInit();\n            this.config.updateContinuationToken(reply.continuationToken);\n            this.config.confirmedCapabilities = reply.confirmedCapabilities;\n            this.fsm.initSuccess(reply);\n            this.emit('initialized', reply);\n            this.emit('tokenUpdated');\n        }\n        catch (ex) {\n            if (ex instanceof twilsockreplyerror_1.TwilsockReplyError) {\n                let isTerminalError = false;\n                logger_1.log.warn(`Init rejected by server: ${JSON.stringify(ex.reply.status)}`);\n                this.emit('sendInitFailed'); // This is used by client to record startup telemetry event\n                // @todo emit telemetry from inside \"if\" below for more granularity...\n                if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(ex.reply.status);\n                    if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n                        this.emit('tokenExpired');\n                    }\n                }\n                else if (ex.reply.status.code === 429) {\n                    this.modifyBackoff(ex.reply.body);\n                    this.fsm.initError(true);\n                }\n                else if (ex.reply.status.code === 500) {\n                    this.fsm.initError(false);\n                }\n                else {\n                    this.fsm.initError(true);\n                }\n                this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n            }\n            else {\n                this.terminationReason = ex.message;\n                this.emit('connectionError', { terminal: true, message: ex.message, httpStatusCode: null, errorCode: null });\n                this.fsm.initError(true);\n            }\n            this.emit('tokenUpdated', ex);\n        }\n    }\n    async sendUpdate() {\n        logger_1.log.trace('sendUpdate');\n        let message = new Messages.Update(this.config.token);\n        try {\n            let reply = await this.transport.sendWithReply(message);\n            this.fsm.updateSuccess(reply.body);\n            this.emit('tokenUpdated');\n        }\n        catch (ex) {\n            if (ex instanceof twilsockreplyerror_1.TwilsockReplyError) {\n                let isTerminalError = false;\n                logger_1.log.warn(`Token update rejected by server: ${JSON.stringify(ex.reply.status)}`);\n                if (ex.reply.status.code === 401 || ex.reply.status.code === 403) {\n                    isTerminalError = true;\n                    this.fsm.tokenRejected(ex.reply.status);\n                    if (ex.reply.status.errorCode === this.tokenExpiredSasCode) {\n                        this.emit('tokenExpired');\n                    }\n                }\n                else if (ex.reply.status.code === 429) {\n                    this.modifyBackoff(ex.reply.body);\n                    this.fsm.updateError(ex.reply.status);\n                }\n                else {\n                    this.fsm.updateError(ex.reply.status);\n                }\n                this.emitReplyConnectionError(ex.message, ex.reply, isTerminalError);\n            }\n            else {\n                this.emit('error', false, ex.message, null, null);\n                this.fsm.updateError(ex);\n            }\n            this.emit('tokenUpdated', ex);\n        }\n    }\n    emitReplyConnectionError(message, header, terminal) {\n        const description = header.status && header.status.description\n            ? header.status.description\n            : message;\n        const httpStatusCode = header.status.code;\n        const errorCode = header.status && header.status.errorCode\n            ? header.status.errorCode\n            : null;\n        if (terminal) {\n            this.terminationReason = description;\n        }\n        this.emit('connectionError', { terminal: terminal, message: description, httpStatusCode: httpStatusCode, errorCode: errorCode });\n    }\n    cancelInit() {\n        logger_1.log.trace('cancelInit');\n        // TODO: implement\n    }\n    cancelUpdate() {\n        logger_1.log.trace('cancelUpdate');\n        // TODO: implement\n    }\n    /**\n     * Should be called for each message to confirm it received\n     */\n    confirmReceiving(messageHeader) {\n        logger_1.log.trace('confirmReceiving');\n        try {\n            //@todo send telemetry events AnyEvents\n            this.transport.send(new Messages.Reply(messageHeader.id));\n        }\n        catch (e) {\n            logger_1.log.debug('failed to confirm packet receiving', e);\n        }\n    }\n    /**\n     * Shutdown connection\n     */\n    closeSocket(graceful) {\n        logger_1.log.trace(`closeSocket (graceful: ${graceful})`);\n        if (graceful && this.transport.isConnected) {\n            this.transport.sendClose();\n        }\n        this.websocket.close();\n        trampoline(() => this.fsm.socketClosed());\n    }\n    /**\n     * Initiate the twilsock connection\n     * If already connected, it does nothing\n     */\n    connect() {\n        logger_1.log.trace('connect');\n        this.fsm.userConnect();\n    }\n    /**\n     * Close twilsock connection\n     * If already disconnected, it does nothing\n     */\n    disconnect() {\n        logger_1.log.trace('disconnect');\n        if (this.fsm.is('disconnected')) {\n            return Promise.resolve();\n        }\n        return new Promise((resolve) => {\n            this.disconnectedPromiseResolve = resolve;\n            this.fsm.userDisconnect();\n        });\n    }\n    /**\n     * Update fpa token for twilsock connection\n     */\n    updateToken(token) {\n        logger_1.log.trace('updateToken:', token);\n        return new Promise((resolve, reject) => {\n            this.once('tokenUpdated', e => {\n                if (e) {\n                    reject(e);\n                }\n                else {\n                    resolve();\n                }\n            });\n            this.fsm.userUpdateToken();\n        });\n    }\n    get isTerminalState() {\n        return this.terminalStates.indexOf(this.fsm.state) !== -1;\n    }\n    get getTerminationReason() {\n        return this.terminationReason;\n    }\n    onCloseReceived(reason) {\n        this.websocket.close();\n    }\n}\nexports.TwilsockChannel = TwilsockChannel;\nexports.TwilsockImpl = TwilsockChannel;\n"]},"metadata":{},"sourceType":"script"}