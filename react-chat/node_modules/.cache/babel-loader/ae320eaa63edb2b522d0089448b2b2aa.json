{"ast":null,"code":"\"use strict\";\n\nvar _assertThisInitialized = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get2 = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _regeneratorRuntime = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncListImpl = exports.SyncList = void 0;\n\nvar sanitize_1 = require(\"./utils/sanitize\");\n\nvar uri_1 = require(\"./utils/uri\");\n\nvar syncerror_1 = require(\"./utils/syncerror\");\n\nvar logger_1 = require(\"./utils/logger\");\n\nvar entity_1 = require(\"./entity\");\n\nvar listitem_1 = require(\"./listitem\");\n\nvar paginator_1 = require(\"./paginator\");\n\nvar cache_1 = require(\"./cache\");\n\nvar mergingqueue_1 = require(\"./mergingqueue\");\n\nvar closeable_1 = require(\"./closeable\");\n\nvar SyncListImpl = /*#__PURE__*/function (_entity_1$SyncEntity) {\n  _inherits(SyncListImpl, _entity_1$SyncEntity);\n\n  var _super = _createSuper(SyncListImpl);\n\n  /**\n   * @private\n   */\n  function SyncListImpl(services, descriptor, removalHandler) {\n    var _this;\n\n    _classCallCheck(this, SyncListImpl);\n\n    _this = _super.call(this, services, removalHandler);\n\n    var updateRequestReducer = function updateRequestReducer(acc, input) {\n      return typeof input.ttl === 'number' ? {\n        ttl: input.ttl\n      } : acc;\n    };\n\n    _this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n    _this.cache = new cache_1.Cache();\n    _this.descriptor = descriptor;\n    _this.descriptor.date_updated = new Date(_this.descriptor.date_updated);\n    return _this;\n  } // private props\n\n\n  _createClass(SyncListImpl, [{\n    key: \"uri\",\n    get: function get() {\n      return this.descriptor.url;\n    }\n  }, {\n    key: \"revision\",\n    get: function get() {\n      return this.descriptor.revision;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.descriptor.last_event_id;\n    }\n  }, {\n    key: \"links\",\n    get: function get() {\n      return this.descriptor.links;\n    }\n  }, {\n    key: \"dateExpires\",\n    get: function get() {\n      return this.descriptor.date_expires;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return 'list';\n    } // below properties are specific to Insights only\n\n  }, {\n    key: \"indexName\",\n    get: function get() {\n      return undefined;\n    }\n  }, {\n    key: \"queryString\",\n    get: function get() {\n      return undefined;\n    } // public props, documented along with class description\n\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.descriptor.sid;\n    }\n  }, {\n    key: \"uniqueName\",\n    get: function get() {\n      return this.descriptor.unique_name || null;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.descriptor.date_updated;\n    }\n  }, {\n    key: \"_addOrUpdateItemOnServer\",\n    value: function () {\n      var _addOrUpdateItemOnServer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, data, ifMatch, ttl) {\n        var requestBody, response;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                requestBody = {\n                  data: data\n                };\n\n                if (ttl !== undefined) {\n                  requestBody.ttl = ttl;\n                }\n\n                _context.next = 4;\n                return this.services.network.post(url, requestBody, ifMatch);\n\n              case 4:\n                response = _context.sent;\n                response.body.data = data;\n                response.body.date_updated = new Date(response.body.date_updated);\n                return _context.abrupt(\"return\", response.body);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _addOrUpdateItemOnServer(_x, _x2, _x3, _x4) {\n        return _addOrUpdateItemOnServer2.apply(this, arguments);\n      }\n\n      return _addOrUpdateItemOnServer;\n    }()\n  }, {\n    key: \"push\",\n    value: function () {\n      var _push = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(value, itemMetadata) {\n        var ttl, item, index;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                ttl = (itemMetadata || {}).ttl;\n                sanitize_1.validateOptionalTtl(ttl);\n                _context2.next = 4;\n                return this._addOrUpdateItemOnServer(this.links.items, value, undefined, ttl);\n\n              case 4:\n                item = _context2.sent;\n                index = Number(item.index);\n\n                this._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);\n\n                return _context2.abrupt(\"return\", this.cache.get(index));\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function push(_x5, _x6) {\n        return _push.apply(this, arguments);\n      }\n\n      return push;\n    }()\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(index, value, itemMetadataUpdates) {\n        var _this2 = this;\n\n        var input;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                input = itemMetadataUpdates || {};\n                sanitize_1.validateOptionalTtl(input.ttl);\n                return _context3.abrupt(\"return\", this.updateMergingQueue.squashAndAdd(index, input, function (input) {\n                  return _this2._updateItemUnconditionally(index, value, input.ttl);\n                }));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function set(_x7, _x8, _x9) {\n        return _set.apply(this, arguments);\n      }\n\n      return set;\n    }()\n  }, {\n    key: \"_updateItemUnconditionally\",\n    value: function () {\n      var _updateItemUnconditionally2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(index, data, ttl) {\n        var existingItem, itemDescriptor;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.get(index);\n\n              case 2:\n                existingItem = _context4.sent;\n                _context4.next = 5;\n                return this._addOrUpdateItemOnServer(existingItem.uri, data, undefined, ttl);\n\n              case 5:\n                itemDescriptor = _context4.sent;\n\n                this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n\n                return _context4.abrupt(\"return\", this.cache.get(index));\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _updateItemUnconditionally(_x10, _x11, _x12) {\n        return _updateItemUnconditionally2.apply(this, arguments);\n      }\n\n      return _updateItemUnconditionally;\n    }()\n  }, {\n    key: \"_updateItemWithIfMatch\",\n    value: function () {\n      var _updateItemWithIfMatch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(index, mutatorFunction, ttl) {\n        var existingItem, data, ifMatch, itemDescriptor;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.get(index);\n\n              case 2:\n                existingItem = _context5.sent;\n                data = mutatorFunction(sanitize_1.deepClone(existingItem.value));\n\n                if (!data) {\n                  _context5.next = 25;\n                  break;\n                }\n\n                ifMatch = existingItem.revision;\n                _context5.prev = 6;\n                _context5.next = 9;\n                return this._addOrUpdateItemOnServer(existingItem.uri, data, ifMatch, ttl);\n\n              case 9:\n                itemDescriptor = _context5.sent;\n\n                this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n\n                return _context5.abrupt(\"return\", this.cache.get(index));\n\n              case 14:\n                _context5.prev = 14;\n                _context5.t0 = _context5[\"catch\"](6);\n\n                if (!(_context5.t0.status === 412)) {\n                  _context5.next = 22;\n                  break;\n                }\n\n                _context5.next = 19;\n                return this._getItemFromServer(index);\n\n              case 19:\n                return _context5.abrupt(\"return\", this._updateItemWithIfMatch(index, mutatorFunction, ttl));\n\n              case 22:\n                throw _context5.t0;\n\n              case 23:\n                _context5.next = 26;\n                break;\n\n              case 25:\n                return _context5.abrupt(\"return\", existingItem);\n\n              case 26:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[6, 14]]);\n      }));\n\n      function _updateItemWithIfMatch(_x13, _x14, _x15) {\n        return _updateItemWithIfMatch2.apply(this, arguments);\n      }\n\n      return _updateItemWithIfMatch;\n    }()\n  }, {\n    key: \"mutate\",\n    value: function () {\n      var _mutate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(index, mutator, itemMetadataUpdates) {\n        var _this3 = this;\n\n        var input;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                input = itemMetadataUpdates || {};\n                sanitize_1.validateOptionalTtl(input.ttl);\n                return _context6.abrupt(\"return\", this.updateMergingQueue.add(index, input, function (input) {\n                  return _this3._updateItemWithIfMatch(index, mutator, input.ttl);\n                }));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function mutate(_x16, _x17, _x18) {\n        return _mutate.apply(this, arguments);\n      }\n\n      return mutate;\n    }()\n  }, {\n    key: \"update\",\n    value: function () {\n      var _update2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(index, obj, itemMetadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                return _context7.abrupt(\"return\", this.mutate(index, function (remote) {\n                  return Object.assign(remote, obj);\n                }, itemMetadataUpdates));\n\n              case 1:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function update(_x19, _x20, _x21) {\n        return _update2.apply(this, arguments);\n      }\n\n      return update;\n    }()\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(index) {\n        var item, response;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.get(index);\n\n              case 2:\n                item = _context8.sent;\n                _context8.next = 5;\n                return this.services.network.delete(item.uri);\n\n              case 5:\n                response = _context8.sent;\n\n                this._handleItemRemoved(index, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function remove(_x22) {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(index) {\n        var cachedItem;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                cachedItem = this.cache.get(index);\n\n                if (!cachedItem) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", cachedItem);\n\n              case 5:\n                return _context9.abrupt(\"return\", this._getItemFromServer(index));\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function get(_x23) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"_getItemFromServer\",\n    value: function () {\n      var _getItemFromServer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(index) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.queryItems({\n                  index: index\n                });\n\n              case 2:\n                result = _context10.sent;\n\n                if (!(result.items.length < 1)) {\n                  _context10.next = 7;\n                  break;\n                }\n\n                throw new syncerror_1.SyncError(\"No item with index \".concat(index, \" found\"), 404, 54151);\n\n              case 7:\n                return _context10.abrupt(\"return\", result.items[0]);\n\n              case 8:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function _getItemFromServer(_x24) {\n        return _getItemFromServer2.apply(this, arguments);\n      }\n\n      return _getItemFromServer;\n    }()\n    /**\n     * Query items from the List\n     * @private\n     */\n\n  }, {\n    key: \"queryItems\",\n    value: function () {\n      var _queryItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(arg) {\n        var _this4 = this;\n\n        var url, response, items, meta;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                arg = arg || {};\n                url = new uri_1.UriBuilder(this.links.items).queryParam('From', arg.from).queryParam('PageSize', arg.limit).queryParam('Index', arg.index).queryParam('PageToken', arg.pageToken).queryParam('Order', arg.order).build();\n                _context11.next = 4;\n                return this.services.network.get(url);\n\n              case 4:\n                response = _context11.sent;\n                items = response.body.items.map(function (el) {\n                  el.date_updated = new Date(el.date_updated);\n\n                  var itemInCache = _this4.cache.get(el.index);\n\n                  if (itemInCache) {\n                    _this4._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n                  } else {\n                    _this4.cache.store(Number(el.index), new listitem_1.ListItem({\n                      index: Number(el.index),\n                      uri: el.url,\n                      revision: el.revision,\n                      lastEventId: el.last_event_id,\n                      dateUpdated: el.date_updated,\n                      dateExpires: el.date_expires,\n                      value: el.data\n                    }), el.last_event_id);\n                  }\n\n                  return _this4.cache.get(el.index);\n                });\n                meta = response.body.meta;\n                return _context11.abrupt(\"return\", new paginator_1.Paginator(items, function (pageToken) {\n                  return _this4.queryItems({\n                    pageToken: pageToken\n                  });\n                }, meta.previous_token, meta.next_token));\n\n              case 8:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function queryItems(_x25) {\n        return _queryItems.apply(this, arguments);\n      }\n\n      return queryItems;\n    }()\n  }, {\n    key: \"getItems\",\n    value: function () {\n      var _getItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(args) {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                args = args || {};\n                sanitize_1.validatePageSize(args.pageSize);\n                args.limit = args.pageSize || args.limit || 50;\n                args.order = args.order || 'asc';\n                return _context12.abrupt(\"return\", this.queryItems(args));\n\n              case 5:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function getItems(_x26) {\n        return _getItems.apply(this, arguments);\n      }\n\n      return getItems;\n    }()\n    /**\n     * @return {Promise<Object>} Context of List\n     * @private\n     */\n\n  }, {\n    key: \"getContext\",\n    value: function () {\n      var _getContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (this.context) {\n                  _context13.next = 5;\n                  break;\n                }\n\n                _context13.next = 3;\n                return this.services.network.get(this.links.context);\n\n              case 3:\n                response = _context13.sent;\n\n                // store fetched context if we have't received any newer update\n                this._updateContextIfRequired(response.body.data, response.body.last_event_id);\n\n              case 5:\n                return _context13.abrupt(\"return\", this.context);\n\n              case 6:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function getContext() {\n        return _getContext.apply(this, arguments);\n      }\n\n      return getContext;\n    }()\n  }, {\n    key: \"setTtl\",\n    value: function () {\n      var _setTtl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(ttl) {\n        var requestBody, response;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                sanitize_1.validateMandatoryTtl(ttl);\n                _context14.prev = 1;\n                requestBody = {\n                  ttl: ttl\n                };\n                _context14.next = 5;\n                return this.services.network.post(this.uri, requestBody);\n\n              case 5:\n                response = _context14.sent;\n                this.descriptor.date_expires = response.body.date_expires;\n                _context14.next = 13;\n                break;\n\n              case 9:\n                _context14.prev = 9;\n                _context14.t0 = _context14[\"catch\"](1);\n\n                if (_context14.t0.status === 404) {\n                  this.onRemoved(false);\n                }\n\n                throw _context14.t0;\n\n              case 13:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[1, 9]]);\n      }));\n\n      function setTtl(_x27) {\n        return _setTtl.apply(this, arguments);\n      }\n\n      return setTtl;\n    }()\n  }, {\n    key: \"setItemTtl\",\n    value: function () {\n      var _setItemTtl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(index, ttl) {\n        var existingItem, requestBody, response;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                sanitize_1.validateMandatoryTtl(ttl);\n                _context15.next = 3;\n                return this.get(index);\n\n              case 3:\n                existingItem = _context15.sent;\n                requestBody = {\n                  ttl: ttl\n                };\n                _context15.next = 7;\n                return this.services.network.post(existingItem.uri, requestBody);\n\n              case 7:\n                response = _context15.sent;\n                existingItem.updateDateExpires(response.body.date_expires);\n\n              case 9:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function setItemTtl(_x28, _x29) {\n        return _setItemTtl.apply(this, arguments);\n      }\n\n      return setItemTtl;\n    }()\n  }, {\n    key: \"removeList\",\n    value: function () {\n      var _removeList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return this.services.network.delete(this.uri);\n\n              case 2:\n                this.onRemoved(true);\n\n              case 3:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function removeList() {\n        return _removeList.apply(this, arguments);\n      }\n\n      return removeList;\n    }()\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved(locally) {\n      this._unsubscribe();\n\n      this.removalHandler(this.type, this.sid, this.uniqueName);\n      this.broadcastEventToListeners('removed', {\n        isLocal: locally\n      });\n    }\n  }, {\n    key: \"shouldIgnoreEvent\",\n    value: function shouldIgnoreEvent(key, eventId) {\n      return this.cache.isKnown(key, eventId);\n    }\n    /**\n     * Handle update, which came from the server.\n     * @private\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update(update, isStrictlyOrdered) {\n      var itemIndex = Number(update.item_index);\n      update.date_created = new Date(update.date_created);\n\n      switch (update.type) {\n        case 'list_item_added':\n        case 'list_item_updated':\n          {\n            this._handleItemMutated(itemIndex, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration does not include date_expires\n            update.type === 'list_item_added', true);\n          }\n          break;\n\n        case 'list_item_removed':\n          {\n            this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);\n          }\n          break;\n\n        case 'list_context_updated':\n          {\n            this._handleContextUpdate(update.context_data, update.id, update.date_created);\n          }\n          break;\n\n        case 'list_removed':\n          {\n            this.onRemoved(false);\n          }\n          break;\n      }\n\n      if (isStrictlyOrdered) {\n        this._advanceLastEventId(update.id, update.list_revision);\n      }\n    }\n  }, {\n    key: \"_advanceLastEventId\",\n    value: function _advanceLastEventId(eventId, revision) {\n      if (this.lastEventId < eventId) {\n        this.descriptor.last_event_id = eventId;\n\n        if (revision) {\n          this.descriptor.revision = revision;\n        }\n      }\n    }\n  }, {\n    key: \"_updateRootDateUpdated\",\n    value: function _updateRootDateUpdated(dateUpdated) {\n      if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n        this.descriptor.date_updated = dateUpdated;\n        this.services.storage.update(this.type, this.sid, this.uniqueName, {\n          date_updated: dateUpdated\n        });\n      }\n    }\n  }, {\n    key: \"_handleItemMutated\",\n    value: function _handleItemMutated(index, uri, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n      if (this.shouldIgnoreEvent(index, lastEventId)) {\n        logger_1.default.trace('Item ', index, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n        return;\n      } else {\n        this._updateRootDateUpdated(dateUpdated);\n\n        var item = this.cache.get(index);\n\n        if (!item) {\n          var _item = new listitem_1.ListItem({\n            index: index,\n            uri: uri,\n            lastEventId: lastEventId,\n            revision: revision,\n            value: value,\n            dateUpdated: dateUpdated,\n            dateExpires: dateExpires\n          });\n\n          this.cache.store(index, _item, lastEventId);\n          this.emitItemMutationEvent(_item, remote, added);\n        } else {\n          item.update(lastEventId, revision, value, dateUpdated);\n          this.cache.store(index, item, lastEventId);\n\n          if (dateExpires !== undefined) {\n            item.updateDateExpires(dateExpires);\n          }\n\n          this.emitItemMutationEvent(item, remote, false);\n        }\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"emitItemMutationEvent\",\n    value: function emitItemMutationEvent(item, remote, added) {\n      var eventName = added ? 'itemAdded' : 'itemUpdated';\n      this.broadcastEventToListeners(eventName, {\n        item: item,\n        isLocal: !remote\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_handleItemRemoved\",\n    value: function _handleItemRemoved(index, eventId, oldData, dateUpdated, remote) {\n      this._updateRootDateUpdated(dateUpdated);\n\n      this.cache.delete(index, eventId);\n      this.broadcastEventToListeners('itemRemoved', {\n        index: index,\n        isLocal: !remote,\n        value: oldData\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_handleContextUpdate\",\n    value: function _handleContextUpdate(data, eventId, dateUpdated) {\n      this._updateRootDateUpdated(dateUpdated);\n\n      if (this._updateContextIfRequired(data, eventId)) {\n        this.broadcastEventToListeners('contextUpdated', {\n          context: data,\n          isLocal: false\n        });\n      }\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_updateContextIfRequired\",\n    value: function _updateContextIfRequired(data, eventId) {\n      if (!this.contextEventId || eventId > this.contextEventId) {\n        this.context = data;\n        this.contextEventId = eventId;\n        return true;\n      } else {\n        logger_1.default.trace('Context update skipped, current:', this.lastEventId, ', remote:', eventId);\n        return false;\n      }\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'list';\n    }\n  }]);\n\n  return SyncListImpl;\n}(entity_1.SyncEntity);\n\nexports.SyncListImpl = SyncListImpl;\n/**\n * @class\n * @alias List\n * @classdesc Represents a Sync List, which stores an ordered list of values.\n * Use the {@link Client#list} method to obtain a reference to a Sync List.\n * @property {String} sid - List unique id, immutable identifier assigned by the system.\n * @property {String} [uniqueName=null] - List unique name, immutable identifier that can be assigned to list during creation.\n * @property {Date} dateUpdated Date when the List was last updated.\n *\n * @fires List#removed\n * @fires List#itemAdded\n * @fires List#itemRemoved\n * @fires List#itemUpdated\n */\n\nvar SyncList = /*#__PURE__*/function (_closeable_1$default) {\n  _inherits(SyncList, _closeable_1$default);\n\n  var _super2 = _createSuper(SyncList);\n\n  function SyncList(syncListImpl) {\n    var _this5;\n\n    _classCallCheck(this, SyncList);\n\n    _this5 = _super2.call(this);\n    _this5.syncListImpl = syncListImpl;\n\n    _this5.syncListImpl.attach(_assertThisInitialized(_this5));\n\n    return _this5;\n  } // private props\n\n\n  _createClass(SyncList, [{\n    key: \"uri\",\n    get: function get() {\n      return this.syncListImpl.uri;\n    }\n  }, {\n    key: \"revision\",\n    get: function get() {\n      return this.syncListImpl.revision;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.syncListImpl.lastEventId;\n    }\n  }, {\n    key: \"links\",\n    get: function get() {\n      return this.syncListImpl.links;\n    }\n  }, {\n    key: \"dateExpires\",\n    get: function get() {\n      return this.syncListImpl.dateExpires;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return SyncListImpl.type;\n    } // public props, documented along with class description\n\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.syncListImpl.sid;\n    }\n  }, {\n    key: \"uniqueName\",\n    get: function get() {\n      return this.syncListImpl.uniqueName;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.syncListImpl.dateUpdated;\n    }\n    /**\n     * Add a new item to the list.\n     * @param {Object} value Value to be added.\n     * @param {List#ItemMetadata} [itemMetadata] Item metadata.\n     * @returns {Promise<ListItem>} A newly added item.\n     * @public\n     * @example\n     * list.push({ name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('List Item push() successful, item index:' + item.index + ', value: ', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item push() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"push\",\n    value: function () {\n      var _push2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(value, itemMetadata) {\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context17.abrupt(\"return\", this.syncListImpl.push(value, itemMetadata));\n\n              case 2:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function push(_x30, _x31) {\n        return _push2.apply(this, arguments);\n      }\n\n      return push;\n    }()\n    /**\n     * Assign new value to an existing item, given its index.\n     * @param {Number} index Index of the item to be updated.\n     * @param {Object} value New value to be assigned to an item.\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<ListItem>} A promise with updated item containing latest known value.\n     * The promise will be rejected if the item does not exist.\n     * @public\n     * @example\n     * list.set(42, { name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('List Item set() successful, item value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item set() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(index, value, itemMetadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context18.abrupt(\"return\", this.syncListImpl.set(index, value, itemMetadataUpdates));\n\n              case 2:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function set(_x32, _x33, _x34) {\n        return _set2.apply(this, arguments);\n      }\n\n      return set;\n    }()\n    /**\n     * Modify an existing item by applying a mutation function to it.\n     * @param {Number} index Index of an item to be changed.\n     * @param {List~Mutator} mutator A function that outputs a new value based on the existing value.\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<ListItem>} Resolves with the most recent item state, the output of a successful\n     *    mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>). This promise\n     *    will be rejected if the indicated item does not already exist.\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * list.mutate(42, mutatorFunction, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('List Item mutate() successful, new value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item mutate() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"mutate\",\n    value: function () {\n      var _mutate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(index, mutator, itemMetadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context19.abrupt(\"return\", this.syncListImpl.mutate(index, mutator, itemMetadataUpdates));\n\n              case 2:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function mutate(_x35, _x36, _x37) {\n        return _mutate2.apply(this, arguments);\n      }\n\n      return mutate;\n    }()\n    /**\n     * Modify an existing item by appending new fields (or overwriting existing ones) with the values from Object.\n     * This is equivalent to\n     * <pre>\n     * list.mutate(42, function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {Number} index Index of an item to be changed.\n     * @param {Object} obj Set of fields to update.\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<ListItem>} A promise with a modified item containing latest known value.\n     * The promise will be rejected if an item was not found.\n     * @public\n     * @example\n     * // Say, the List Item (index: 42) value is { name: 'John Smith' }\n     * list.update(42, { age: 34 }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     // Now the List Item value is { name: 'John Smith', age: 34 }\n     *     console.log('List Item update() successful, new value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item update() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"update\",\n    value: function () {\n      var _update3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(index, obj, itemMetadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context20.abrupt(\"return\", this.syncListImpl.update(index, obj, itemMetadataUpdates));\n\n              case 2:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function update(_x38, _x39, _x40) {\n        return _update3.apply(this, arguments);\n      }\n\n      return update;\n    }()\n    /**\n     * Delete an item, given its index.\n     * @param {Number} index Index of an item to be removed.\n     * @returns {Promise<void>} A promise to remove an item.\n     * A promise will be rejected if an item was not found.\n     * @public\n     * @example\n     * list.remove(42)\n     *   .then(function() {\n     *     console.log('List Item remove() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item remove() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(index) {\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context21.abrupt(\"return\", this.syncListImpl.remove(index));\n\n              case 2:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function remove(_x41) {\n        return _remove2.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * Retrieve an item by List index.\n     * @param {Number} index Item index in a List.\n     * @returns {Promise<ListItem>} A promise with an item containing latest known value.\n     * A promise will be rejected if an item was not found.\n     * @public\n     * @example\n     * list.get(42)\n     *   .then(function(item) {\n     *     console.log('List Item get() successful, item value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item get() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(index) {\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context22.abrupt(\"return\", this.syncListImpl.get(index));\n\n              case 2:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function get(_x42) {\n        return _get3.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Retrieve a List context\n     * @returns {Promise<Object>} A promise with a List's context\n     * @ignore\n     */\n\n  }, {\n    key: \"getContext\",\n    value: function () {\n      var _getContext2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context23.abrupt(\"return\", this.syncListImpl.getContext());\n\n              case 2:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function getContext() {\n        return _getContext2.apply(this, arguments);\n      }\n\n      return getContext;\n    }()\n    /**\n     * Query a list of items from collection.\n     * @param {Object} [args] Arguments for query\n     * @param {Number} [args.from] Item index, which should be used as the offset.\n     * If undefined, starts from the beginning or end depending on args.order.\n     * @param {Number} [args.pageSize=50] Results page size.\n     * @param {'asc'|'desc'} [args.order='asc'] Numeric order of results.\n     * @returns {Promise<Paginator<ListItem>>}\n     * @public\n     * @example\n     * var pageHandler = function(paginator) {\n     *   paginator.items.forEach(function(item) {\n     *     console.log('Item ' + item.index + ': ', item.value);\n     *   });\n     *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n     *                                : null;\n     * };\n     * list.getItems({ from: 0, order: 'asc' })\n     *   .then(pageHandler)\n     *   .catch(function(error) {\n     *     console.error('List getItems() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"getItems\",\n    value: function () {\n      var _getItems2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(args) {\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context24.abrupt(\"return\", this.syncListImpl.getItems(args));\n\n              case 2:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function getItems(_x43) {\n        return _getItems2.apply(this, arguments);\n      }\n\n      return getItems;\n    }()\n    /**\n     * Update the time-to-live of the list.\n     * @param {Number} ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * list.setTtl(3600)\n     *   .then(function() {\n     *     console.log('List setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List setTtl() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"setTtl\",\n    value: function () {\n      var _setTtl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(ttl) {\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context25.abrupt(\"return\", this.syncListImpl.setTtl(ttl));\n\n              case 2:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function setTtl(_x44) {\n        return _setTtl2.apply(this, arguments);\n      }\n\n      return setTtl;\n    }()\n    /**\n     * Update the time-to-live of a list item.\n     * @param {Number} index Item index.\n     * @param {Number} ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * list.setItemTtl(42, 86400)\n     *   .then(function() {\n     *     console.log('List setItemTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List setItemTtl() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"setItemTtl\",\n    value: function () {\n      var _setItemTtl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(index, ttl) {\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context26.abrupt(\"return\", this.syncListImpl.setItemTtl(index, ttl));\n\n              case 2:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function setItemTtl(_x45, _x46) {\n        return _setItemTtl2.apply(this, arguments);\n      }\n\n      return setItemTtl;\n    }()\n    /**\n     * Delete this list. It will be impossible to restore it.\n     * @return {Promise<void>} A promise that resolves when the list has been deleted.\n     * @public\n     * @example\n     * list.removeList()\n     *   .then(function() {\n     *     console.log('List removeList() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List removeList() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"removeList\",\n    value: function () {\n      var _removeList2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee27() {\n        return _regeneratorRuntime.wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context27.abrupt(\"return\", this.syncListImpl.removeList());\n\n              case 2:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function removeList() {\n        return _removeList2.apply(this, arguments);\n      }\n\n      return removeList;\n    }()\n    /**\n     * Conclude work with the list instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this list will continue operating and receiving events normally.\n     * @public\n     * @example\n     * list.close();\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      _get2(_getPrototypeOf(SyncList.prototype), \"close\", this).call(this);\n\n      this.syncListImpl.detach(this.listenerUuid);\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return SyncListImpl.type;\n    }\n  }]);\n\n  return SyncList;\n}(closeable_1.default);\n\nexports.SyncList = SyncList;\nexports.default = SyncList;\n/**\n * Contains List Item metadata.\n * @typedef {Object} List#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the list item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback List~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when a new item appears in the list, whether its creator was local or remote.\n * @event List#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {ListItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * list.on('itemAdded', function(args) {\n *   console.log('List item ' + args.item.index + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a list item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event List#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {ListItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * list.on('itemUpdated', function(args) {\n *   console.log('List item ' + args.item.index + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a list item is removed, whether the remover was local or remote.\n * @event List#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {Number} args.index The index of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * list.on('itemRemoved', function(args) {\n *   console.log('List item ' + args.index + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a list is deleted entirely, by any actor local or remote.\n * @event List#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if list was removed by local actor, 'false' otherwise.\n * @example\n * list.on('removed', function(args) {\n *   console.log('List ' + list.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilio-sync/lib/synclist.js"],"names":["Object","defineProperty","exports","value","SyncListImpl","SyncList","sanitize_1","require","uri_1","syncerror_1","logger_1","entity_1","listitem_1","paginator_1","cache_1","mergingqueue_1","closeable_1","services","descriptor","removalHandler","updateRequestReducer","acc","input","ttl","updateMergingQueue","NamespacedMergingQueue","cache","Cache","date_updated","Date","url","revision","last_event_id","links","date_expires","undefined","sid","unique_name","data","ifMatch","requestBody","network","post","response","body","itemMetadata","validateOptionalTtl","_addOrUpdateItemOnServer","items","item","index","Number","_handleItemMutated","get","itemMetadataUpdates","squashAndAdd","_updateItemUnconditionally","existingItem","uri","itemDescriptor","mutatorFunction","deepClone","status","_getItemFromServer","_updateItemWithIfMatch","mutator","add","obj","mutate","remote","assign","delete","_handleItemRemoved","cachedItem","queryItems","result","length","SyncError","arg","UriBuilder","queryParam","from","limit","pageToken","order","build","map","el","itemInCache","store","ListItem","lastEventId","dateUpdated","dateExpires","meta","Paginator","previous_token","next_token","args","validatePageSize","pageSize","context","_updateContextIfRequired","validateMandatoryTtl","onRemoved","updateDateExpires","locally","_unsubscribe","type","uniqueName","broadcastEventToListeners","isLocal","key","eventId","isKnown","update","isStrictlyOrdered","itemIndex","item_index","date_created","item_url","id","item_revision","item_data","_handleContextUpdate","context_data","_advanceLastEventId","list_revision","getTime","storage","added","shouldIgnoreEvent","default","trace","_updateRootDateUpdated","emitItemMutationEvent","eventName","oldData","contextEventId","SyncEntity","syncListImpl","attach","ensureNotClosed","push","set","remove","getContext","getItems","setTtl","setItemTtl","removeList","detach","listenerUuid"],"mappings":"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I,qBAAKuH,eAAL;AADJ,mDAEW,KAAKF,YAAL,CAAkBS,UAAlB,CAA6BnG,KAA7B,EAAoC3B,GAApC,CAFX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;kFACI;AAAA;AAAA;AAAA;AAAA;AACI,qBAAKuH,eAAL;AADJ,mDAEW,KAAKF,YAAL,CAAkBU,UAAlB,EAFX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,iBAAQ;AACJ;;AACA,WAAKV,YAAL,CAAkBW,MAAlB,CAAyB,KAAKC,YAA9B;AACH;;;SA1PD,eAAkB;AACd,aAAOpJ,YAAY,CAACwG,IAApB;AACH;;;;EAxBkB5F,WAAW,CAACoH,O;;AAkRnClI,OAAO,CAACG,QAAR,GAAmBA,QAAnB;AACAH,OAAO,CAACkI,OAAR,GAAkB/H,QAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyncListImpl = exports.SyncList = void 0;\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst entity_1 = require(\"./entity\");\nconst listitem_1 = require(\"./listitem\");\nconst paginator_1 = require(\"./paginator\");\nconst cache_1 = require(\"./cache\");\nconst mergingqueue_1 = require(\"./mergingqueue\");\nconst closeable_1 = require(\"./closeable\");\nclass SyncListImpl extends entity_1.SyncEntity {\n    /**\n     * @private\n     */\n    constructor(services, descriptor, removalHandler) {\n        super(services, removalHandler);\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\n            : acc;\n        this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n        this.cache = new cache_1.Cache();\n        this.descriptor = descriptor;\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n    }\n    // private props\n    get uri() {\n        return this.descriptor.url;\n    }\n    get revision() {\n        return this.descriptor.revision;\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get links() {\n        return this.descriptor.links;\n    }\n    get dateExpires() {\n        return this.descriptor.date_expires;\n    }\n    static get type() {\n        return 'list';\n    }\n    get type() {\n        return 'list';\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return undefined;\n    }\n    get queryString() {\n        return undefined;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.descriptor.sid;\n    }\n    get uniqueName() {\n        return this.descriptor.unique_name || null;\n    }\n    get dateUpdated() {\n        return this.descriptor.date_updated;\n    }\n    async _addOrUpdateItemOnServer(url, data, ifMatch, ttl) {\n        const requestBody = { data };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        const response = await this.services.network.post(url, requestBody, ifMatch);\n        response.body.data = data;\n        response.body.date_updated = new Date(response.body.date_updated);\n        return response.body;\n    }\n    async push(value, itemMetadata) {\n        let ttl = (itemMetadata || {}).ttl;\n        sanitize_1.validateOptionalTtl(ttl);\n        let item = await this._addOrUpdateItemOnServer(this.links.items, value, undefined, ttl);\n        let index = Number(item.index);\n        this._handleItemMutated(index, item.url, item.last_event_id, item.revision, value, item.date_updated, item.date_expires, true, false);\n        return this.cache.get(index);\n    }\n    async set(index, value, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.squashAndAdd(index, input, (input) => this._updateItemUnconditionally(index, value, input.ttl));\n    }\n    async _updateItemUnconditionally(index, data, ttl) {\n        let existingItem = await this.get(index);\n        const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, undefined, ttl);\n        this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n        return this.cache.get(index);\n    }\n    async _updateItemWithIfMatch(index, mutatorFunction, ttl) {\n        const existingItem = await this.get(index);\n        const data = mutatorFunction(sanitize_1.deepClone(existingItem.value));\n        if (data) {\n            const ifMatch = existingItem.revision;\n            try {\n                const itemDescriptor = await this._addOrUpdateItemOnServer(existingItem.uri, data, ifMatch, ttl);\n                this._handleItemMutated(index, itemDescriptor.url, itemDescriptor.last_event_id, itemDescriptor.revision, itemDescriptor.data, itemDescriptor.date_updated, itemDescriptor.date_expires, false, false);\n                return this.cache.get(index);\n            }\n            catch (error) {\n                if (error.status === 412) {\n                    await this._getItemFromServer(index);\n                    return this._updateItemWithIfMatch(index, mutatorFunction, ttl);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        else {\n            return existingItem;\n        }\n    }\n    async mutate(index, mutator, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.add(index, input, (input) => this._updateItemWithIfMatch(index, mutator, input.ttl));\n    }\n    async update(index, obj, itemMetadataUpdates) {\n        return this.mutate(index, remote => Object.assign(remote, obj), itemMetadataUpdates);\n    }\n    async remove(index) {\n        let item = await this.get(index);\n        let response = await this.services.network.delete(item.uri);\n        this._handleItemRemoved(index, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n    }\n    async get(index) {\n        let cachedItem = this.cache.get(index);\n        if (cachedItem) {\n            return cachedItem;\n        }\n        else {\n            return this._getItemFromServer(index);\n        }\n    }\n    async _getItemFromServer(index) {\n        let result = await this.queryItems({ index });\n        if (result.items.length < 1) {\n            throw new syncerror_1.SyncError(`No item with index ${index} found`, 404, 54151);\n        }\n        else {\n            return result.items[0];\n        }\n    }\n    /**\n     * Query items from the List\n     * @private\n     */\n    async queryItems(arg) {\n        arg = arg || {};\n        const url = new uri_1.UriBuilder(this.links.items)\n            .queryParam('From', arg.from)\n            .queryParam('PageSize', arg.limit)\n            .queryParam('Index', arg.index)\n            .queryParam('PageToken', arg.pageToken)\n            .queryParam('Order', arg.order)\n            .build();\n        let response = await this.services.network.get(url);\n        let items = response.body.items.map(el => {\n            el.date_updated = new Date(el.date_updated);\n            let itemInCache = this.cache.get(el.index);\n            if (itemInCache) {\n                this._handleItemMutated(el.index, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n            }\n            else {\n                this.cache.store(Number(el.index), new listitem_1.ListItem({\n                    index: Number(el.index),\n                    uri: el.url,\n                    revision: el.revision,\n                    lastEventId: el.last_event_id,\n                    dateUpdated: el.date_updated,\n                    dateExpires: el.date_expires,\n                    value: el.data\n                }), el.last_event_id);\n            }\n            return this.cache.get(el.index);\n        });\n        let meta = response.body.meta;\n        return new paginator_1.Paginator(items, pageToken => this.queryItems({ pageToken }), meta.previous_token, meta.next_token);\n    }\n    async getItems(args) {\n        args = args || {};\n        sanitize_1.validatePageSize(args.pageSize);\n        args.limit = args.pageSize || args.limit || 50;\n        args.order = args.order || 'asc';\n        return this.queryItems(args);\n    }\n    /**\n     * @return {Promise<Object>} Context of List\n     * @private\n     */\n    async getContext() {\n        if (!this.context) {\n            let response = await this.services.network.get(this.links.context);\n            // store fetched context if we have't received any newer update\n            this._updateContextIfRequired(response.body.data, response.body.last_event_id);\n        }\n        return this.context;\n    }\n    async setTtl(ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        try {\n            const requestBody = { ttl };\n            const response = await this.services.network.post(this.uri, requestBody);\n            this.descriptor.date_expires = response.body.date_expires;\n        }\n        catch (error) {\n            if (error.status === 404) {\n                this.onRemoved(false);\n            }\n            throw error;\n        }\n    }\n    async setItemTtl(index, ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        let existingItem = await this.get(index);\n        const requestBody = { ttl };\n        const response = await this.services.network.post(existingItem.uri, requestBody);\n        existingItem.updateDateExpires(response.body.date_expires);\n    }\n    async removeList() {\n        await this.services.network.delete(this.uri);\n        this.onRemoved(true);\n    }\n    onRemoved(locally) {\n        this._unsubscribe();\n        this.removalHandler(this.type, this.sid, this.uniqueName);\n        this.broadcastEventToListeners('removed', { isLocal: locally });\n    }\n    shouldIgnoreEvent(key, eventId) {\n        return this.cache.isKnown(key, eventId);\n    }\n    /**\n     * Handle update, which came from the server.\n     * @private\n     */\n    _update(update, isStrictlyOrdered) {\n        const itemIndex = Number(update.item_index);\n        update.date_created = new Date(update.date_created);\n        switch (update.type) {\n            case 'list_item_added':\n            case 'list_item_updated':\n                {\n                    this._handleItemMutated(itemIndex, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration does not include date_expires\n                    update.type === 'list_item_added', true);\n                }\n                break;\n            case 'list_item_removed':\n                {\n                    this._handleItemRemoved(itemIndex, update.id, update.item_data, update.date_created, true);\n                }\n                break;\n            case 'list_context_updated':\n                {\n                    this._handleContextUpdate(update.context_data, update.id, update.date_created);\n                }\n                break;\n            case 'list_removed':\n                {\n                    this.onRemoved(false);\n                }\n                break;\n        }\n        if (isStrictlyOrdered) {\n            this._advanceLastEventId(update.id, update.list_revision);\n        }\n    }\n    _advanceLastEventId(eventId, revision) {\n        if (this.lastEventId < eventId) {\n            this.descriptor.last_event_id = eventId;\n            if (revision) {\n                this.descriptor.revision = revision;\n            }\n        }\n    }\n    _updateRootDateUpdated(dateUpdated) {\n        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n            this.descriptor.date_updated = dateUpdated;\n            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });\n        }\n    }\n    _handleItemMutated(index, uri, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n        if (this.shouldIgnoreEvent(index, lastEventId)) {\n            logger_1.default.trace('Item ', index, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n            return;\n        }\n        else {\n            this._updateRootDateUpdated(dateUpdated);\n            let item = this.cache.get(index);\n            if (!item) {\n                let item = new listitem_1.ListItem({ index, uri, lastEventId, revision, value, dateUpdated, dateExpires });\n                this.cache.store(index, item, lastEventId);\n                this.emitItemMutationEvent(item, remote, added);\n            }\n            else {\n                item.update(lastEventId, revision, value, dateUpdated);\n                this.cache.store(index, item, lastEventId);\n                if (dateExpires !== undefined) {\n                    item.updateDateExpires(dateExpires);\n                }\n                this.emitItemMutationEvent(item, remote, false);\n            }\n        }\n    }\n    /**\n     * @private\n     */\n    emitItemMutationEvent(item, remote, added) {\n        let eventName = added ? 'itemAdded' : 'itemUpdated';\n        this.broadcastEventToListeners(eventName, { item: item, isLocal: !remote });\n    }\n    /**\n     * @private\n     */\n    _handleItemRemoved(index, eventId, oldData, dateUpdated, remote) {\n        this._updateRootDateUpdated(dateUpdated);\n        this.cache.delete(index, eventId);\n        this.broadcastEventToListeners('itemRemoved', { index: index, isLocal: !remote, value: oldData });\n    }\n    /**\n     * @private\n     */\n    _handleContextUpdate(data, eventId, dateUpdated) {\n        this._updateRootDateUpdated(dateUpdated);\n        if (this._updateContextIfRequired(data, eventId)) {\n            this.broadcastEventToListeners('contextUpdated', { context: data, isLocal: false });\n        }\n    }\n    /**\n     * @private\n     */\n    _updateContextIfRequired(data, eventId) {\n        if (!this.contextEventId || eventId > this.contextEventId) {\n            this.context = data;\n            this.contextEventId = eventId;\n            return true;\n        }\n        else {\n            logger_1.default.trace('Context update skipped, current:', this.lastEventId, ', remote:', eventId);\n            return false;\n        }\n    }\n}\nexports.SyncListImpl = SyncListImpl;\n/**\n * @class\n * @alias List\n * @classdesc Represents a Sync List, which stores an ordered list of values.\n * Use the {@link Client#list} method to obtain a reference to a Sync List.\n * @property {String} sid - List unique id, immutable identifier assigned by the system.\n * @property {String} [uniqueName=null] - List unique name, immutable identifier that can be assigned to list during creation.\n * @property {Date} dateUpdated Date when the List was last updated.\n *\n * @fires List#removed\n * @fires List#itemAdded\n * @fires List#itemRemoved\n * @fires List#itemUpdated\n */\nclass SyncList extends closeable_1.default {\n    constructor(syncListImpl) {\n        super();\n        this.syncListImpl = syncListImpl;\n        this.syncListImpl.attach(this);\n    }\n    // private props\n    get uri() {\n        return this.syncListImpl.uri;\n    }\n    get revision() {\n        return this.syncListImpl.revision;\n    }\n    get lastEventId() {\n        return this.syncListImpl.lastEventId;\n    }\n    get links() {\n        return this.syncListImpl.links;\n    }\n    get dateExpires() {\n        return this.syncListImpl.dateExpires;\n    }\n    static get type() {\n        return SyncListImpl.type;\n    }\n    get type() {\n        return SyncListImpl.type;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.syncListImpl.sid;\n    }\n    get uniqueName() {\n        return this.syncListImpl.uniqueName;\n    }\n    get dateUpdated() {\n        return this.syncListImpl.dateUpdated;\n    }\n    /**\n     * Add a new item to the list.\n     * @param {Object} value Value to be added.\n     * @param {List#ItemMetadata} [itemMetadata] Item metadata.\n     * @returns {Promise<ListItem>} A newly added item.\n     * @public\n     * @example\n     * list.push({ name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('List Item push() successful, item index:' + item.index + ', value: ', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item push() failed', error);\n     *   });\n     */\n    async push(value, itemMetadata) {\n        this.ensureNotClosed();\n        return this.syncListImpl.push(value, itemMetadata);\n    }\n    /**\n     * Assign new value to an existing item, given its index.\n     * @param {Number} index Index of the item to be updated.\n     * @param {Object} value New value to be assigned to an item.\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<ListItem>} A promise with updated item containing latest known value.\n     * The promise will be rejected if the item does not exist.\n     * @public\n     * @example\n     * list.set(42, { name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('List Item set() successful, item value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item set() failed', error);\n     *   });\n     */\n    async set(index, value, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncListImpl.set(index, value, itemMetadataUpdates);\n    }\n    /**\n     * Modify an existing item by applying a mutation function to it.\n     * @param {Number} index Index of an item to be changed.\n     * @param {List~Mutator} mutator A function that outputs a new value based on the existing value.\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<ListItem>} Resolves with the most recent item state, the output of a successful\n     *    mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>). This promise\n     *    will be rejected if the indicated item does not already exist.\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * list.mutate(42, mutatorFunction, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('List Item mutate() successful, new value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item mutate() failed', error);\n     *   });\n     */\n    async mutate(index, mutator, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncListImpl.mutate(index, mutator, itemMetadataUpdates);\n    }\n    /**\n     * Modify an existing item by appending new fields (or overwriting existing ones) with the values from Object.\n     * This is equivalent to\n     * <pre>\n     * list.mutate(42, function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {Number} index Index of an item to be changed.\n     * @param {Object} obj Set of fields to update.\n     * @param {List#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<ListItem>} A promise with a modified item containing latest known value.\n     * The promise will be rejected if an item was not found.\n     * @public\n     * @example\n     * // Say, the List Item (index: 42) value is { name: 'John Smith' }\n     * list.update(42, { age: 34 }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     // Now the List Item value is { name: 'John Smith', age: 34 }\n     *     console.log('List Item update() successful, new value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item update() failed', error);\n     *   });\n     */\n    async update(index, obj, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncListImpl.update(index, obj, itemMetadataUpdates);\n    }\n    /**\n     * Delete an item, given its index.\n     * @param {Number} index Index of an item to be removed.\n     * @returns {Promise<void>} A promise to remove an item.\n     * A promise will be rejected if an item was not found.\n     * @public\n     * @example\n     * list.remove(42)\n     *   .then(function() {\n     *     console.log('List Item remove() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item remove() failed', error);\n     *   });\n     */\n    async remove(index) {\n        this.ensureNotClosed();\n        return this.syncListImpl.remove(index);\n    }\n    /**\n     * Retrieve an item by List index.\n     * @param {Number} index Item index in a List.\n     * @returns {Promise<ListItem>} A promise with an item containing latest known value.\n     * A promise will be rejected if an item was not found.\n     * @public\n     * @example\n     * list.get(42)\n     *   .then(function(item) {\n     *     console.log('List Item get() successful, item value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List Item get() failed', error);\n     *   });\n     */\n    async get(index) {\n        this.ensureNotClosed();\n        return this.syncListImpl.get(index);\n    }\n    /**\n     * Retrieve a List context\n     * @returns {Promise<Object>} A promise with a List's context\n     * @ignore\n     */\n    async getContext() {\n        this.ensureNotClosed();\n        return this.syncListImpl.getContext();\n    }\n    /**\n     * Query a list of items from collection.\n     * @param {Object} [args] Arguments for query\n     * @param {Number} [args.from] Item index, which should be used as the offset.\n     * If undefined, starts from the beginning or end depending on args.order.\n     * @param {Number} [args.pageSize=50] Results page size.\n     * @param {'asc'|'desc'} [args.order='asc'] Numeric order of results.\n     * @returns {Promise<Paginator<ListItem>>}\n     * @public\n     * @example\n     * var pageHandler = function(paginator) {\n     *   paginator.items.forEach(function(item) {\n     *     console.log('Item ' + item.index + ': ', item.value);\n     *   });\n     *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n     *                                : null;\n     * };\n     * list.getItems({ from: 0, order: 'asc' })\n     *   .then(pageHandler)\n     *   .catch(function(error) {\n     *     console.error('List getItems() failed', error);\n     *   });\n     */\n    async getItems(args) {\n        this.ensureNotClosed();\n        return this.syncListImpl.getItems(args);\n    }\n    /**\n     * Update the time-to-live of the list.\n     * @param {Number} ttl Specifies the TTL in seconds after which the list is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * list.setTtl(3600)\n     *   .then(function() {\n     *     console.log('List setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List setTtl() failed', error);\n     *   });\n     */\n    async setTtl(ttl) {\n        this.ensureNotClosed();\n        return this.syncListImpl.setTtl(ttl);\n    }\n    /**\n     * Update the time-to-live of a list item.\n     * @param {Number} index Item index.\n     * @param {Number} ttl Specifies the TTL in seconds after which the list item is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * list.setItemTtl(42, 86400)\n     *   .then(function() {\n     *     console.log('List setItemTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List setItemTtl() failed', error);\n     *   });\n     */\n    async setItemTtl(index, ttl) {\n        this.ensureNotClosed();\n        return this.syncListImpl.setItemTtl(index, ttl);\n    }\n    /**\n     * Delete this list. It will be impossible to restore it.\n     * @return {Promise<void>} A promise that resolves when the list has been deleted.\n     * @public\n     * @example\n     * list.removeList()\n     *   .then(function() {\n     *     console.log('List removeList() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('List removeList() failed', error);\n     *   });\n     */\n    async removeList() {\n        this.ensureNotClosed();\n        return this.syncListImpl.removeList();\n    }\n    /**\n     * Conclude work with the list instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this list will continue operating and receiving events normally.\n     * @public\n     * @example\n     * list.close();\n     */\n    close() {\n        super.close();\n        this.syncListImpl.detach(this.listenerUuid);\n    }\n}\nexports.SyncList = SyncList;\nexports.default = SyncList;\n/**\n * Contains List Item metadata.\n * @typedef {Object} List#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the list item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback List~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n/**\n * Fired when a new item appears in the list, whether its creator was local or remote.\n * @event List#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {ListItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * list.on('itemAdded', function(args) {\n *   console.log('List item ' + args.item.index + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a list item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event List#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {ListItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * list.on('itemUpdated', function(args) {\n *   console.log('List item ' + args.item.index + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a list item is removed, whether the remover was local or remote.\n * @event List#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {Number} args.index The index of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * list.on('itemRemoved', function(args) {\n *   console.log('List item ' + args.index + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a list is deleted entirely, by any actor local or remote.\n * @event List#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if list was removed by local actor, 'false' otherwise.\n * @example\n * list.on('removed', function(args) {\n *   console.log('List ' + list.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n"]},"metadata":{},"sourceType":"script"}