{"ast":null,"code":"var _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\n// Generated by CoffeeScript 2.4.1\n(function () {\n  var NodeType,\n      WriterState,\n      XMLStreamWriter,\n      XMLWriterBase,\n      hasProp = {}.hasOwnProperty;\n  NodeType = require('./NodeType');\n  XMLWriterBase = require('./XMLWriterBase');\n  WriterState = require('./WriterState'); // Prints XML nodes to a stream\n\n  module.exports = XMLStreamWriter = /*#__PURE__*/function (_XMLWriterBase) {\n    \"use strict\";\n\n    _inherits(XMLStreamWriter, _XMLWriterBase);\n\n    var _super = _createSuper(XMLStreamWriter);\n\n    // Initializes a new instance of `XMLStreamWriter`\n    // `stream` output stream\n    // `options.pretty` pretty prints the result\n    // `options.indent` indentation string\n    // `options.newline` newline sequence\n    // `options.offset` a fixed number of indentations to add to every line\n    // `options.allowEmpty` do not self close empty element tags\n    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF\n    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements\n    function XMLStreamWriter(stream, options) {\n      var _this;\n\n      _classCallCheck(this, XMLStreamWriter);\n\n      _this = _super.call(this, options);\n      _this.stream = stream;\n      return _this;\n    }\n\n    _createClass(XMLStreamWriter, [{\n      key: \"endline\",\n      value: function endline(node, options, level) {\n        if (node.isLastRootNode && options.state === WriterState.CloseTag) {\n          return '';\n        } else {\n          return _get(_getPrototypeOf(XMLStreamWriter.prototype), \"endline\", this).call(this, node, options, level);\n        }\n      }\n    }, {\n      key: \"document\",\n      value: function document(doc, options) {\n        var child, i, j, k, len1, len2, ref, ref1, results;\n        ref = doc.children; // set a flag so that we don't insert a newline after the last root level node \n\n        for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n          child = ref[i];\n          child.isLastRootNode = i === doc.children.length - 1;\n        }\n\n        options = this.filterOptions(options);\n        ref1 = doc.children;\n        results = [];\n\n        for (k = 0, len2 = ref1.length; k < len2; k++) {\n          child = ref1[k];\n          results.push(this.writeChildNode(child, options, 0));\n        }\n\n        return results;\n      }\n    }, {\n      key: \"cdata\",\n      value: function cdata(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"cdata\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"comment\",\n      value: function comment(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"comment\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"declaration\",\n      value: function declaration(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"declaration\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"docType\",\n      value: function docType(node, options, level) {\n        var child, j, len1, ref;\n        level || (level = 0);\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        this.stream.write(this.indent(node, options, level));\n        this.stream.write('<!DOCTYPE ' + node.root().name); // external identifier\n\n        if (node.pubID && node.sysID) {\n          this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n        } else if (node.sysID) {\n          this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n        } // internal subset\n\n\n        if (node.children.length > 0) {\n          this.stream.write(' [');\n          this.stream.write(this.endline(node, options, level));\n          options.state = WriterState.InsideTag;\n          ref = node.children;\n\n          for (j = 0, len1 = ref.length; j < len1; j++) {\n            child = ref[j];\n            this.writeChildNode(child, options, level + 1);\n          }\n\n          options.state = WriterState.CloseTag;\n          this.stream.write(']');\n        } // close tag\n\n\n        options.state = WriterState.CloseTag;\n        this.stream.write(options.spaceBeforeSlash + '>');\n        this.stream.write(this.endline(node, options, level));\n        options.state = WriterState.None;\n        return this.closeNode(node, options, level);\n      }\n    }, {\n      key: \"element\",\n      value: function element(node, options, level) {\n        var att, attLen, child, childNodeCount, firstChildNode, j, len, len1, name, prettySuppressed, r, ratt, ref, ref1, ref2, rline;\n        level || (level = 0); // open tag\n\n        this.openNode(node, options, level);\n        options.state = WriterState.OpenTag;\n        r = this.indent(node, options, level) + '<' + node.name; // attributes\n\n        if (options.pretty && options.width > 0) {\n          len = r.length;\n          ref = node.attribs;\n\n          for (name in ref) {\n            if (!hasProp.call(ref, name)) continue;\n            att = ref[name];\n            ratt = this.attribute(att, options, level);\n            attLen = ratt.length;\n\n            if (len + attLen > options.width) {\n              rline = this.indent(node, options, level + 1) + ratt;\n              r += this.endline(node, options, level) + rline;\n              len = rline.length;\n            } else {\n              rline = ' ' + ratt;\n              r += rline;\n              len += rline.length;\n            }\n          }\n        } else {\n          ref1 = node.attribs;\n\n          for (name in ref1) {\n            if (!hasProp.call(ref1, name)) continue;\n            att = ref1[name];\n            r += this.attribute(att, options, level);\n          }\n        }\n\n        this.stream.write(r);\n        childNodeCount = node.children.length;\n        firstChildNode = childNodeCount === 0 ? null : node.children[0];\n\n        if (childNodeCount === 0 || node.children.every(function (e) {\n          return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n        })) {\n          // empty element\n          if (options.allowEmpty) {\n            this.stream.write('>');\n            options.state = WriterState.CloseTag;\n            this.stream.write('</' + node.name + '>');\n          } else {\n            options.state = WriterState.CloseTag;\n            this.stream.write(options.spaceBeforeSlash + '/>');\n          }\n        } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {\n          // do not indent text-only nodes\n          this.stream.write('>');\n          options.state = WriterState.InsideTag;\n          options.suppressPrettyCount++;\n          prettySuppressed = true;\n          this.writeChildNode(firstChildNode, options, level + 1);\n          options.suppressPrettyCount--;\n          prettySuppressed = false;\n          options.state = WriterState.CloseTag;\n          this.stream.write('</' + node.name + '>');\n        } else {\n          this.stream.write('>' + this.endline(node, options, level));\n          options.state = WriterState.InsideTag;\n          ref2 = node.children; // inner tags\n\n          for (j = 0, len1 = ref2.length; j < len1; j++) {\n            child = ref2[j];\n            this.writeChildNode(child, options, level + 1);\n          } // close tag\n\n\n          options.state = WriterState.CloseTag;\n          this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');\n        }\n\n        this.stream.write(this.endline(node, options, level));\n        options.state = WriterState.None;\n        return this.closeNode(node, options, level);\n      }\n    }, {\n      key: \"processingInstruction\",\n      value: function processingInstruction(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"processingInstruction\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"raw\",\n      value: function raw(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"raw\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"text\",\n      value: function text(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"text\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"dtdAttList\",\n      value: function dtdAttList(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"dtdAttList\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"dtdElement\",\n      value: function dtdElement(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"dtdElement\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"dtdEntity\",\n      value: function dtdEntity(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"dtdEntity\", this).call(this, node, options, level));\n      }\n    }, {\n      key: \"dtdNotation\",\n      value: function dtdNotation(node, options, level) {\n        return this.stream.write(_get(_getPrototypeOf(XMLStreamWriter.prototype), \"dtdNotation\", this).call(this, node, options, level));\n      }\n    }]);\n\n    return XMLStreamWriter;\n  }(XMLWriterBase);\n}).call(this);","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/xmlbuilder/lib/XMLStreamWriter.js"],"names":["NodeType","WriterState","XMLStreamWriter","XMLWriterBase","hasProp","hasOwnProperty","require","module","exports","stream","options","node","level","isLastRootNode","state","CloseTag","doc","child","i","j","k","len1","len2","ref","ref1","results","children","length","filterOptions","push","writeChildNode","write","openNode","OpenTag","indent","root","name","pubID","sysID","endline","InsideTag","spaceBeforeSlash","None","closeNode","att","attLen","childNodeCount","firstChildNode","len","prettySuppressed","r","ratt","ref2","rline","pretty","width","attribs","call","attribute","every","e","type","Text","Raw","value","allowEmpty","suppressPrettyCount"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var NodeType, WriterState, XMLStreamWriter, XMLWriterBase,\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLWriterBase = require('./XMLWriterBase');\n\n  WriterState = require('./WriterState');\n\n  // Prints XML nodes to a stream\n  module.exports = XMLStreamWriter = class XMLStreamWriter extends XMLWriterBase {\n    // Initializes a new instance of `XMLStreamWriter`\n\n    // `stream` output stream\n    // `options.pretty` pretty prints the result\n    // `options.indent` indentation string\n    // `options.newline` newline sequence\n    // `options.offset` a fixed number of indentations to add to every line\n    // `options.allowEmpty` do not self close empty element tags\n    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF\n    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements\n    constructor(stream, options) {\n      super(options);\n      this.stream = stream;\n    }\n\n    endline(node, options, level) {\n      if (node.isLastRootNode && options.state === WriterState.CloseTag) {\n        return '';\n      } else {\n        return super.endline(node, options, level);\n      }\n    }\n\n    document(doc, options) {\n      var child, i, j, k, len1, len2, ref, ref1, results;\n      ref = doc.children;\n      // set a flag so that we don't insert a newline after the last root level node \n      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n        child = ref[i];\n        child.isLastRootNode = i === doc.children.length - 1;\n      }\n      options = this.filterOptions(options);\n      ref1 = doc.children;\n      results = [];\n      for (k = 0, len2 = ref1.length; k < len2; k++) {\n        child = ref1[k];\n        results.push(this.writeChildNode(child, options, 0));\n      }\n      return results;\n    }\n\n    cdata(node, options, level) {\n      return this.stream.write(super.cdata(node, options, level));\n    }\n\n    comment(node, options, level) {\n      return this.stream.write(super.comment(node, options, level));\n    }\n\n    declaration(node, options, level) {\n      return this.stream.write(super.declaration(node, options, level));\n    }\n\n    docType(node, options, level) {\n      var child, j, len1, ref;\n      level || (level = 0);\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      this.stream.write(this.indent(node, options, level));\n      this.stream.write('<!DOCTYPE ' + node.root().name);\n      // external identifier\n      if (node.pubID && node.sysID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n      } else if (node.sysID) {\n        this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n      }\n      // internal subset\n      if (node.children.length > 0) {\n        this.stream.write(' [');\n        this.stream.write(this.endline(node, options, level));\n        options.state = WriterState.InsideTag;\n        ref = node.children;\n        for (j = 0, len1 = ref.length; j < len1; j++) {\n          child = ref[j];\n          this.writeChildNode(child, options, level + 1);\n        }\n        options.state = WriterState.CloseTag;\n        this.stream.write(']');\n      }\n      // close tag\n      options.state = WriterState.CloseTag;\n      this.stream.write(options.spaceBeforeSlash + '>');\n      this.stream.write(this.endline(node, options, level));\n      options.state = WriterState.None;\n      return this.closeNode(node, options, level);\n    }\n\n    element(node, options, level) {\n      var att, attLen, child, childNodeCount, firstChildNode, j, len, len1, name, prettySuppressed, r, ratt, ref, ref1, ref2, rline;\n      level || (level = 0);\n      // open tag\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<' + node.name;\n      // attributes\n      if (options.pretty && options.width > 0) {\n        len = r.length;\n        ref = node.attribs;\n        for (name in ref) {\n          if (!hasProp.call(ref, name)) continue;\n          att = ref[name];\n          ratt = this.attribute(att, options, level);\n          attLen = ratt.length;\n          if (len + attLen > options.width) {\n            rline = this.indent(node, options, level + 1) + ratt;\n            r += this.endline(node, options, level) + rline;\n            len = rline.length;\n          } else {\n            rline = ' ' + ratt;\n            r += rline;\n            len += rline.length;\n          }\n        }\n      } else {\n        ref1 = node.attribs;\n        for (name in ref1) {\n          if (!hasProp.call(ref1, name)) continue;\n          att = ref1[name];\n          r += this.attribute(att, options, level);\n        }\n      }\n      this.stream.write(r);\n      childNodeCount = node.children.length;\n      firstChildNode = childNodeCount === 0 ? null : node.children[0];\n      if (childNodeCount === 0 || node.children.every(function(e) {\n        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n      })) {\n        // empty element\n        if (options.allowEmpty) {\n          this.stream.write('>');\n          options.state = WriterState.CloseTag;\n          this.stream.write('</' + node.name + '>');\n        } else {\n          options.state = WriterState.CloseTag;\n          this.stream.write(options.spaceBeforeSlash + '/>');\n        }\n      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {\n        // do not indent text-only nodes\n        this.stream.write('>');\n        options.state = WriterState.InsideTag;\n        options.suppressPrettyCount++;\n        prettySuppressed = true;\n        this.writeChildNode(firstChildNode, options, level + 1);\n        options.suppressPrettyCount--;\n        prettySuppressed = false;\n        options.state = WriterState.CloseTag;\n        this.stream.write('</' + node.name + '>');\n      } else {\n        this.stream.write('>' + this.endline(node, options, level));\n        options.state = WriterState.InsideTag;\n        ref2 = node.children;\n        // inner tags\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          child = ref2[j];\n          this.writeChildNode(child, options, level + 1);\n        }\n        // close tag\n        options.state = WriterState.CloseTag;\n        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');\n      }\n      this.stream.write(this.endline(node, options, level));\n      options.state = WriterState.None;\n      return this.closeNode(node, options, level);\n    }\n\n    processingInstruction(node, options, level) {\n      return this.stream.write(super.processingInstruction(node, options, level));\n    }\n\n    raw(node, options, level) {\n      return this.stream.write(super.raw(node, options, level));\n    }\n\n    text(node, options, level) {\n      return this.stream.write(super.text(node, options, level));\n    }\n\n    dtdAttList(node, options, level) {\n      return this.stream.write(super.dtdAttList(node, options, level));\n    }\n\n    dtdElement(node, options, level) {\n      return this.stream.write(super.dtdElement(node, options, level));\n    }\n\n    dtdEntity(node, options, level) {\n      return this.stream.write(super.dtdEntity(node, options, level));\n    }\n\n    dtdNotation(node, options, level) {\n      return this.stream.write(super.dtdNotation(node, options, level));\n    }\n\n  };\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}