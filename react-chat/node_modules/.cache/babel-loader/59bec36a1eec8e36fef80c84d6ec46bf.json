{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar telemetry_1 = require(\"../protocol/messages/telemetry\");\n\nvar logger_1 = require(\"../logger\");\n\nvar TelemetryEventDescription = /*#__PURE__*/function () {\n  function TelemetryEventDescription(title, details, start, end, type, id) {\n    _classCallCheck(this, TelemetryEventDescription);\n\n    this.title = title;\n    this.details = details;\n    this.start = start;\n    this.type = type;\n    this.id = id;\n    this.end = end;\n  } // Prepare telemetry event right before sending it.\n  // Convert times to relative.\n\n\n  _createClass(TelemetryEventDescription, [{\n    key: \"toTelemetryEvent\",\n    value: function toTelemetryEvent() {\n      // Fix dates\n      var now = new Date();\n      var actualStart = this.start;\n      var actualEnd = this.end ? this.end : now;\n\n      if (actualEnd < actualStart) {\n        var tmp = actualEnd;\n        actualEnd = actualStart;\n        actualStart = tmp;\n      } // Converting dates to relative offset from current moment in ms\n\n\n      var startOffset = actualStart.getTime() - now.getTime();\n      var endOffset = actualEnd.getTime() - now.getTime();\n      var result = new telemetry_1.TelemetryEvent(startOffset, endOffset, this.title, this.details, this.id, this.type);\n      return result;\n    }\n  }]);\n\n  return TelemetryEventDescription;\n}();\n\nexports.TelemetryEventDescription = TelemetryEventDescription;\nvar TelemetryPoint;\n\n(function (TelemetryPoint) {\n  TelemetryPoint[TelemetryPoint[\"Start\"] = 0] = \"Start\";\n  TelemetryPoint[TelemetryPoint[\"End\"] = 1] = \"End\";\n})(TelemetryPoint || (TelemetryPoint = {}));\n\nexports.TelemetryPoint = TelemetryPoint;\nvar EventSendingLimitation;\n\n(function (EventSendingLimitation) {\n  EventSendingLimitation[EventSendingLimitation[\"MinEventsPortion\"] = 0] = \"MinEventsPortion\";\n  EventSendingLimitation[EventSendingLimitation[\"AnyEvents\"] = 1] = \"AnyEvents\";\n  EventSendingLimitation[EventSendingLimitation[\"AnyEventsIncludingUnfinished\"] = 2] = \"AnyEventsIncludingUnfinished\";\n})(EventSendingLimitation || (EventSendingLimitation = {}));\n\nexports.EventSendingLimitation = EventSendingLimitation;\n\nvar TelemetryTracker = /*#__PURE__*/function () {\n  function TelemetryTracker(config, packetInterface) {\n    _classCallCheck(this, TelemetryTracker);\n\n    // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)\n    this.minEventsPortionToSend = 50; // max events batch size to be sent in a single Telemetry message\n\n    this.maxEventsPortionToSend = 100;\n    this.pendingEvents = new Map(); // started events: have TelemetryEvent::startTime only\n\n    this.readyEvents = []; // events ready to send\n\n    this.hasInitializationFinished = false;\n    this._canSendTelemetry = false;\n    this.config = config;\n    this.packetInterface = packetInterface;\n  } // Keeping this private prevents the type declaration from being generated properly.\n  // Ideally, this should be private.\n\n\n  _createClass(TelemetryTracker, [{\n    key: \"isTelemetryEnabled\",\n    get: function get() {\n      return this.config.confirmedCapabilities.has('telemetry.v1');\n    }\n  }, {\n    key: \"canSendTelemetry\",\n    get: function get() {\n      return this._canSendTelemetry && this.isTelemetryEnabled;\n    },\n    set: function set(enable) {\n      logger_1.log.debug(\"TelemetryTracker.canSendTelemetry: \".concat(enable, \" TelemetryTracker.isTelemetryEnabled: \").concat(this.isTelemetryEnabled)); // We want to keep telemetry events added in advance but\n      // we need to purge events from previous connection when being disconnected\n\n      if (this._canSendTelemetry && !enable) {\n        this.pendingEvents.clear();\n        this.readyEvents = [];\n      }\n\n      this._canSendTelemetry = enable;\n\n      if (enable) {\n        this.sendTelemetry(EventSendingLimitation.AnyEvents);\n      }\n\n      if (enable && !this.hasInitializationFinished) {\n        this.hasInitializationFinished = true;\n      }\n    } // Add complete event\n\n  }, {\n    key: \"addTelemetryEvent\",\n    value: function addTelemetryEvent(event) {\n      // Allow adding events before initialization.\n      if (!this.canSendTelemetry && this.hasInitializationFinished) {\n        return;\n      }\n\n      this.readyEvents.push(event);\n    } // Add incomplete event (with either starting or ending time point)\n\n  }, {\n    key: \"addPartialEvent\",\n    value: function addPartialEvent(incompleteEvent, eventKey, point) {\n      logger_1.log.debug(\"Adding \".concat(point === TelemetryPoint.Start ? 'starting' : 'ending', \" timepoint for '\").concat(eventKey, \"' event\"));\n      var exists = this.pendingEvents.has(eventKey);\n\n      if (point === TelemetryPoint.Start) {\n        if (exists) {\n          logger_1.log.debug(\"Overwriting starting point for '\".concat(eventKey, \"' event\"));\n        }\n\n        this.pendingEvents.set(eventKey, incompleteEvent);\n      } else {\n        if (!exists) {\n          logger_1.log.info(\"Could not find started event for '\".concat(eventKey, \"' event\"));\n          return;\n        }\n\n        this.addTelemetryEvent(this.merge(this.pendingEvents.get(eventKey), incompleteEvent));\n        this.pendingEvents.delete(eventKey);\n      }\n    }\n  }, {\n    key: \"getTelemetryToSend\",\n    value: function getTelemetryToSend(sendingLimit) {\n      if (!this.canSendTelemetry || this.readyEvents.length == 0) {\n        return []; // Events are collected but not sent until telemetry is enabled\n      }\n\n      if (sendingLimit == EventSendingLimitation.MinEventsPortion && this.readyEvents.length < this.minEventsPortionToSend) {\n        return [];\n      }\n\n      return this.getTelemetryPortion(sendingLimit == EventSendingLimitation.AnyEventsIncludingUnfinished);\n    }\n  }, {\n    key: \"getTelemetryPortion\",\n    value: function getTelemetryPortion(includeUnfinished) {\n      var _this = this;\n\n      var eventsPortionToSend = Math.min(this.readyEvents.length, this.maxEventsPortionToSend);\n      var res = this.readyEvents.splice(0, eventsPortionToSend);\n\n      if (includeUnfinished && res.length < this.maxEventsPortionToSend) {\n        this.pendingEvents.forEach(function (value, key) {\n          if (res.length >= _this.maxEventsPortionToSend) {\n            return; // @fixme does not end the loop early\n          }\n\n          var event = _this.pendingEvents.get(key);\n\n          _this.pendingEvents.delete(key);\n\n          res.push(new TelemetryEventDescription(\"[UNFINISHED] \".concat(event.title), // add prefix title to mark unfinished events for CleanSock\n          event.details, event.start, null, // Not ended, on sending will be replaced with now\n          event.type, event.id));\n        });\n      }\n\n      return res;\n    } // Merging 2 partial events:\n    //   use start.startTime & end.endTime.\n    // For other fields,\n    //   if there are values in end, use them,\n    //   else use values from start.\n\n  }, {\n    key: \"merge\",\n    value: function merge(start, end) {\n      return new TelemetryEventDescription(end.title ? end.title : start.title, end.details ? end.details : start.details, start.start, end.end, end.type ? end.type : start.type, end.id ? end.id : start.id);\n    }\n  }, {\n    key: \"sendTelemetryIfMinimalPortionCollected\",\n    value: function sendTelemetryIfMinimalPortionCollected() {\n      this.sendTelemetry(EventSendingLimitation.MinEventsPortion);\n    } // NB: getTelemetryToSend will return non-empty array only if we have already received initReply\n    // and telemetry.v1 capability is enabled there.\n\n  }, {\n    key: \"sendTelemetry\",\n    value: function sendTelemetry(limit) {\n      var events = this.getTelemetryToSend(limit);\n\n      if (events.length === 0) {\n        return; // not enough telemetry data collected\n      }\n\n      try {\n        this.packetInterface.send(new telemetry_1.Telemetry(events.map(function (e) {\n          return e.toTelemetryEvent();\n        })));\n      } catch (err) {\n        logger_1.log.debug(\"Error while sending \".concat(events.length, \" telemetry events due to \").concat(err, \"; they will be resubmitted\"));\n        this.readyEvents = this.readyEvents.concat(events);\n      }\n    }\n  }]);\n\n  return TelemetryTracker;\n}();\n\nexports.TelemetryTracker = TelemetryTracker;","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilio-notifications/node_modules/twilsock/lib/services/telemetrytracker.js"],"names":["Object","defineProperty","exports","value","telemetry_1","require","logger_1","TelemetryEventDescription","title","details","start","end","type","id","now","Date","actualStart","actualEnd","tmp","startOffset","getTime","endOffset","result","TelemetryEvent","TelemetryPoint","EventSendingLimitation","TelemetryTracker","config","packetInterface","minEventsPortionToSend","maxEventsPortionToSend","pendingEvents","Map","readyEvents","hasInitializationFinished","_canSendTelemetry","confirmedCapabilities","has","isTelemetryEnabled","enable","log","debug","clear","sendTelemetry","AnyEvents","event","canSendTelemetry","push","incompleteEvent","eventKey","point","Start","exists","set","info","addTelemetryEvent","merge","get","delete","sendingLimit","length","MinEventsPortion","getTelemetryPortion","AnyEventsIncludingUnfinished","includeUnfinished","eventsPortionToSend","Math","min","res","splice","forEach","key","limit","events","getTelemetryToSend","send","Telemetry","map","e","toTelemetryEvent","err","concat"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst telemetry_1 = require(\"../protocol/messages/telemetry\");\nconst logger_1 = require(\"../logger\");\nclass TelemetryEventDescription {\n    constructor(title, details, start, end, type, id) {\n        this.title = title;\n        this.details = details;\n        this.start = start;\n        this.type = type;\n        this.id = id;\n        this.end = end;\n    }\n    // Prepare telemetry event right before sending it.\n    // Convert times to relative.\n    toTelemetryEvent() {\n        // Fix dates\n        const now = new Date();\n        let actualStart = this.start;\n        let actualEnd = this.end ? this.end : now;\n        if (actualEnd < actualStart) {\n            let tmp = actualEnd;\n            actualEnd = actualStart;\n            actualStart = tmp;\n        }\n        // Converting dates to relative offset from current moment in ms\n        const startOffset = actualStart.getTime() - now.getTime();\n        const endOffset = actualEnd.getTime() - now.getTime();\n        const result = new telemetry_1.TelemetryEvent(startOffset, endOffset, this.title, this.details, this.id, this.type);\n        return result;\n    }\n}\nexports.TelemetryEventDescription = TelemetryEventDescription;\nvar TelemetryPoint;\n(function (TelemetryPoint) {\n    TelemetryPoint[TelemetryPoint[\"Start\"] = 0] = \"Start\";\n    TelemetryPoint[TelemetryPoint[\"End\"] = 1] = \"End\";\n})(TelemetryPoint || (TelemetryPoint = {}));\nexports.TelemetryPoint = TelemetryPoint;\nvar EventSendingLimitation;\n(function (EventSendingLimitation) {\n    EventSendingLimitation[EventSendingLimitation[\"MinEventsPortion\"] = 0] = \"MinEventsPortion\";\n    EventSendingLimitation[EventSendingLimitation[\"AnyEvents\"] = 1] = \"AnyEvents\";\n    EventSendingLimitation[EventSendingLimitation[\"AnyEventsIncludingUnfinished\"] = 2] = \"AnyEventsIncludingUnfinished\";\n})(EventSendingLimitation || (EventSendingLimitation = {}));\nexports.EventSendingLimitation = EventSendingLimitation;\nclass TelemetryTracker {\n    constructor(config, packetInterface) {\n        // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)\n        this.minEventsPortionToSend = 50;\n        // max events batch size to be sent in a single Telemetry message\n        this.maxEventsPortionToSend = 100;\n        this.pendingEvents = new Map(); // started events: have TelemetryEvent::startTime only\n        this.readyEvents = []; // events ready to send\n        this.hasInitializationFinished = false;\n        this._canSendTelemetry = false;\n        this.config = config;\n        this.packetInterface = packetInterface;\n    }\n    // Keeping this private prevents the type declaration from being generated properly.\n    // Ideally, this should be private.\n    get isTelemetryEnabled() {\n        return this.config.confirmedCapabilities.has('telemetry.v1');\n    }\n    get canSendTelemetry() {\n        return this._canSendTelemetry && this.isTelemetryEnabled;\n    }\n    set canSendTelemetry(enable) {\n        logger_1.log.debug(`TelemetryTracker.canSendTelemetry: ${enable} TelemetryTracker.isTelemetryEnabled: ${this.isTelemetryEnabled}`);\n        // We want to keep telemetry events added in advance but\n        // we need to purge events from previous connection when being disconnected\n        if (this._canSendTelemetry && !enable) {\n            this.pendingEvents.clear();\n            this.readyEvents = [];\n        }\n        this._canSendTelemetry = enable;\n        if (enable) {\n            this.sendTelemetry(EventSendingLimitation.AnyEvents);\n        }\n        if (enable && !this.hasInitializationFinished) {\n            this.hasInitializationFinished = true;\n        }\n    }\n    // Add complete event\n    addTelemetryEvent(event) {\n        // Allow adding events before initialization.\n        if (!this.canSendTelemetry && this.hasInitializationFinished) {\n            return;\n        }\n        this.readyEvents.push(event);\n    }\n    // Add incomplete event (with either starting or ending time point)\n    addPartialEvent(incompleteEvent, eventKey, point) {\n        logger_1.log.debug(`Adding ${point === TelemetryPoint.Start ? 'starting' : 'ending'} timepoint for '${eventKey}' event`);\n        let exists = this.pendingEvents.has(eventKey);\n        if (point === TelemetryPoint.Start) {\n            if (exists) {\n                logger_1.log.debug(`Overwriting starting point for '${eventKey}' event`);\n            }\n            this.pendingEvents.set(eventKey, incompleteEvent);\n        }\n        else {\n            if (!exists) {\n                logger_1.log.info(`Could not find started event for '${eventKey}' event`);\n                return;\n            }\n            this.addTelemetryEvent(this.merge(this.pendingEvents.get(eventKey), incompleteEvent));\n            this.pendingEvents.delete(eventKey);\n        }\n    }\n    getTelemetryToSend(sendingLimit) {\n        if (!this.canSendTelemetry || this.readyEvents.length == 0) {\n            return []; // Events are collected but not sent until telemetry is enabled\n        }\n        if (sendingLimit == EventSendingLimitation.MinEventsPortion && this.readyEvents.length < this.minEventsPortionToSend) {\n            return [];\n        }\n        return this.getTelemetryPortion(sendingLimit == EventSendingLimitation.AnyEventsIncludingUnfinished);\n    }\n    getTelemetryPortion(includeUnfinished) {\n        const eventsPortionToSend = Math.min(this.readyEvents.length, this.maxEventsPortionToSend);\n        let res = this.readyEvents.splice(0, eventsPortionToSend);\n        if (includeUnfinished && res.length < this.maxEventsPortionToSend) {\n            this.pendingEvents.forEach((value, key) => {\n                if (res.length >= this.maxEventsPortionToSend) {\n                    return; // @fixme does not end the loop early\n                }\n                let event = this.pendingEvents.get(key);\n                this.pendingEvents.delete(key);\n                res.push(new TelemetryEventDescription(`[UNFINISHED] ${event.title}`, // add prefix title to mark unfinished events for CleanSock\n                event.details, event.start, null, // Not ended, on sending will be replaced with now\n                event.type, event.id));\n            });\n        }\n        return res;\n    }\n    // Merging 2 partial events:\n    //   use start.startTime & end.endTime.\n    // For other fields,\n    //   if there are values in end, use them,\n    //   else use values from start.\n    merge(start, end) {\n        return new TelemetryEventDescription(end.title ? end.title : start.title, end.details ? end.details : start.details, start.start, end.end, end.type ? end.type : start.type, end.id ? end.id : start.id);\n    }\n    sendTelemetryIfMinimalPortionCollected() {\n        this.sendTelemetry(EventSendingLimitation.MinEventsPortion);\n    }\n    // NB: getTelemetryToSend will return non-empty array only if we have already received initReply\n    // and telemetry.v1 capability is enabled there.\n    sendTelemetry(limit) {\n        const events = this.getTelemetryToSend(limit);\n        if (events.length === 0) {\n            return; // not enough telemetry data collected\n        }\n        try {\n            this.packetInterface.send(new telemetry_1.Telemetry(events.map(e => e.toTelemetryEvent())));\n        }\n        catch (err) {\n            logger_1.log.debug(`Error while sending ${events.length} telemetry events due to ${err}; they will be resubmitted`);\n            this.readyEvents = this.readyEvents.concat(events);\n        }\n    }\n}\nexports.TelemetryTracker = TelemetryTracker;\n"]},"metadata":{},"sourceType":"script"}