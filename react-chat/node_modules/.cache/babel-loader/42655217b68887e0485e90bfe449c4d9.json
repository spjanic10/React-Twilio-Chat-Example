{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subscriptions = void 0;\n\nvar operation_retrier_1 = require(\"operation-retrier\");\n\nvar syncerror_1 = require(\"./utils/syncerror\");\n\nvar logger_1 = require(\"./utils/logger\");\n\nvar twilsock_1 = require(\"twilsock\");\n/**\n * A data container used by the Subscriptions class to track subscribed entities' local\n * representations and their state.\n */\n\n\nvar SubscribedEntity = /*#__PURE__*/function () {\n  function SubscribedEntity(entity) {\n    _classCallCheck(this, SubscribedEntity);\n\n    this.localObject = entity;\n    this.pendingCorrelationId = null;\n    this.pendingAction = null;\n    this.established = false;\n    this.retryCount = 0;\n  }\n\n  _createClass(SubscribedEntity, [{\n    key: \"sid\",\n    get: function get() {\n      return this.localObject.sid;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.localObject.type;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.localObject.lastEventId;\n    } // below properties are specific to Insights only\n\n  }, {\n    key: \"indexName\",\n    get: function get() {\n      return this.localObject.indexName;\n    }\n  }, {\n    key: \"queryString\",\n    get: function get() {\n      return this.localObject.queryString;\n    }\n  }, {\n    key: \"isEstablished\",\n    get: function get() {\n      return this.established;\n    }\n  }, {\n    key: \"update\",\n    value: function update(event, isStrictlyOrdered) {\n      this.localObject._update(event, isStrictlyOrdered);\n    }\n  }, {\n    key: \"updatePending\",\n    value: function updatePending(action, correlationId) {\n      this.pendingAction = action;\n      this.pendingCorrelationId = correlationId;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.updatePending(null, null);\n      this.retryCount = 0;\n      this.established = false;\n      this.setSubscriptionState('none');\n    }\n  }, {\n    key: \"markAsFailed\",\n    value: function markAsFailed(message) {\n      this.rejectedWithError = message.error;\n      this.updatePending(null, null);\n      this.localObject.reportFailure(new syncerror_1.SyncError(\"Failed to subscribe on service events: \".concat(message.error.message), message.error.status, message.error.code));\n    }\n  }, {\n    key: \"complete\",\n    value: function complete(eventId) {\n      this.updatePending(null, null);\n      this.established = true;\n\n      this.localObject._advanceLastEventId(eventId);\n    }\n  }, {\n    key: \"setSubscriptionState\",\n    value: function setSubscriptionState(newState) {\n      this.localObject._setSubscriptionState(newState);\n    }\n  }]);\n\n  return SubscribedEntity;\n}();\n/**\n * @class Subscriptions\n * @classdesc A manager which, in batches of varying size, continuously persists the\n *      subscription intent of the caller to the Sync backend until it achieves a\n *      converged state.\n */\n\n\nvar Subscriptions = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.\n   *\n   * @param {object} config may include a key 'backoffConfig', wherein any of the parameters\n   *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.\n   *\n   * @param {Network} must be a viable running Sync Network object, useful for routing requests.\n   */\n  function Subscriptions(services) {\n    var _this = this;\n\n    _classCallCheck(this, Subscriptions);\n\n    this.isConnected = false;\n    this.maxBatchSize = 100; // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration\n    // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.\n    // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.\n\n    this.subscriptionTtlTimer = null;\n    this.pendingPokeReason = null;\n    this.services = services;\n    this.subscriptions = new Map();\n    this.persisted = new Map();\n    this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();\n    var defaultBackoffConfig = {\n      randomisationFactor: 0.2,\n      initialDelay: 100,\n      maxDelay: 2 * 60 * 1000\n    };\n    this.backoff = operation_retrier_1.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig)); // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)\n    // backoff 'ready' event, at which point a new subscription set is calculated.\n\n    this.backoff.on('ready', function () {\n      var _this$getSubscription = _this.getSubscriptionUpdateBatch(),\n          action = _this$getSubscription.action,\n          subscriptionRequests = _this$getSubscription.subscriptions;\n\n      if (action) {\n        _this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);\n      } else {\n        _this.backoff.reset();\n\n        logger_1.default.debug('All subscriptions resolved.');\n      }\n    });\n  }\n\n  _createClass(Subscriptions, [{\n    key: \"getSubscriptionUpdateBatch\",\n    value: function getSubscriptionUpdateBatch() {\n      function subtract(these, those, action, limit) {\n        var result = [];\n\n        var _iterator = _createForOfIteratorHelper(these),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n                thisKey = _step$value[0],\n                thisValue = _step$value[1];\n\n            var otherValue = those.get(thisKey);\n\n            if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {\n              result.push(thisValue);\n\n              if (limit && result.length >= limit) {\n                break;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return result;\n      }\n\n      var listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);\n\n      if (listToAdd.length > 0) {\n        return {\n          action: 'establish',\n          subscriptions: listToAdd\n        };\n      }\n\n      var listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);\n\n      if (listToRemove.length > 0) {\n        return {\n          action: 'cancel',\n          subscriptions: listToRemove\n        };\n      }\n\n      return {\n        action: null,\n        subscriptions: null\n      };\n    }\n  }, {\n    key: \"persist\",\n    value: function persist() {\n      this.backoff.backoff();\n    }\n  }, {\n    key: \"applyNewSubscriptionUpdateBatch\",\n    value: function () {\n      var _applyNewSubscriptionUpdateBatch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(action, requests) {\n        var _this2 = this;\n\n        var correlationId, _iterator2, _step2, subscribed, reason, response, newMaxBatchSize, subscriptionTtlInS, isNumeric, isValidTtl, estimatedDeliveryInMs, _isNumeric, isValidTimeout, _iterator3, _step3, attemptedSubscription;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.isConnected) {\n                  _context.next = 4;\n                  break;\n                }\n\n                logger_1.default.debug(\"Twilsock connection (required for subscription) not ready; waiting\\u2026\");\n                this.backoff.reset();\n                return _context.abrupt(\"return\");\n\n              case 4:\n                // Keeping in mind that events may begin flowing _before_ we receive the response\n                requests = this.processLocalActions(action, requests);\n                correlationId = new Date().getTime();\n                _iterator2 = _createForOfIteratorHelper(requests);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    subscribed = _step2.value;\n                    this.recordActionAttemptOn(subscribed, action, correlationId);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                reason = this.pendingPokeReason;\n                this.pendingPokeReason = null; // Send this batch to the service\n\n                _context.prev = 10;\n                _context.next = 13;\n                return this.request(action, correlationId, reason, requests);\n\n              case 13:\n                response = _context.sent;\n                newMaxBatchSize = response.body.max_batch_size;\n\n                if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {\n                  this.maxBatchSize = newMaxBatchSize;\n                }\n\n                if (!this.subscriptionTtlTimer) {\n                  subscriptionTtlInS = response.body.ttl_in_s;\n                  isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);\n                  isValidTtl = isNumeric && subscriptionTtlInS > 0;\n\n                  if (isValidTtl) {\n                    this.subscriptionTtlTimer = setTimeout(function () {\n                      return _this2.onSubscriptionTtlElapsed();\n                    }, subscriptionTtlInS * 1000);\n                  }\n                }\n\n                if (action === 'establish') {\n                  estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;\n                  _isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);\n                  isValidTimeout = _isNumeric && estimatedDeliveryInMs > 0;\n\n                  if (isValidTimeout) {\n                    setTimeout(function () {\n                      return _this2.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests);\n                    }, estimatedDeliveryInMs);\n                  } else {\n                    logger_1.default.error(\"Invalid timeout: \".concat(estimatedDeliveryInMs));\n                  }\n\n                  requests.filter(function (r) {\n                    return r.pendingCorrelationId === correlationId;\n                  }).forEach(function (r) {\n                    return r.setSubscriptionState('response_in_flight');\n                  });\n                }\n\n                this.backoff.reset();\n                _context.next = 26;\n                break;\n\n              case 21:\n                _context.prev = 21;\n                _context.t0 = _context[\"catch\"](10);\n                _iterator3 = _createForOfIteratorHelper(requests);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    attemptedSubscription = _step3.value;\n                    this.recordActionFailureOn(attemptedSubscription, action);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                if (_context.t0 instanceof twilsock_1.TransportUnavailableError) {\n                  logger_1.default.debug(\"Twilsock connection (required for subscription) not ready (c:\".concat(correlationId, \"); waiting\\u2026\"));\n                  this.backoff.reset();\n                } else {\n                  logger_1.default.debug(\"Failed an attempt to \".concat(action, \" subscriptions (c:\").concat(correlationId, \"); retrying\"), _context.t0);\n                  this.persist();\n                }\n\n              case 26:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[10, 21]]);\n      }));\n\n      function applyNewSubscriptionUpdateBatch(_x, _x2) {\n        return _applyNewSubscriptionUpdateBatch.apply(this, arguments);\n      }\n\n      return applyNewSubscriptionUpdateBatch;\n    }()\n  }, {\n    key: \"verifyPokeDelivery\",\n    value: function verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {\n      var _this3 = this;\n\n      var lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);\n      var silencePeriod = lastReceived ? new Date().getTime() - lastReceived : estimatedDeliveryInMs;\n\n      if (silencePeriod >= estimatedDeliveryInMs) {\n        // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again\n        requests.filter(function (r) {\n          return r.pendingCorrelationId === correlationId;\n        }).forEach(function (r) {\n          r.updatePending(null, null);\n          r.retryCount++;\n\n          _this3.persisted.delete(r.sid);\n        });\n        this.persist();\n        this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);\n      } else {\n        // Otherwise, the poke responses are probably in transit and we should wait for them\n        var timeoutExtension = estimatedDeliveryInMs - silencePeriod;\n        setTimeout(function () {\n          return _this3.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests);\n        }, timeoutExtension);\n      }\n    }\n  }, {\n    key: \"processLocalActions\",\n    value: function processLocalActions(action, requests) {\n      if (action === 'cancel') {\n        return requests.filter(function (request) {\n          return !request.rejectedWithError;\n        });\n      }\n\n      return requests;\n    }\n  }, {\n    key: \"recordActionAttemptOn\",\n    value: function recordActionAttemptOn(attemptedSubscription, action, correlationId) {\n      attemptedSubscription.setSubscriptionState('request_in_flight');\n\n      if (action === 'establish') {\n        this.persisted.set(attemptedSubscription.sid, attemptedSubscription);\n        attemptedSubscription.updatePending(action, correlationId);\n      } else {\n        // cancel\n        var persistedSubscription = this.persisted.get(attemptedSubscription.sid);\n\n        if (persistedSubscription) {\n          persistedSubscription.updatePending(action, correlationId);\n        }\n      }\n    }\n  }, {\n    key: \"recordActionFailureOn\",\n    value: function recordActionFailureOn(attemptedSubscription, action) {\n      attemptedSubscription.setSubscriptionState('none');\n      attemptedSubscription.updatePending(null, null);\n\n      if (action === 'establish') {\n        this.persisted.delete(attemptedSubscription.sid);\n      }\n    }\n  }, {\n    key: \"request\",\n    value: function request(action, correlationId, reason, objects) {\n      var requests = objects.map(function (object) {\n        return {\n          object_sid: object.sid,\n          object_type: object.type,\n          last_event_id: action === 'establish' ? object.lastEventId : undefined,\n          index_name: action === 'establish' ? object.indexName : undefined,\n          query_string: action === 'establish' ? object.queryString : undefined\n        };\n      });\n      var retriedRequests = objects.filter(function (a) {\n        return a.retryCount > 0;\n      }).length;\n      logger_1.default.debug(\"Attempting '\".concat(action, \"' request (c:\").concat(correlationId, \"):\"), requests);\n      var requestBody = {\n        event_protocol_version: 3,\n        action: action,\n        correlation_id: correlationId,\n        retried_requests: retriedRequests,\n        ttl_in_s: -1,\n        requests: requests\n      };\n\n      if (reason === 'ttl') {\n        requestBody.reason = reason;\n      }\n\n      return this.services.network.post(this.services.config.subscriptionsUri, requestBody);\n    }\n    /**\n     * Establishes intent to be subscribed to this entity. That subscription will be effected\n     * asynchronously.\n     * If subscription to the given sid already exists, it will be overwritten.\n     *\n     * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.\n     * @param {Object} entity should represent the (singular) local representation of this entity.\n     *      Incoming events and modifications to the entity will be directed at the _update() function\n     *      of this provided reference.\n     *\n     * @return undefined\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(sid, entity) {\n      logger_1.default.debug(\"Establishing intent to subscribe to \".concat(sid));\n      var existingSubscription = this.subscriptions.get(sid);\n\n      if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {\n        // If last event id is the same as before - we're fine\n        return;\n      }\n\n      this.persisted.delete(sid);\n      this.subscriptions.set(sid, new SubscribedEntity(entity));\n      this.persist();\n    }\n    /**\n     * Establishes the caller's intent to no longer be subscribed to this entity. Following this\n     * call, no further events shall be routed to the local representation of the entity, even\n     * though a server-side subscription may take more time to actually terminate.\n     *\n     * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.\n     *      This call only has meaningful effect if that entity is subscribed at the\n     *      time of call. Otherwise does nothing.\n     *\n     * @return undefined\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(sid) {\n      logger_1.default.debug(\"Establishing intent to unsubscribe from \".concat(sid));\n      var removed = this.subscriptions.delete(sid);\n\n      if (removed) {\n        this.persist();\n      }\n    }\n    /**\n     * The point of ingestion for remote incoming messages (e.g. new data was written to a map\n     * to which we are subscribed).\n     *\n     * @param {object} message is the full, unaltered body of the incoming notification.\n     *\n     * @return undefined\n     */\n\n  }, {\n    key: \"acceptMessage\",\n    value: function acceptMessage(message, isStrictlyOrdered) {\n      logger_1.default.trace('Subscriptions received', message);\n\n      if (message.correlation_id) {\n        this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());\n      }\n\n      var event_type;\n\n      switch (message.event_type) {\n        case 'subscription_established':\n          this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);\n          break;\n\n        case 'subscription_canceled':\n          this.applySubscriptionCancelledMessage(message.event, message.correlation_id);\n          break;\n\n        case 'subscription_failed':\n          this.applySubscriptionFailedMessage(message.event, message.correlation_id);\n          break;\n\n        case (event_type = message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:\n          {\n            var typedSid;\n\n            switch (event_type[0]) {\n              case 'map_':\n                typedSid = message.event.map_sid;\n                break;\n\n              case 'list_':\n                typedSid = message.event.list_sid;\n                break;\n\n              case 'document_':\n                typedSid = message.event.document_sid;\n                break;\n\n              case 'stream_':\n                typedSid = message.event.stream_sid;\n                break;\n\n              case 'live_query_':\n                typedSid = message.event.query_id; // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them\n                // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned\n                // to this type in legacy clients, which we have to support now; hence a hack)\n\n                isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries\n\n                if (message.strictly_ordered === true) {\n                  isStrictlyOrdered = true;\n                }\n\n                break;\n\n              default:\n                typedSid = undefined;\n            }\n\n            this.applyEventToSubscribedEntity(typedSid, message, isStrictlyOrdered);\n          }\n          break;\n\n        default:\n          logger_1.default.debug(\"Dropping unknown message type \".concat(message.event_type));\n          break;\n      }\n    }\n  }, {\n    key: \"applySubscriptionEstablishedMessage\",\n    value: function applySubscriptionEstablishedMessage(message, correlationId) {\n      var sid = message.object_sid;\n      var subscriptionIntent = this.persisted.get(message.object_sid);\n\n      if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {\n        if (message.replay_status === 'interrupted') {\n          logger_1.default.debug(\"Event Replay for subscription to \".concat(sid, \" (c:\").concat(correlationId, \") interrupted; continuing eagerly.\"));\n          subscriptionIntent.updatePending(null, null);\n          this.persisted.delete(subscriptionIntent.sid);\n          this.backoff.reset();\n        } else if (message.replay_status === 'completed') {\n          logger_1.default.debug(\"Event Replay for subscription to \".concat(sid, \" (c:\").concat(correlationId, \") completed. Subscription is ready.\"));\n          subscriptionIntent.complete(message.last_event_id);\n          this.persisted.set(message.object_sid, subscriptionIntent);\n          subscriptionIntent.setSubscriptionState('established');\n          this.backoff.reset();\n        }\n      } else {\n        logger_1.default.debug(\"Late message for \".concat(message.object_sid, \" (c:\").concat(correlationId, \") dropped.\"));\n      }\n\n      this.persist();\n    }\n  }, {\n    key: \"applySubscriptionCancelledMessage\",\n    value: function applySubscriptionCancelledMessage(message, correlationId) {\n      var persistedSubscription = this.persisted.get(message.object_sid);\n\n      if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {\n        persistedSubscription.updatePending(null, null);\n        persistedSubscription.setSubscriptionState('none');\n        this.persisted.delete(message.object_sid);\n      } else {\n        logger_1.default.debug(\"Late message for \".concat(message.object_sid, \" (c:\").concat(correlationId, \") dropped.\"));\n      }\n\n      this.persist();\n    }\n  }, {\n    key: \"applySubscriptionFailedMessage\",\n    value: function applySubscriptionFailedMessage(message, correlationId) {\n      var sid = message.object_sid;\n      var subscriptionIntent = this.subscriptions.get(sid);\n      var subscription = this.persisted.get(sid);\n\n      if (subscriptionIntent && subscription) {\n        if (subscription.pendingCorrelationId === correlationId) {\n          logger_1.default.error(\"Failed to subscribe on \".concat(subscription.sid), message.error);\n          subscription.markAsFailed(message);\n          subscription.setSubscriptionState('none');\n        }\n      } else if (!subscriptionIntent && subscription) {\n        this.persisted.delete(sid);\n        subscription.setSubscriptionState('none');\n      }\n\n      this.persist();\n    }\n  }, {\n    key: \"applyEventToSubscribedEntity\",\n    value: function applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {\n      var _this4 = this;\n\n      if (!sid) {\n        return;\n      } // Looking for subscription descriptor to check if poke has been completed\n\n\n      isStrictlyOrdered = isStrictlyOrdered || function () {\n        var subscription = _this4.persisted.get(sid);\n\n        return subscription && subscription.isEstablished;\n      }(); // Still searching for subscriptionIntents. User could remove subscription already\n\n\n      var subscriptionIntent = this.subscriptions.get(sid);\n\n      if (subscriptionIntent) {\n        message.event.type = message.event_type;\n        subscriptionIntent.update(message.event, isStrictlyOrdered);\n      } else {\n        logger_1.default.debug(\"Message dropped for SID '\".concat(sid, \"', for which there is no subscription.\"));\n      }\n    }\n  }, {\n    key: \"onConnectionStateChanged\",\n    value: function onConnectionStateChanged(isConnected) {\n      this.isConnected = isConnected;\n\n      if (isConnected) {\n        this.poke('reconnect');\n      }\n    }\n  }, {\n    key: \"onSubscriptionTtlElapsed\",\n    value: function onSubscriptionTtlElapsed() {\n      if (this.isConnected) {\n        this.poke('ttl');\n      }\n    }\n    /**\n     * Prompts a playback of any missed changes made to any subscribed object. This method\n     * should be invoked whenever the connectivity layer has experienced cross-cutting\n     * delivery failures that would affect the entire local sync set. Any tangible result\n     * of this operation will result in calls to the _update() function of subscribed\n     * Sync entities.\n     */\n\n  }, {\n    key: \"poke\",\n    value: function poke(reason) {\n      logger_1.default.debug(\"Triggering event replay for all subscriptions, reason=\".concat(reason));\n      this.pendingPokeReason = reason;\n\n      if (this.subscriptionTtlTimer) {\n        clearTimeout(this.subscriptionTtlTimer);\n        this.subscriptionTtlTimer = null;\n      }\n\n      var failedSubscriptions = [];\n\n      var _iterator4 = _createForOfIteratorHelper(this.persisted.values()),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _it = _step4.value;\n\n          _it.reset();\n\n          if (_it.rejectedWithError) {\n            failedSubscriptions.push(_it);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this.persisted.clear();\n\n      for (var _i = 0, _failedSubscriptions = failedSubscriptions; _i < _failedSubscriptions.length; _i++) {\n        var it = _failedSubscriptions[_i];\n        this.persisted.set(it.sid, it);\n      }\n\n      this.persist();\n    }\n    /**\n     * Stops all communication, clears any subscription intent, and returns.\n     */\n\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      this.backoff.reset();\n      this.subscriptions.clear();\n    }\n  }]);\n\n  return Subscriptions;\n}();\n\nexports.Subscriptions = Subscriptions;","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilio-sync/lib/subscriptions.js"],"names":["Object","defineProperty","exports","value","Subscriptions","operation_retrier_1","require","syncerror_1","logger_1","twilsock_1","SubscribedEntity","entity","localObject","pendingCorrelationId","pendingAction","established","retryCount","sid","type","lastEventId","indexName","queryString","event","isStrictlyOrdered","_update","action","correlationId","updatePending","setSubscriptionState","message","rejectedWithError","error","reportFailure","SyncError","status","code","eventId","_advanceLastEventId","newState","_setSubscriptionState","services","isConnected","maxBatchSize","subscriptionTtlTimer","pendingPokeReason","subscriptions","Map","persisted","latestPokeResponseArrivalTimestampByCorrelationId","defaultBackoffConfig","randomisationFactor","initialDelay","maxDelay","backoff","Backoff","exponential","assign","config","backoffConfig","on","getSubscriptionUpdateBatch","subscriptionRequests","applyNewSubscriptionUpdateBatch","reset","default","debug","subtract","these","those","limit","result","thisKey","thisValue","otherValue","get","push","length","listToAdd","listToRemove","requests","processLocalActions","Date","getTime","subscribed","recordActionAttemptOn","reason","request","response","newMaxBatchSize","body","max_batch_size","isNaN","parseInt","isFinite","subscriptionTtlInS","ttl_in_s","isNumeric","parseFloat","isValidTtl","setTimeout","onSubscriptionTtlElapsed","estimatedDeliveryInMs","estimated_delivery_in_ms","isValidTimeout","verifyPokeDelivery","filter","r","forEach","attemptedSubscription","recordActionFailureOn","TransportUnavailableError","persist","lastReceived","silencePeriod","delete","timeoutExtension","set","persistedSubscription","objects","map","object","object_sid","object_type","last_event_id","undefined","index_name","query_string","retriedRequests","a","requestBody","event_protocol_version","correlation_id","retried_requests","network","post","subscriptionsUri","existingSubscription","removed","trace","event_type","applySubscriptionEstablishedMessage","applySubscriptionCancelledMessage","applySubscriptionFailedMessage","match","input","typedSid","map_sid","list_sid","document_sid","stream_sid","query_id","strictly_ordered","applyEventToSubscribedEntity","subscriptionIntent","replay_status","complete","subscription","markAsFailed","isEstablished","update","poke","clearTimeout","failedSubscriptions","values","it","clear"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscriptions = void 0;\nconst operation_retrier_1 = require(\"operation-retrier\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst twilsock_1 = require(\"twilsock\");\n/**\n * A data container used by the Subscriptions class to track subscribed entities' local\n * representations and their state.\n */\nclass SubscribedEntity {\n    constructor(entity) {\n        this.localObject = entity;\n        this.pendingCorrelationId = null;\n        this.pendingAction = null;\n        this.established = false;\n        this.retryCount = 0;\n    }\n    get sid() {\n        return this.localObject.sid;\n    }\n    get type() {\n        return this.localObject.type;\n    }\n    get lastEventId() {\n        return this.localObject.lastEventId;\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return this.localObject.indexName;\n    }\n    get queryString() {\n        return this.localObject.queryString;\n    }\n    get isEstablished() {\n        return this.established;\n    }\n    update(event, isStrictlyOrdered) {\n        this.localObject._update(event, isStrictlyOrdered);\n    }\n    updatePending(action, correlationId) {\n        this.pendingAction = action;\n        this.pendingCorrelationId = correlationId;\n    }\n    reset() {\n        this.updatePending(null, null);\n        this.retryCount = 0;\n        this.established = false;\n        this.setSubscriptionState('none');\n    }\n    markAsFailed(message) {\n        this.rejectedWithError = message.error;\n        this.updatePending(null, null);\n        this.localObject.reportFailure(new syncerror_1.SyncError(`Failed to subscribe on service events: ${message.error.message}`, message.error.status, message.error.code));\n    }\n    complete(eventId) {\n        this.updatePending(null, null);\n        this.established = true;\n        this.localObject._advanceLastEventId(eventId);\n    }\n    setSubscriptionState(newState) {\n        this.localObject._setSubscriptionState(newState);\n    }\n}\n/**\n * @class Subscriptions\n * @classdesc A manager which, in batches of varying size, continuously persists the\n *      subscription intent of the caller to the Sync backend until it achieves a\n *      converged state.\n */\nclass Subscriptions {\n    /**\n     * @constructor\n     * Prepares a new Subscriptions manager object with zero subscribed or persisted subscriptions.\n     *\n     * @param {object} config may include a key 'backoffConfig', wherein any of the parameters\n     *      of Backoff.exponential (from npm 'backoff') are valid and will override the defaults.\n     *\n     * @param {Network} must be a viable running Sync Network object, useful for routing requests.\n     */\n    constructor(services) {\n        this.isConnected = false;\n        this.maxBatchSize = 100;\n        // If the server includes a `ttl_in_s` attribute in the poke response, subscriptionTtlTimer is started for that duration\n        // such that when it fires, it repokes the entire sync set (i.e., emulates a reconnect). Every reconnect resets the timer.\n        // After the timer has fired, the first poke request includes a `reason: ttl` attribute in the body.\n        this.subscriptionTtlTimer = null;\n        this.pendingPokeReason = null;\n        this.services = services;\n        this.subscriptions = new Map();\n        this.persisted = new Map();\n        this.latestPokeResponseArrivalTimestampByCorrelationId = new Map();\n        const defaultBackoffConfig = {\n            randomisationFactor: 0.2,\n            initialDelay: 100,\n            maxDelay: 2 * 60 * 1000\n        };\n        this.backoff = operation_retrier_1.Backoff.exponential(Object.assign(defaultBackoffConfig, this.services.config.backoffConfig));\n        // This block is triggered by #_persist. Every request is executed in a series of (ideally 1)\n        // backoff 'ready' event, at which point a new subscription set is calculated.\n        this.backoff.on('ready', () => {\n            let { action: action, subscriptions: subscriptionRequests } = this.getSubscriptionUpdateBatch();\n            if (action) {\n                this.applyNewSubscriptionUpdateBatch(action, subscriptionRequests);\n            }\n            else {\n                this.backoff.reset();\n                logger_1.default.debug('All subscriptions resolved.');\n            }\n        });\n    }\n    getSubscriptionUpdateBatch() {\n        function subtract(these, those, action, limit) {\n            let result = [];\n            for (let [thisKey, thisValue] of these) {\n                const otherValue = those.get(thisKey);\n                if (!otherValue && action !== thisValue.pendingAction && !thisValue.rejectedWithError) {\n                    result.push(thisValue);\n                    if (limit && result.length >= limit) {\n                        break;\n                    }\n                }\n            }\n            return result;\n        }\n        let listToAdd = subtract(this.subscriptions, this.persisted, 'establish', this.maxBatchSize);\n        if (listToAdd.length > 0) {\n            return { action: 'establish', subscriptions: listToAdd };\n        }\n        let listToRemove = subtract(this.persisted, this.subscriptions, 'cancel', this.maxBatchSize);\n        if (listToRemove.length > 0) {\n            return { action: 'cancel', subscriptions: listToRemove };\n        }\n        return { action: null, subscriptions: null };\n    }\n    persist() {\n        this.backoff.backoff();\n    }\n    async applyNewSubscriptionUpdateBatch(action, requests) {\n        if (!this.isConnected) {\n            logger_1.default.debug(`Twilsock connection (required for subscription) not ready; waiting`);\n            this.backoff.reset();\n            return;\n        }\n        // Keeping in mind that events may begin flowing _before_ we receive the response\n        requests = this.processLocalActions(action, requests);\n        const correlationId = new Date().getTime();\n        for (const subscribed of requests) {\n            this.recordActionAttemptOn(subscribed, action, correlationId);\n        }\n        let reason = this.pendingPokeReason;\n        this.pendingPokeReason = null;\n        // Send this batch to the service\n        try {\n            let response = await this.request(action, correlationId, reason, requests);\n            let newMaxBatchSize = response.body.max_batch_size;\n            if (!isNaN(parseInt(newMaxBatchSize)) && isFinite(newMaxBatchSize) && newMaxBatchSize > 0) {\n                this.maxBatchSize = newMaxBatchSize;\n            }\n            if (!this.subscriptionTtlTimer) {\n                let subscriptionTtlInS = response.body.ttl_in_s;\n                let isNumeric = !isNaN(parseFloat(subscriptionTtlInS)) && isFinite(subscriptionTtlInS);\n                let isValidTtl = isNumeric && subscriptionTtlInS > 0;\n                if (isValidTtl) {\n                    this.subscriptionTtlTimer = setTimeout(() => this.onSubscriptionTtlElapsed(), subscriptionTtlInS * 1000);\n                }\n            }\n            if (action === 'establish') {\n                const estimatedDeliveryInMs = response.body.estimated_delivery_in_ms;\n                let isNumeric = !isNaN(parseFloat(estimatedDeliveryInMs)) && isFinite(estimatedDeliveryInMs);\n                let isValidTimeout = isNumeric && estimatedDeliveryInMs > 0;\n                if (isValidTimeout) {\n                    setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), estimatedDeliveryInMs);\n                }\n                else {\n                    logger_1.default.error(`Invalid timeout: ${estimatedDeliveryInMs}`);\n                }\n                requests.filter(r => r.pendingCorrelationId === correlationId)\n                    .forEach(r => r.setSubscriptionState('response_in_flight'));\n            }\n            this.backoff.reset();\n        }\n        catch (e) {\n            for (const attemptedSubscription of requests) {\n                this.recordActionFailureOn(attemptedSubscription, action);\n            }\n            if (e instanceof twilsock_1.TransportUnavailableError) {\n                logger_1.default.debug(`Twilsock connection (required for subscription) not ready (c:${correlationId}); waiting`);\n                this.backoff.reset();\n            }\n            else {\n                logger_1.default.debug(`Failed an attempt to ${action} subscriptions (c:${correlationId}); retrying`, e);\n                this.persist();\n            }\n        }\n    }\n    verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests) {\n        const lastReceived = this.latestPokeResponseArrivalTimestampByCorrelationId.get(correlationId);\n        const silencePeriod = lastReceived ? (new Date().getTime() - lastReceived)\n            : estimatedDeliveryInMs;\n        if (silencePeriod >= estimatedDeliveryInMs) {\n            // If we haven't received _any_ responses from that poke request for the duration of estimated_delivery_in_ms, poke again\n            requests\n                .filter(r => r.pendingCorrelationId === correlationId)\n                .forEach(r => {\n                r.updatePending(null, null);\n                r.retryCount++;\n                this.persisted.delete(r.sid);\n            });\n            this.persist();\n            this.latestPokeResponseArrivalTimestampByCorrelationId.delete(correlationId);\n        }\n        else {\n            // Otherwise, the poke responses are probably in transit and we should wait for them\n            const timeoutExtension = estimatedDeliveryInMs - silencePeriod;\n            setTimeout(() => this.verifyPokeDelivery(correlationId, estimatedDeliveryInMs, requests), timeoutExtension);\n        }\n    }\n    processLocalActions(action, requests) {\n        if (action === 'cancel') {\n            return requests.filter(request => !request.rejectedWithError);\n        }\n        return requests;\n    }\n    recordActionAttemptOn(attemptedSubscription, action, correlationId) {\n        attemptedSubscription.setSubscriptionState('request_in_flight');\n        if (action === 'establish') {\n            this.persisted.set(attemptedSubscription.sid, attemptedSubscription);\n            attemptedSubscription.updatePending(action, correlationId);\n        }\n        else { // cancel\n            let persistedSubscription = this.persisted.get(attemptedSubscription.sid);\n            if (persistedSubscription) {\n                persistedSubscription.updatePending(action, correlationId);\n            }\n        }\n    }\n    recordActionFailureOn(attemptedSubscription, action) {\n        attemptedSubscription.setSubscriptionState('none');\n        attemptedSubscription.updatePending(null, null);\n        if (action === 'establish') {\n            this.persisted.delete(attemptedSubscription.sid);\n        }\n    }\n    request(action, correlationId, reason, objects) {\n        let requests = objects.map(object => ({\n            object_sid: object.sid,\n            object_type: object.type,\n            last_event_id: action === 'establish' ? object.lastEventId : undefined,\n            index_name: action === 'establish' ? object.indexName : undefined,\n            query_string: action === 'establish' ? object.queryString : undefined,\n        }));\n        let retriedRequests = objects.filter(a => a.retryCount > 0).length;\n        logger_1.default.debug(`Attempting '${action}' request (c:${correlationId}):`, requests);\n        const requestBody = {\n            event_protocol_version: 3,\n            action,\n            correlation_id: correlationId,\n            retried_requests: retriedRequests,\n            ttl_in_s: -1,\n            requests\n        };\n        if (reason === 'ttl') {\n            requestBody.reason = reason;\n        }\n        return this.services.network.post(this.services.config.subscriptionsUri, requestBody);\n    }\n    /**\n     * Establishes intent to be subscribed to this entity. That subscription will be effected\n     * asynchronously.\n     * If subscription to the given sid already exists, it will be overwritten.\n     *\n     * @param {String} sid should be a well-formed SID, uniquely identifying a single instance of a Sync entity.\n     * @param {Object} entity should represent the (singular) local representation of this entity.\n     *      Incoming events and modifications to the entity will be directed at the _update() function\n     *      of this provided reference.\n     *\n     * @return undefined\n     */\n    add(sid, entity) {\n        logger_1.default.debug(`Establishing intent to subscribe to ${sid}`);\n        const existingSubscription = this.subscriptions.get(sid);\n        if (existingSubscription && entity && existingSubscription.lastEventId === entity.lastEventId) {\n            // If last event id is the same as before - we're fine\n            return;\n        }\n        this.persisted.delete(sid);\n        this.subscriptions.set(sid, new SubscribedEntity(entity));\n        this.persist();\n    }\n    /**\n     * Establishes the caller's intent to no longer be subscribed to this entity. Following this\n     * call, no further events shall be routed to the local representation of the entity, even\n     * though a server-side subscription may take more time to actually terminate.\n     *\n     * @param {string} sid should be any well-formed SID, uniquely identifying a Sync entity.\n     *      This call only has meaningful effect if that entity is subscribed at the\n     *      time of call. Otherwise does nothing.\n     *\n     * @return undefined\n     */\n    remove(sid) {\n        logger_1.default.debug(`Establishing intent to unsubscribe from ${sid}`);\n        const removed = this.subscriptions.delete(sid);\n        if (removed) {\n            this.persist();\n        }\n    }\n    /**\n     * The point of ingestion for remote incoming messages (e.g. new data was written to a map\n     * to which we are subscribed).\n     *\n     * @param {object} message is the full, unaltered body of the incoming notification.\n     *\n     * @return undefined\n     */\n    acceptMessage(message, isStrictlyOrdered) {\n        logger_1.default.trace('Subscriptions received', message);\n        if (message.correlation_id) {\n            this.latestPokeResponseArrivalTimestampByCorrelationId.set(message.correlation_id, new Date().getTime());\n        }\n        let event_type;\n        switch (message.event_type) {\n            case 'subscription_established':\n                this.applySubscriptionEstablishedMessage(message.event, message.correlation_id);\n                break;\n            case 'subscription_canceled':\n                this.applySubscriptionCancelledMessage(message.event, message.correlation_id);\n                break;\n            case 'subscription_failed':\n                this.applySubscriptionFailedMessage(message.event, message.correlation_id);\n                break;\n            case (event_type = message.event_type.match(/^(?:map|list|document|stream|live_query)_/) || {}).input:\n                {\n                    let typedSid;\n                    switch (event_type[0]) {\n                        case 'map_':\n                            typedSid = message.event.map_sid;\n                            break;\n                        case 'list_':\n                            typedSid = message.event.list_sid;\n                            break;\n                        case 'document_':\n                            typedSid = message.event.document_sid;\n                            break;\n                        case 'stream_':\n                            typedSid = message.event.stream_sid;\n                            break;\n                        case 'live_query_':\n                            typedSid = message.event.query_id;\n                            // hack to mark replay events for LiveQuery as strictly ordered, due to lack of special type of notification for them\n                            // (normally only replay events would have `twilio.sync.event` type, but LiveQuery non-replay events were also assigned\n                            // to this type in legacy clients, which we have to support now; hence a hack)\n                            isStrictlyOrdered = false; // explicitly override it due to code in router.ts does not know about LiveQueries\n                            if (message.strictly_ordered === true) {\n                                isStrictlyOrdered = true;\n                            }\n                            break;\n                        default:\n                            typedSid = undefined;\n                    }\n                    this.applyEventToSubscribedEntity(typedSid, message, isStrictlyOrdered);\n                }\n                break;\n            default:\n                logger_1.default.debug(`Dropping unknown message type ${message.event_type}`);\n                break;\n        }\n    }\n    applySubscriptionEstablishedMessage(message, correlationId) {\n        const sid = message.object_sid;\n        let subscriptionIntent = this.persisted.get(message.object_sid);\n        if (subscriptionIntent && subscriptionIntent.pendingCorrelationId === correlationId) {\n            if (message.replay_status === 'interrupted') {\n                logger_1.default.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) interrupted; continuing eagerly.`);\n                subscriptionIntent.updatePending(null, null);\n                this.persisted.delete(subscriptionIntent.sid);\n                this.backoff.reset();\n            }\n            else if (message.replay_status === 'completed') {\n                logger_1.default.debug(`Event Replay for subscription to ${sid} (c:${correlationId}) completed. Subscription is ready.`);\n                subscriptionIntent.complete(message.last_event_id);\n                this.persisted.set(message.object_sid, subscriptionIntent);\n                subscriptionIntent.setSubscriptionState('established');\n                this.backoff.reset();\n            }\n        }\n        else {\n            logger_1.default.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);\n        }\n        this.persist();\n    }\n    applySubscriptionCancelledMessage(message, correlationId) {\n        let persistedSubscription = this.persisted.get(message.object_sid);\n        if (persistedSubscription && persistedSubscription.pendingCorrelationId === correlationId) {\n            persistedSubscription.updatePending(null, null);\n            persistedSubscription.setSubscriptionState('none');\n            this.persisted.delete(message.object_sid);\n        }\n        else {\n            logger_1.default.debug(`Late message for ${message.object_sid} (c:${correlationId}) dropped.`);\n        }\n        this.persist();\n    }\n    applySubscriptionFailedMessage(message, correlationId) {\n        const sid = message.object_sid;\n        let subscriptionIntent = this.subscriptions.get(sid);\n        let subscription = this.persisted.get(sid);\n        if (subscriptionIntent && subscription) {\n            if (subscription.pendingCorrelationId === correlationId) {\n                logger_1.default.error(`Failed to subscribe on ${subscription.sid}`, message.error);\n                subscription.markAsFailed(message);\n                subscription.setSubscriptionState('none');\n            }\n        }\n        else if (!subscriptionIntent && subscription) {\n            this.persisted.delete(sid);\n            subscription.setSubscriptionState('none');\n        }\n        this.persist();\n    }\n    applyEventToSubscribedEntity(sid, message, isStrictlyOrdered) {\n        if (!sid) {\n            return;\n        }\n        // Looking for subscription descriptor to check if poke has been completed\n        isStrictlyOrdered = isStrictlyOrdered || (() => {\n            let subscription = this.persisted.get(sid);\n            return subscription && subscription.isEstablished;\n        })();\n        // Still searching for subscriptionIntents. User could remove subscription already\n        let subscriptionIntent = this.subscriptions.get(sid);\n        if (subscriptionIntent) {\n            message.event.type = message.event_type;\n            subscriptionIntent.update(message.event, isStrictlyOrdered);\n        }\n        else {\n            logger_1.default.debug(`Message dropped for SID '${sid}', for which there is no subscription.`);\n        }\n    }\n    onConnectionStateChanged(isConnected) {\n        this.isConnected = isConnected;\n        if (isConnected) {\n            this.poke('reconnect');\n        }\n    }\n    onSubscriptionTtlElapsed() {\n        if (this.isConnected) {\n            this.poke('ttl');\n        }\n    }\n    /**\n     * Prompts a playback of any missed changes made to any subscribed object. This method\n     * should be invoked whenever the connectivity layer has experienced cross-cutting\n     * delivery failures that would affect the entire local sync set. Any tangible result\n     * of this operation will result in calls to the _update() function of subscribed\n     * Sync entities.\n     */\n    poke(reason) {\n        logger_1.default.debug(`Triggering event replay for all subscriptions, reason=${reason}`);\n        this.pendingPokeReason = reason;\n        if (this.subscriptionTtlTimer) {\n            clearTimeout(this.subscriptionTtlTimer);\n            this.subscriptionTtlTimer = null;\n        }\n        let failedSubscriptions = [];\n        for (let it of this.persisted.values()) {\n            it.reset();\n            if (it.rejectedWithError) {\n                failedSubscriptions.push(it);\n            }\n        }\n        this.persisted.clear();\n        for (let it of failedSubscriptions) {\n            this.persisted.set(it.sid, it);\n        }\n        this.persist();\n    }\n    /**\n     * Stops all communication, clears any subscription intent, and returns.\n     */\n    shutdown() {\n        this.backoff.reset();\n        this.subscriptions.clear();\n    }\n}\nexports.Subscriptions = Subscriptions;\n"]},"metadata":{},"sourceType":"script"}