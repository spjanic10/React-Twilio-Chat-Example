{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTests = exports.createPatch = exports.applyPatch = void 0;\n\nvar pointer_1 = require(\"./pointer\");\n\nvar patch_1 = require(\"./patch\");\n\nvar diff_1 = require(\"./diff\");\n/**\nApply a 'application/json-patch+json'-type patch to an object.\n\n`patch` *must* be an array of operations.\n\n> Operation objects MUST have exactly one \"op\" member, whose value\n> indicates the operation to perform.  Its value MUST be one of \"add\",\n> \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are\n> errors.\n\nThis method mutates the target object in-place.\n\n@returns list of results, one for each operation: `null` indicated success,\n         otherwise, the result will be an instance of one of the Error classes:\n         MissingError, InvalidOperationError, or TestError.\n*/\n\n\nfunction applyPatch(object, patch) {\n  return patch.map(function (operation) {\n    return patch_1.apply(object, operation);\n  });\n}\n\nexports.applyPatch = applyPatch;\n\nfunction wrapVoidableDiff(diff) {\n  function wrappedDiff(input, output, ptr) {\n    var custom_patch = diff(input, output, ptr); // ensure an array is always returned\n\n    return Array.isArray(custom_patch) ? custom_patch : diff_1.diffAny(input, output, ptr, wrappedDiff);\n  }\n\n  return wrappedDiff;\n}\n/**\nProduce a 'application/json-patch+json'-type patch to get from one object to\nanother.\n\nThis does not alter `input` or `output` unless they have a property getter with\nside-effects (which is not a good idea anyway).\n\n`diff` is called on each pair of comparable non-primitive nodes in the\n`input`/`output` object trees, producing nested patches. Return `undefined`\nto fall back to default behaviour.\n\nReturns list of operations to perform on `input` to produce `output`.\n*/\n\n\nfunction createPatch(input, output, diff) {\n  var ptr = new pointer_1.Pointer(); // a new Pointer gets a default path of [''] if not specified\n\n  return (diff ? wrapVoidableDiff(diff) : diff_1.diffAny)(input, output, ptr);\n}\n\nexports.createPatch = createPatch;\n/**\nCreate a test operation based on `input`'s current evaluation of the JSON\nPointer `path`; if such a pointer cannot be resolved, returns undefined.\n*/\n\nfunction createTest(input, path) {\n  var endpoint = pointer_1.Pointer.fromJSON(path).evaluate(input);\n\n  if (endpoint !== undefined) {\n    return {\n      op: 'test',\n      path: path,\n      value: endpoint.value\n    };\n  }\n}\n/**\nProduce an 'application/json-patch+json'-type list of tests, to verify that\nexisting values in an object are identical to the those captured at some\ncheckpoint (whenever this function is called).\n\nThis does not alter `input` or `output` unless they have a property getter with\nside-effects (which is not a good idea anyway).\n\nReturns list of test operations.\n*/\n\n\nfunction createTests(input, patch) {\n  var tests = new Array();\n  patch.filter(diff_1.isDestructive).forEach(function (operation) {\n    var pathTest = createTest(input, operation.path);\n    if (pathTest) tests.push(pathTest);\n\n    if ('from' in operation) {\n      var fromTest = createTest(input, operation.from);\n      if (fromTest) tests.push(fromTest);\n    }\n  });\n  return tests;\n}\n\nexports.createTests = createTests;","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/rfc6902/index.js"],"names":["Object","defineProperty","exports","value","createTests","createPatch","applyPatch","pointer_1","require","patch_1","diff_1","object","patch","map","operation","apply","wrapVoidableDiff","diff","wrappedDiff","input","output","ptr","custom_patch","Array","isArray","diffAny","Pointer","createTest","path","endpoint","fromJSON","evaluate","undefined","op","tests","filter","isDestructive","forEach","pathTest","push","fromTest","from"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createTests = exports.createPatch = exports.applyPatch = void 0;\nvar pointer_1 = require(\"./pointer\");\nvar patch_1 = require(\"./patch\");\nvar diff_1 = require(\"./diff\");\n/**\nApply a 'application/json-patch+json'-type patch to an object.\n\n`patch` *must* be an array of operations.\n\n> Operation objects MUST have exactly one \"op\" member, whose value\n> indicates the operation to perform.  Its value MUST be one of \"add\",\n> \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are\n> errors.\n\nThis method mutates the target object in-place.\n\n@returns list of results, one for each operation: `null` indicated success,\n         otherwise, the result will be an instance of one of the Error classes:\n         MissingError, InvalidOperationError, or TestError.\n*/\nfunction applyPatch(object, patch) {\n    return patch.map(function (operation) { return patch_1.apply(object, operation); });\n}\nexports.applyPatch = applyPatch;\nfunction wrapVoidableDiff(diff) {\n    function wrappedDiff(input, output, ptr) {\n        var custom_patch = diff(input, output, ptr);\n        // ensure an array is always returned\n        return Array.isArray(custom_patch) ? custom_patch : diff_1.diffAny(input, output, ptr, wrappedDiff);\n    }\n    return wrappedDiff;\n}\n/**\nProduce a 'application/json-patch+json'-type patch to get from one object to\nanother.\n\nThis does not alter `input` or `output` unless they have a property getter with\nside-effects (which is not a good idea anyway).\n\n`diff` is called on each pair of comparable non-primitive nodes in the\n`input`/`output` object trees, producing nested patches. Return `undefined`\nto fall back to default behaviour.\n\nReturns list of operations to perform on `input` to produce `output`.\n*/\nfunction createPatch(input, output, diff) {\n    var ptr = new pointer_1.Pointer();\n    // a new Pointer gets a default path of [''] if not specified\n    return (diff ? wrapVoidableDiff(diff) : diff_1.diffAny)(input, output, ptr);\n}\nexports.createPatch = createPatch;\n/**\nCreate a test operation based on `input`'s current evaluation of the JSON\nPointer `path`; if such a pointer cannot be resolved, returns undefined.\n*/\nfunction createTest(input, path) {\n    var endpoint = pointer_1.Pointer.fromJSON(path).evaluate(input);\n    if (endpoint !== undefined) {\n        return { op: 'test', path: path, value: endpoint.value };\n    }\n}\n/**\nProduce an 'application/json-patch+json'-type list of tests, to verify that\nexisting values in an object are identical to the those captured at some\ncheckpoint (whenever this function is called).\n\nThis does not alter `input` or `output` unless they have a property getter with\nside-effects (which is not a good idea anyway).\n\nReturns list of test operations.\n*/\nfunction createTests(input, patch) {\n    var tests = new Array();\n    patch.filter(diff_1.isDestructive).forEach(function (operation) {\n        var pathTest = createTest(input, operation.path);\n        if (pathTest)\n            tests.push(pathTest);\n        if ('from' in operation) {\n            var fromTest = createTest(input, operation.from);\n            if (fromTest)\n                tests.push(fromTest);\n        }\n    });\n    return tests;\n}\nexports.createTests = createTests;\n"]},"metadata":{},"sourceType":"script"}