{"ast":null,"code":"var _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n// Generated by CoffeeScript 2.4.1\n(function () {\n  var NodeType,\n      WriterState,\n      XMLAttribute,\n      XMLCData,\n      XMLComment,\n      XMLDTDAttList,\n      XMLDTDElement,\n      XMLDTDEntity,\n      XMLDTDNotation,\n      XMLDeclaration,\n      XMLDocType,\n      XMLDocument,\n      XMLDocumentCB,\n      XMLElement,\n      XMLProcessingInstruction,\n      XMLRaw,\n      XMLStringWriter,\n      XMLStringifier,\n      XMLText,\n      getValue,\n      isFunction,\n      isObject,\n      isPlainObject,\n      hasProp = {}.hasOwnProperty;\n\n  var _require = require('./Utility');\n\n  isObject = _require.isObject;\n  isFunction = _require.isFunction;\n  isPlainObject = _require.isPlainObject;\n  getValue = _require.getValue;\n  NodeType = require('./NodeType');\n  XMLDocument = require('./XMLDocument');\n  XMLElement = require('./XMLElement');\n  XMLCData = require('./XMLCData');\n  XMLComment = require('./XMLComment');\n  XMLRaw = require('./XMLRaw');\n  XMLText = require('./XMLText');\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n  XMLDeclaration = require('./XMLDeclaration');\n  XMLDocType = require('./XMLDocType');\n  XMLDTDAttList = require('./XMLDTDAttList');\n  XMLDTDEntity = require('./XMLDTDEntity');\n  XMLDTDElement = require('./XMLDTDElement');\n  XMLDTDNotation = require('./XMLDTDNotation');\n  XMLAttribute = require('./XMLAttribute');\n  XMLStringifier = require('./XMLStringifier');\n  XMLStringWriter = require('./XMLStringWriter');\n  WriterState = require('./WriterState'); // Represents an XML builder\n\n  module.exports = XMLDocumentCB = /*#__PURE__*/function () {\n    \"use strict\";\n\n    // Initializes a new instance of `XMLDocumentCB`\n    // `options.keepNullNodes` whether nodes with null values will be kept\n    //     or ignored: true or false\n    // `options.keepNullAttributes` whether attributes with null values will be\n    //     kept or ignored: true or false\n    // `options.ignoreDecorators` whether decorator strings will be ignored when\n    //     converting JS objects: true or false\n    // `options.separateArrayItems` whether array items are created as separate\n    //     nodes when passed as an object value: true or false\n    // `options.noDoubleEncoding` whether existing html entities are encoded:\n    //     true or false\n    // `options.stringify` a set of functions to use for converting values to\n    //     strings\n    // `options.writer` the default XML writer to use for converting nodes to\n    //     string. If the default writer is not set, the built-in XMLStringWriter\n    //     will be used instead.\n    // `onData` the function to be called when a new chunk of XML is output. The\n    //          string containing the XML chunk is passed to `onData` as its first\n    //          argument, and the current indentation level as its second argument.\n    // `onEnd`  the function to be called when the XML document is completed with\n    //          `end`. `onEnd` does not receive any arguments.\n    function XMLDocumentCB(options, onData, onEnd) {\n      _classCallCheck(this, XMLDocumentCB);\n\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n\n      this.onDataCallback = onData || function () {};\n\n      this.onEndCallback = onEnd || function () {};\n\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    } // Creates a child element node from the given XMLNode\n    // `node` the child node\n\n\n    _createClass(XMLDocumentCB, [{\n      key: \"createChildNode\",\n      value: function createChildNode(node) {\n        var att, attName, attributes, child, i, len, ref, ref1;\n\n        switch (node.type) {\n          case NodeType.CData:\n            this.cdata(node.value);\n            break;\n\n          case NodeType.Comment:\n            this.comment(node.value);\n            break;\n\n          case NodeType.Element:\n            attributes = {};\n            ref = node.attribs;\n\n            for (attName in ref) {\n              if (!hasProp.call(ref, attName)) continue;\n              att = ref[attName];\n              attributes[attName] = att.value;\n            }\n\n            this.node(node.name, attributes);\n            break;\n\n          case NodeType.Dummy:\n            this.dummy();\n            break;\n\n          case NodeType.Raw:\n            this.raw(node.value);\n            break;\n\n          case NodeType.Text:\n            this.text(node.value);\n            break;\n\n          case NodeType.ProcessingInstruction:\n            this.instruction(node.target, node.value);\n            break;\n\n          default:\n            throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n        }\n\n        ref1 = node.children; // write child nodes recursively\n\n        for (i = 0, len = ref1.length; i < len; i++) {\n          child = ref1[i];\n          this.createChildNode(child);\n\n          if (child.type === NodeType.Element) {\n            this.up();\n          }\n        }\n\n        return this;\n      } // Creates a dummy node\n\n    }, {\n      key: \"dummy\",\n      value: function dummy() {\n        // no-op, just return this\n        return this;\n      } // Creates a node\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n    }, {\n      key: \"node\",\n      value: function node(name, attributes, text) {\n        if (name == null) {\n          throw new Error(\"Missing node name.\");\n        }\n\n        if (this.root && this.currentLevel === -1) {\n          throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n        }\n\n        this.openCurrent();\n        name = getValue(name);\n\n        if (attributes == null) {\n          attributes = {};\n        }\n\n        attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n        if (!isObject(attributes)) {\n          var _ref = [attributes, text];\n          text = _ref[0];\n          attributes = _ref[1];\n        }\n\n        this.currentNode = new XMLElement(this, name, attributes);\n        this.currentNode.children = false;\n        this.currentLevel++;\n        this.openTags[this.currentLevel] = this.currentNode;\n\n        if (text != null) {\n          this.text(text);\n        }\n\n        return this;\n      } // Creates a child element node or an element type declaration when called\n      // inside the DTD\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n\n    }, {\n      key: \"element\",\n      value: function element(name, attributes, text) {\n        var child, i, len, oldValidationFlag, ref, root;\n\n        if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n          this.dtdElement.apply(this, arguments);\n        } else {\n          if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n            oldValidationFlag = this.options.noValidation;\n            this.options.noValidation = true;\n            root = new XMLDocument(this.options).element('TEMP_ROOT');\n            root.element(name);\n            this.options.noValidation = oldValidationFlag;\n            ref = root.children;\n\n            for (i = 0, len = ref.length; i < len; i++) {\n              child = ref[i];\n              this.createChildNode(child);\n\n              if (child.type === NodeType.Element) {\n                this.up();\n              }\n            }\n          } else {\n            this.node(name, attributes, text);\n          }\n        }\n\n        return this;\n      } // Adds or modifies an attribute\n      // `name` attribute name\n      // `value` attribute value\n\n    }, {\n      key: \"attribute\",\n      value: function attribute(name, value) {\n        var attName, attValue;\n\n        if (!this.currentNode || this.currentNode.children) {\n          throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n        }\n\n        if (name != null) {\n          name = getValue(name);\n        }\n\n        if (isObject(name)) {\n          // expand if object\n          for (attName in name) {\n            if (!hasProp.call(name, attName)) continue;\n            attValue = name[attName];\n            this.attribute(attName, attValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n\n          if (this.options.keepNullAttributes && value == null) {\n            this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n          } else if (value != null) {\n            this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n          }\n        }\n\n        return this;\n      } // Creates a text node\n      // `value` element text\n\n    }, {\n      key: \"text\",\n      value: function text(value) {\n        var node;\n        this.openCurrent();\n        node = new XMLText(this, value);\n        this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates a CDATA node\n      // `value` element text without CDATA delimiters\n\n    }, {\n      key: \"cdata\",\n      value: function cdata(value) {\n        var node;\n        this.openCurrent();\n        node = new XMLCData(this, value);\n        this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates a comment node\n      // `value` comment text\n\n    }, {\n      key: \"comment\",\n      value: function comment(value) {\n        var node;\n        this.openCurrent();\n        node = new XMLComment(this, value);\n        this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Adds unescaped raw text\n      // `value` text\n\n    }, {\n      key: \"raw\",\n      value: function raw(value) {\n        var node;\n        this.openCurrent();\n        node = new XMLRaw(this, value);\n        this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Adds a processing instruction\n      // `target` instruction target\n      // `value` instruction value\n\n    }, {\n      key: \"instruction\",\n      value: function instruction(target, value) {\n        var i, insTarget, insValue, len, node;\n        this.openCurrent();\n\n        if (target != null) {\n          target = getValue(target);\n        }\n\n        if (value != null) {\n          value = getValue(value);\n        }\n\n        if (Array.isArray(target)) {\n          // expand if array\n          for (i = 0, len = target.length; i < len; i++) {\n            insTarget = target[i];\n            this.instruction(insTarget);\n          }\n        } else if (isObject(target)) {\n          // expand if object\n          for (insTarget in target) {\n            if (!hasProp.call(target, insTarget)) continue;\n            insValue = target[insTarget];\n            this.instruction(insTarget, insValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n\n          node = new XMLProcessingInstruction(this, target, value);\n          this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        }\n\n        return this;\n      } // Creates the xml declaration\n      // `version` A version number string, e.g. 1.0\n      // `encoding` Encoding declaration, e.g. UTF-8\n      // `standalone` standalone document declaration: true or false\n\n    }, {\n      key: \"declaration\",\n      value: function declaration(version, encoding, standalone) {\n        var node;\n        this.openCurrent();\n\n        if (this.documentStarted) {\n          throw new Error(\"declaration() must be the first node.\");\n        }\n\n        node = new XMLDeclaration(this, version, encoding, standalone);\n        this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates the document type declaration\n      // `root`  the name of the root node\n      // `pubID` the public identifier of the external subset\n      // `sysID` the system identifier of the external subset\n\n    }, {\n      key: \"doctype\",\n      value: function doctype(root, pubID, sysID) {\n        this.openCurrent();\n\n        if (root == null) {\n          throw new Error(\"Missing root node name.\");\n        }\n\n        if (this.root) {\n          throw new Error(\"dtd() must come before the root node.\");\n        }\n\n        this.currentNode = new XMLDocType(this, pubID, sysID);\n        this.currentNode.rootNodeName = root;\n        this.currentNode.children = false;\n        this.currentLevel++;\n        this.openTags[this.currentLevel] = this.currentNode;\n        return this;\n      } // Creates an element type declaration\n      // `name` element name\n      // `value` element content (defaults to #PCDATA)\n\n    }, {\n      key: \"dtdElement\",\n      value: function dtdElement(name, value) {\n        var node;\n        this.openCurrent();\n        node = new XMLDTDElement(this, name, value);\n        this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates an attribute declaration\n      // `elementName` the name of the element containing this attribute\n      // `attributeName` attribute name\n      // `attributeType` type of the attribute (defaults to CDATA)\n      // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or\n      //                    #DEFAULT) (defaults to #IMPLIED)\n      // `defaultValue` default value of the attribute\n      //                (only used for #FIXED or #DEFAULT)\n\n    }, {\n      key: \"attList\",\n      value: function attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n        var node;\n        this.openCurrent();\n        node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n        this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates a general entity declaration\n      // `name` the name of the entity\n      // `value` internal entity value or an object with external entity details\n      // `value.pubID` public identifier\n      // `value.sysID` system identifier\n      // `value.nData` notation declaration\n\n    }, {\n      key: \"entity\",\n      value: function entity(name, value) {\n        var node;\n        this.openCurrent();\n        node = new XMLDTDEntity(this, false, name, value);\n        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates a parameter entity declaration\n      // `name` the name of the entity\n      // `value` internal entity value or an object with external entity details\n      // `value.pubID` public identifier\n      // `value.sysID` system identifier\n\n    }, {\n      key: \"pEntity\",\n      value: function pEntity(name, value) {\n        var node;\n        this.openCurrent();\n        node = new XMLDTDEntity(this, true, name, value);\n        this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Creates a NOTATION declaration\n      // `name` the name of the notation\n      // `value` an object with external entity details\n      // `value.pubID` public identifier\n      // `value.sysID` system identifier\n\n    }, {\n      key: \"notation\",\n      value: function notation(name, value) {\n        var node;\n        this.openCurrent();\n        node = new XMLDTDNotation(this, name, value);\n        this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n        return this;\n      } // Gets the parent node\n\n    }, {\n      key: \"up\",\n      value: function up() {\n        if (this.currentLevel < 0) {\n          throw new Error(\"The document node has no parent.\");\n        }\n\n        if (this.currentNode) {\n          if (this.currentNode.children) {\n            this.closeNode(this.currentNode);\n          } else {\n            this.openNode(this.currentNode);\n          }\n\n          this.currentNode = null;\n        } else {\n          this.closeNode(this.openTags[this.currentLevel]);\n        }\n\n        delete this.openTags[this.currentLevel];\n        this.currentLevel--;\n        return this;\n      } // Ends the document\n\n    }, {\n      key: \"end\",\n      value: function end() {\n        while (this.currentLevel >= 0) {\n          this.up();\n        }\n\n        return this.onEnd();\n      } // Opens the current parent node\n\n    }, {\n      key: \"openCurrent\",\n      value: function openCurrent() {\n        if (this.currentNode) {\n          this.currentNode.children = true;\n          return this.openNode(this.currentNode);\n        }\n      } // Writes the opening tag of the current node or the entire node if it has\n      // no child nodes\n\n    }, {\n      key: \"openNode\",\n      value: function openNode(node) {\n        var att, chunk, name, ref;\n\n        if (!node.isOpen) {\n          if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n            this.root = node;\n          }\n\n          chunk = '';\n\n          if (node.type === NodeType.Element) {\n            this.writerOptions.state = WriterState.OpenTag;\n            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n            ref = node.attribs;\n\n            for (name in ref) {\n              if (!hasProp.call(ref, name)) continue;\n              att = ref[name];\n              chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n            }\n\n            chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n            this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType\n          } else {\n            this.writerOptions.state = WriterState.OpenTag;\n            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName; // external identifier\n\n            if (node.pubID && node.sysID) {\n              chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n            } else if (node.sysID) {\n              chunk += ' SYSTEM \"' + node.sysID + '\"';\n            } // internal subset\n\n\n            if (node.children) {\n              chunk += ' [';\n              this.writerOptions.state = WriterState.InsideTag;\n            } else {\n              this.writerOptions.state = WriterState.CloseTag;\n              chunk += '>';\n            }\n\n            chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n          }\n\n          this.onData(chunk, this.currentLevel);\n          return node.isOpen = true;\n        }\n      } // Writes the closing tag of the current node\n\n    }, {\n      key: \"closeNode\",\n      value: function closeNode(node) {\n        var chunk;\n\n        if (!node.isClosed) {\n          chunk = '';\n          this.writerOptions.state = WriterState.CloseTag;\n\n          if (node.type === NodeType.Element) {\n            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel); // if node.type is NodeType.DocType\n          } else {\n            chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          }\n\n          this.writerOptions.state = WriterState.None;\n          this.onData(chunk, this.currentLevel);\n          return node.isClosed = true;\n        }\n      } // Called when a new chunk of XML is output\n      // `chunk` a string containing the XML chunk\n      // `level` current indentation level\n\n    }, {\n      key: \"onData\",\n      value: function onData(chunk, level) {\n        this.documentStarted = true;\n        return this.onDataCallback(chunk, level + 1);\n      } // Called when the XML document is completed\n\n    }, {\n      key: \"onEnd\",\n      value: function onEnd() {\n        this.documentCompleted = true;\n        return this.onEndCallback();\n      } // Returns debug string\n\n    }, {\n      key: \"debugInfo\",\n      value: function debugInfo(name) {\n        if (name == null) {\n          return \"\";\n        } else {\n          return \"node: <\" + name + \">\";\n        }\n      } // Node aliases\n\n    }, {\n      key: \"ele\",\n      value: function ele() {\n        return this.element.apply(this, arguments);\n      }\n    }, {\n      key: \"nod\",\n      value: function nod(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n    }, {\n      key: \"txt\",\n      value: function txt(value) {\n        return this.text(value);\n      }\n    }, {\n      key: \"dat\",\n      value: function dat(value) {\n        return this.cdata(value);\n      }\n    }, {\n      key: \"com\",\n      value: function com(value) {\n        return this.comment(value);\n      }\n    }, {\n      key: \"ins\",\n      value: function ins(target, value) {\n        return this.instruction(target, value);\n      }\n    }, {\n      key: \"dec\",\n      value: function dec(version, encoding, standalone) {\n        return this.declaration(version, encoding, standalone);\n      }\n    }, {\n      key: \"dtd\",\n      value: function dtd(root, pubID, sysID) {\n        return this.doctype(root, pubID, sysID);\n      }\n    }, {\n      key: \"e\",\n      value: function e(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n    }, {\n      key: \"n\",\n      value: function n(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n    }, {\n      key: \"t\",\n      value: function t(value) {\n        return this.text(value);\n      }\n    }, {\n      key: \"d\",\n      value: function d(value) {\n        return this.cdata(value);\n      }\n    }, {\n      key: \"c\",\n      value: function c(value) {\n        return this.comment(value);\n      }\n    }, {\n      key: \"r\",\n      value: function r(value) {\n        return this.raw(value);\n      }\n    }, {\n      key: \"i\",\n      value: function i(target, value) {\n        return this.instruction(target, value);\n      } // Attribute aliases\n\n    }, {\n      key: \"att\",\n      value: function att() {\n        if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n          return this.attList.apply(this, arguments);\n        } else {\n          return this.attribute.apply(this, arguments);\n        }\n      }\n    }, {\n      key: \"a\",\n      value: function a() {\n        if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n          return this.attList.apply(this, arguments);\n        } else {\n          return this.attribute.apply(this, arguments);\n        }\n      } // DTD aliases\n      // att() and ele() are defined above\n\n    }, {\n      key: \"ent\",\n      value: function ent(name, value) {\n        return this.entity(name, value);\n      }\n    }, {\n      key: \"pent\",\n      value: function pent(name, value) {\n        return this.pEntity(name, value);\n      }\n    }, {\n      key: \"not\",\n      value: function not(name, value) {\n        return this.notation(name, value);\n      }\n    }]);\n\n    return XMLDocumentCB;\n  }();\n}).call(this);","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/xmlbuilder/lib/XMLDocumentCB.js"],"names":["NodeType","WriterState","XMLAttribute","XMLCData","XMLComment","XMLDTDAttList","XMLDTDElement","XMLDTDEntity","XMLDTDNotation","XMLDeclaration","XMLDocType","XMLDocument","XMLDocumentCB","XMLElement","XMLProcessingInstruction","XMLRaw","XMLStringWriter","XMLStringifier","XMLText","getValue","isFunction","isObject","isPlainObject","hasProp","hasOwnProperty","require","module","exports","options","onData","onEnd","writerOptions","name","type","Document","writer","filterOptions","stringify","onDataCallback","onEndCallback","currentNode","currentLevel","openTags","documentStarted","documentCompleted","root","node","att","attName","attributes","child","i","len","ref","ref1","CData","cdata","value","Comment","comment","Element","attribs","call","Dummy","dummy","Raw","raw","Text","text","ProcessingInstruction","instruction","target","Error","constructor","children","length","createChildNode","up","debugInfo","openCurrent","oldValidationFlag","DocType","dtdElement","arguments","Array","isArray","noValidation","element","attValue","attribute","apply","keepNullAttributes","insTarget","insValue","processingInstruction","version","encoding","standalone","declaration","pubID","sysID","rootNodeName","elementName","attributeName","attributeType","defaultValueType","defaultValue","dtdAttList","dtdEntity","dtdNotation","closeNode","openNode","chunk","isOpen","state","OpenTag","indent","endline","InsideTag","CloseTag","isClosed","None","level","doctype","attList","entity","pEntity","notation"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject,\n    hasProp = {}.hasOwnProperty;\n\n  ({isObject, isFunction, isPlainObject, getValue} = require('./Utility'));\n\n  NodeType = require('./NodeType');\n\n  XMLDocument = require('./XMLDocument');\n\n  XMLElement = require('./XMLElement');\n\n  XMLCData = require('./XMLCData');\n\n  XMLComment = require('./XMLComment');\n\n  XMLRaw = require('./XMLRaw');\n\n  XMLText = require('./XMLText');\n\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n\n  XMLDeclaration = require('./XMLDeclaration');\n\n  XMLDocType = require('./XMLDocType');\n\n  XMLDTDAttList = require('./XMLDTDAttList');\n\n  XMLDTDEntity = require('./XMLDTDEntity');\n\n  XMLDTDElement = require('./XMLDTDElement');\n\n  XMLDTDNotation = require('./XMLDTDNotation');\n\n  XMLAttribute = require('./XMLAttribute');\n\n  XMLStringifier = require('./XMLStringifier');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  WriterState = require('./WriterState');\n\n  // Represents an XML builder\n  module.exports = XMLDocumentCB = class XMLDocumentCB {\n    // Initializes a new instance of `XMLDocumentCB`\n\n    // `options.keepNullNodes` whether nodes with null values will be kept\n    //     or ignored: true or false\n    // `options.keepNullAttributes` whether attributes with null values will be\n    //     kept or ignored: true or false\n    // `options.ignoreDecorators` whether decorator strings will be ignored when\n    //     converting JS objects: true or false\n    // `options.separateArrayItems` whether array items are created as separate\n    //     nodes when passed as an object value: true or false\n    // `options.noDoubleEncoding` whether existing html entities are encoded:\n    //     true or false\n    // `options.stringify` a set of functions to use for converting values to\n    //     strings\n    // `options.writer` the default XML writer to use for converting nodes to\n    //     string. If the default writer is not set, the built-in XMLStringWriter\n    //     will be used instead.\n\n    // `onData` the function to be called when a new chunk of XML is output. The\n    //          string containing the XML chunk is passed to `onData` as its first\n    //          argument, and the current indentation level as its second argument.\n    // `onEnd`  the function to be called when the XML document is completed with\n    //          `end`. `onEnd` does not receive any arguments.\n    constructor(options, onData, onEnd) {\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n      this.onDataCallback = onData || function() {};\n      this.onEndCallback = onEnd || function() {};\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    }\n\n    // Creates a child element node from the given XMLNode\n\n    // `node` the child node\n    createChildNode(node) {\n      var att, attName, attributes, child, i, len, ref, ref1;\n      switch (node.type) {\n        case NodeType.CData:\n          this.cdata(node.value);\n          break;\n        case NodeType.Comment:\n          this.comment(node.value);\n          break;\n        case NodeType.Element:\n          attributes = {};\n          ref = node.attribs;\n          for (attName in ref) {\n            if (!hasProp.call(ref, attName)) continue;\n            att = ref[attName];\n            attributes[attName] = att.value;\n          }\n          this.node(node.name, attributes);\n          break;\n        case NodeType.Dummy:\n          this.dummy();\n          break;\n        case NodeType.Raw:\n          this.raw(node.value);\n          break;\n        case NodeType.Text:\n          this.text(node.value);\n          break;\n        case NodeType.ProcessingInstruction:\n          this.instruction(node.target, node.value);\n          break;\n        default:\n          throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n      }\n      ref1 = node.children;\n      // write child nodes recursively\n      for (i = 0, len = ref1.length; i < len; i++) {\n        child = ref1[i];\n        this.createChildNode(child);\n        if (child.type === NodeType.Element) {\n          this.up();\n        }\n      }\n      return this;\n    }\n\n    // Creates a dummy node\n\n    dummy() {\n      // no-op, just return this\n      return this;\n    }\n\n    // Creates a node\n\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n    node(name, attributes, text) {\n      if (name == null) {\n        throw new Error(\"Missing node name.\");\n      }\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n      }\n      this.openCurrent();\n      name = getValue(name);\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = getValue(attributes);\n      // swap argument order: text <-> attributes\n      if (!isObject(attributes)) {\n        [text, attributes] = [attributes, text];\n      }\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      if (text != null) {\n        this.text(text);\n      }\n      return this;\n    }\n\n    // Creates a child element node or an element type declaration when called\n    // inside the DTD\n\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n    element(name, attributes, text) {\n      var child, i, len, oldValidationFlag, ref, root;\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        this.dtdElement(...arguments);\n      } else {\n        if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n          oldValidationFlag = this.options.noValidation;\n          this.options.noValidation = true;\n          root = new XMLDocument(this.options).element('TEMP_ROOT');\n          root.element(name);\n          this.options.noValidation = oldValidationFlag;\n          ref = root.children;\n          for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            this.createChildNode(child);\n            if (child.type === NodeType.Element) {\n              this.up();\n            }\n          }\n        } else {\n          this.node(name, attributes, text);\n        }\n      }\n      return this;\n    }\n\n    // Adds or modifies an attribute\n\n    // `name` attribute name\n    // `value` attribute value\n    attribute(name, value) {\n      var attName, attValue;\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n      }\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (isObject(name)) { // expand if object\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (this.options.keepNullAttributes && (value == null)) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    }\n\n    // Creates a text node\n\n    // `value` element text\n    text(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a CDATA node\n\n    // `value` element text without CDATA delimiters\n    cdata(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a comment node\n\n    // `value` comment text\n    comment(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Adds unescaped raw text\n\n    // `value` text\n    raw(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Adds a processing instruction\n\n    // `target` instruction target\n    // `value` instruction value\n    instruction(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n      if (target != null) {\n        target = getValue(target);\n      }\n      if (value != null) {\n        value = getValue(value);\n      }\n      if (Array.isArray(target)) { // expand if array\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) { // expand if object\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      }\n      return this;\n    }\n\n    // Creates the xml declaration\n\n    // `version` A version number string, e.g. 1.0\n    // `encoding` Encoding declaration, e.g. UTF-8\n    // `standalone` standalone document declaration: true or false\n    declaration(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node.\");\n      }\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates the document type declaration\n\n    // `root`  the name of the root node\n    // `pubID` the public identifier of the external subset\n    // `sysID` the system identifier of the external subset\n    doctype(root, pubID, sysID) {\n      this.openCurrent();\n      if (root == null) {\n        throw new Error(\"Missing root node name.\");\n      }\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node.\");\n      }\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    }\n\n    // Creates an element type declaration\n\n    // `name` element name\n    // `value` element content (defaults to #PCDATA)\n    dtdElement(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates an attribute declaration\n\n    // `elementName` the name of the element containing this attribute\n    // `attributeName` attribute name\n    // `attributeType` type of the attribute (defaults to CDATA)\n    // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or\n    //                    #DEFAULT) (defaults to #IMPLIED)\n    // `defaultValue` default value of the attribute\n    //                (only used for #FIXED or #DEFAULT)\n    attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a general entity declaration\n\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    // `value.nData` notation declaration\n    entity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a parameter entity declaration\n\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    pEntity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a NOTATION declaration\n\n    // `name` the name of the notation\n    // `value` an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    notation(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Gets the parent node\n    up() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent.\");\n      }\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    }\n\n    // Ends the document\n    end() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n      return this.onEnd();\n    }\n\n    // Opens the current parent node\n    openCurrent() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    }\n\n    // Writes the opening tag of the current node or the entire node if it has\n    // no child nodes\n    openNode(node) {\n      var att, chunk, name, ref;\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n          this.root = node;\n        }\n        chunk = '';\n        if (node.type === NodeType.Element) {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n          ref = node.attribs;\n          for (name in ref) {\n            if (!hasProp.call(ref, name)) continue;\n            att = ref[name];\n            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n          }\n          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType\n        } else {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;\n          \n          // external identifier\n          if (node.pubID && node.sysID) {\n            chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n          } else if (node.sysID) {\n            chunk += ' SYSTEM \"' + node.sysID + '\"';\n          }\n          \n          // internal subset\n          if (node.children) {\n            chunk += ' [';\n            this.writerOptions.state = WriterState.InsideTag;\n          } else {\n            this.writerOptions.state = WriterState.CloseTag;\n            chunk += '>';\n          }\n          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.onData(chunk, this.currentLevel);\n        return node.isOpen = true;\n      }\n    }\n\n    // Writes the closing tag of the current node\n    closeNode(node) {\n      var chunk;\n      if (!node.isClosed) {\n        chunk = '';\n        this.writerOptions.state = WriterState.CloseTag;\n        if (node.type === NodeType.Element) {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel); // if node.type is NodeType.DocType\n        } else {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.writerOptions.state = WriterState.None;\n        this.onData(chunk, this.currentLevel);\n        return node.isClosed = true;\n      }\n    }\n\n    // Called when a new chunk of XML is output\n\n    // `chunk` a string containing the XML chunk\n    // `level` current indentation level\n    onData(chunk, level) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk, level + 1);\n    }\n\n    // Called when the XML document is completed\n    onEnd() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    }\n\n    // Returns debug string\n    debugInfo(name) {\n      if (name == null) {\n        return \"\";\n      } else {\n        return \"node: <\" + name + \">\";\n      }\n    }\n\n    // Node aliases\n    ele() {\n      return this.element(...arguments);\n    }\n\n    nod(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    txt(value) {\n      return this.text(value);\n    }\n\n    dat(value) {\n      return this.cdata(value);\n    }\n\n    com(value) {\n      return this.comment(value);\n    }\n\n    ins(target, value) {\n      return this.instruction(target, value);\n    }\n\n    dec(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    }\n\n    dtd(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    }\n\n    e(name, attributes, text) {\n      return this.element(name, attributes, text);\n    }\n\n    n(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    t(value) {\n      return this.text(value);\n    }\n\n    d(value) {\n      return this.cdata(value);\n    }\n\n    c(value) {\n      return this.comment(value);\n    }\n\n    r(value) {\n      return this.raw(value);\n    }\n\n    i(target, value) {\n      return this.instruction(target, value);\n    }\n\n    // Attribute aliases\n    att() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    a() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    // DTD aliases\n    // att() and ele() are defined above\n    ent(name, value) {\n      return this.entity(name, value);\n    }\n\n    pent(name, value) {\n      return this.pEntity(name, value);\n    }\n\n    not(name, value) {\n      return this.notation(name, value);\n    }\n\n  };\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}