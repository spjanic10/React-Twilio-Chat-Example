{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Upstream = void 0;\n\nvar logger_1 = require(\"../logger\");\n\nvar twilsockerror_1 = require(\"../error/twilsockerror\");\n\nvar twilsockupstreamerror_1 = require(\"../error/twilsockupstreamerror\");\n\nvar Messages = require(\"../protocol/messages\");\n\nvar transportunavailableerror_1 = require(\"../error/transportunavailableerror\");\n\nvar REQUEST_TIMEOUT = 20000;\n\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\n\nfunction isHttpReply(packet) {\n  return packet && packet.header && packet.header.http_status;\n}\n\nvar Request = function Request() {\n  _classCallCheck(this, Request);\n};\n\nfunction parseUri(uri) {\n  var match = uri.match(/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)(\\/[^?#]*)(\\?[^#]*|)(#.*|)$/);\n\n  if (match) {\n    var uriStruct = {\n      protocol: match[1],\n      host: match[2],\n      hostname: match[3],\n      port: match[4],\n      pathname: match[5],\n      search: match[6],\n      hash: match[7],\n      params: null\n    };\n\n    if (uriStruct.search.length > 0) {\n      var paramsString = uriStruct.search.substring(1);\n      uriStruct.params = paramsString.split('&').map(function (el) {\n        return el.split('=');\n      }).reduce(function (prev, curr) {\n        if (!prev.hasOwnProperty(curr[0])) {\n          prev[curr[0]] = curr[1];\n        } else if (Array.isArray(prev[curr[0]])) {\n          prev[curr[0]].push(curr[1]);\n        } else {\n          prev[curr[0]] = [prev[curr[0]], curr[1]];\n        }\n\n        return prev;\n      }, {});\n    }\n\n    return uriStruct;\n  }\n\n  throw new twilsockerror_1.TwilsockError('Incorrect URI: ' + uri);\n}\n\nfunction twilsockAddress(method, uri) {\n  var parsedUri = parseUri(uri);\n  var to = {\n    method: method,\n    host: parsedUri.host,\n    path: parsedUri.pathname\n  };\n\n  if (parsedUri.params) {\n    to.params = parsedUri.params;\n  }\n\n  return to;\n}\n\nfunction twilsockParams(method, uri, headers, body) {\n  return {\n    to: twilsockAddress(method, uri),\n    headers: headers,\n    body: body\n  };\n}\n\nvar Upstream = /*#__PURE__*/function () {\n  function Upstream(transport, twilsock, config) {\n    _classCallCheck(this, Upstream);\n\n    this.config = config;\n    this.transport = transport;\n    this.pendingMessages = [];\n    this.twilsock = twilsock;\n  }\n\n  _createClass(Upstream, [{\n    key: \"saveMessage\",\n    value: function saveMessage(message) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        var requestDescriptor = {\n          message: message,\n          resolve: resolve,\n          reject: reject,\n          alreadyRejected: false,\n          timeout: setTimeout(function () {\n            logger_1.log.debug('request is timed out');\n            reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout'));\n            requestDescriptor.alreadyRejected = true;\n          }, REQUEST_TIMEOUT)\n        };\n\n        _this.pendingMessages.push(requestDescriptor);\n      });\n    }\n  }, {\n    key: \"sendPendingMessages\",\n    value: function sendPendingMessages() {\n      var _this2 = this;\n\n      var _loop = function _loop() {\n        var request = _this2.pendingMessages[0]; // Do not send message if we've rejected its promise already\n\n        if (!request.alreadyRejected) {\n          try {\n            var message = request.message;\n\n            _this2.actualSend(message).then(function (response) {\n              return request.resolve(response);\n            }).catch(function (e) {\n              return request.reject(e);\n            });\n\n            clearTimeout(request.timeout);\n          } catch (e) {\n            logger_1.log.debug('Failed to send pending message', e);\n            return \"break\";\n          }\n        }\n\n        _this2.pendingMessages.splice(0, 1);\n      };\n\n      while (this.pendingMessages.length) {\n        var _ret = _loop();\n\n        if (_ret === \"break\") break;\n      }\n    }\n  }, {\n    key: \"rejectPendingMessages\",\n    value: function rejectPendingMessages() {\n      var _this3 = this;\n\n      this.pendingMessages.forEach(function (message) {\n        message.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + _this3.twilsock.getTerminationReason));\n        clearTimeout(message.timeout);\n      });\n      this.pendingMessages.splice(0, this.pendingMessages.length);\n    }\n  }, {\n    key: \"actualSend\",\n    value: function () {\n      var _actualSend = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(message) {\n        var address, headers, body, httpRequest, upstreamMessage, reply;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                address = message.to;\n                headers = message.headers;\n                body = message.body;\n                httpRequest = {\n                  host: address.host,\n                  path: address.path,\n                  method: address.method,\n                  params: address.params,\n                  headers: headers\n                };\n                upstreamMessage = new Messages.Message(this.config.activeGrant, headers['Content-Type'] || 'application/json', httpRequest);\n                _context.next = 7;\n                return this.transport.sendWithReply(upstreamMessage, body);\n\n              case 7:\n                reply = _context.sent;\n\n                if (!(isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code))) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new twilsockupstreamerror_1.TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);\n\n              case 10:\n                return _context.abrupt(\"return\", {\n                  status: reply.header.http_status,\n                  headers: reply.header.http_headers,\n                  body: reply.body\n                });\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function actualSend(_x) {\n        return _actualSend.apply(this, arguments);\n      }\n\n      return actualSend;\n    }()\n    /**\n     * Send an upstream message\n     * @param {Twilsock#Message} message Message structure with header, body and remote address\n     * @returns {Promise<Result>} Result from remote side\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(method, url) {\n      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var body = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (this.twilsock.isTerminalState) {\n        return Promise.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\n      }\n\n      var twilsockMessage = twilsockParams(method, url, headers, body);\n\n      if (!this.twilsock.isConnected) {\n        return this.saveMessage(twilsockMessage);\n      }\n\n      return this.actualSend(twilsockMessage);\n    }\n  }]);\n\n  return Upstream;\n}();\n\nexports.Upstream = Upstream;","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilsock/lib/services/upstream.js"],"names":["Object","defineProperty","exports","value","Upstream","logger_1","require","twilsockerror_1","twilsockupstreamerror_1","Messages","transportunavailableerror_1","REQUEST_TIMEOUT","isHttpSuccess","code","isHttpReply","packet","header","http_status","Request","parseUri","uri","match","uriStruct","protocol","host","hostname","port","pathname","search","hash","params","length","paramsString","substring","split","map","el","reduce","prev","curr","hasOwnProperty","Array","isArray","push","TwilsockError","twilsockAddress","method","parsedUri","to","path","twilsockParams","headers","body","transport","twilsock","config","pendingMessages","message","Promise","resolve","reject","requestDescriptor","alreadyRejected","timeout","setTimeout","log","debug","request","actualSend","then","response","catch","e","clearTimeout","splice","forEach","TransportUnavailableError","getTerminationReason","address","httpRequest","upstreamMessage","Message","activeGrant","sendWithReply","reply","TwilsockUpstreamError","status","http_headers","url","isTerminalState","twilsockMessage","isConnected","saveMessage"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Upstream = void 0;\nconst logger_1 = require(\"../logger\");\nconst twilsockerror_1 = require(\"../error/twilsockerror\");\nconst twilsockupstreamerror_1 = require(\"../error/twilsockupstreamerror\");\nconst Messages = require(\"../protocol/messages\");\nconst transportunavailableerror_1 = require(\"../error/transportunavailableerror\");\nconst REQUEST_TIMEOUT = 20000;\nfunction isHttpSuccess(code) {\n    return (code >= 200 && code < 300);\n}\nfunction isHttpReply(packet) {\n    return packet && packet.header && packet.header.http_status;\n}\nclass Request {\n}\nfunction parseUri(uri) {\n    const match = uri.match(/^(https?\\:)\\/\\/(([^:\\/?#]*)(?:\\:([0-9]+))?)(\\/[^?#]*)(\\?[^#]*|)(#.*|)$/);\n    if (match) {\n        let uriStruct = {\n            protocol: match[1],\n            host: match[2],\n            hostname: match[3],\n            port: match[4],\n            pathname: match[5],\n            search: match[6],\n            hash: match[7],\n            params: null\n        };\n        if (uriStruct.search.length > 0) {\n            let paramsString = uriStruct.search.substring(1);\n            uriStruct.params = paramsString.split('&')\n                .map(el => el.split('='))\n                .reduce((prev, curr) => {\n                if (!prev.hasOwnProperty(curr[0])) {\n                    prev[curr[0]] = curr[1];\n                }\n                else if (Array.isArray(prev[curr[0]])) {\n                    prev[curr[0]].push(curr[1]);\n                }\n                else {\n                    prev[curr[0]] = [prev[curr[0]], curr[1]];\n                }\n                return prev;\n            }, {});\n        }\n        return uriStruct;\n    }\n    throw new twilsockerror_1.TwilsockError('Incorrect URI: ' + uri);\n}\nfunction twilsockAddress(method, uri) {\n    const parsedUri = parseUri(uri);\n    let to = {\n        method: method,\n        host: parsedUri.host,\n        path: parsedUri.pathname\n    };\n    if (parsedUri.params) {\n        to.params = parsedUri.params;\n    }\n    return to;\n}\nfunction twilsockParams(method, uri, headers, body) {\n    return {\n        to: twilsockAddress(method, uri),\n        headers: headers,\n        body: body\n    };\n}\nclass Upstream {\n    constructor(transport, twilsock, config) {\n        this.config = config;\n        this.transport = transport;\n        this.pendingMessages = [];\n        this.twilsock = twilsock;\n    }\n    saveMessage(message) {\n        return new Promise((resolve, reject) => {\n            let requestDescriptor = {\n                message,\n                resolve: resolve,\n                reject: reject,\n                alreadyRejected: false,\n                timeout: setTimeout(() => {\n                    logger_1.log.debug('request is timed out');\n                    reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout'));\n                    requestDescriptor.alreadyRejected = true;\n                }, REQUEST_TIMEOUT)\n            };\n            this.pendingMessages.push(requestDescriptor);\n        });\n    }\n    sendPendingMessages() {\n        while (this.pendingMessages.length) {\n            let request = this.pendingMessages[0];\n            // Do not send message if we've rejected its promise already\n            if (!request.alreadyRejected) {\n                try {\n                    let message = request.message;\n                    this.actualSend(message)\n                        .then(response => request.resolve(response))\n                        .catch(e => request.reject(e));\n                    clearTimeout(request.timeout);\n                }\n                catch (e) {\n                    logger_1.log.debug('Failed to send pending message', e);\n                    break;\n                }\n            }\n            this.pendingMessages.splice(0, 1);\n        }\n    }\n    rejectPendingMessages() {\n        this.pendingMessages.forEach(message => {\n            message.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\n            clearTimeout(message.timeout);\n        });\n        this.pendingMessages.splice(0, this.pendingMessages.length);\n    }\n    async actualSend(message) {\n        let address = message.to;\n        let headers = message.headers;\n        let body = message.body;\n        let httpRequest = {\n            host: address.host,\n            path: address.path,\n            method: address.method,\n            params: address.params,\n            headers: headers\n        };\n        let upstreamMessage = new Messages.Message(this.config.activeGrant, headers['Content-Type'] || 'application/json', httpRequest);\n        let reply = await this.transport.sendWithReply(upstreamMessage, body);\n        if (isHttpReply(reply) && !isHttpSuccess(reply.header.http_status.code)) {\n            throw new twilsockupstreamerror_1.TwilsockUpstreamError(reply.header.http_status.code, reply.header.http_status.status, reply.body);\n        }\n        return {\n            status: reply.header.http_status,\n            headers: reply.header.http_headers,\n            body: reply.body\n        };\n    }\n    /**\n     * Send an upstream message\n     * @param {Twilsock#Message} message Message structure with header, body and remote address\n     * @returns {Promise<Result>} Result from remote side\n     */\n    send(method, url, headers = {}, body) {\n        if (this.twilsock.isTerminalState) {\n            return Promise.reject(new transportunavailableerror_1.TransportUnavailableError('Unable to connect: ' + this.twilsock.getTerminationReason));\n        }\n        let twilsockMessage = twilsockParams(method, url, headers, body);\n        if (!this.twilsock.isConnected) {\n            return this.saveMessage(twilsockMessage);\n        }\n        return this.actualSend(twilsockMessage);\n    }\n}\nexports.Upstream = Upstream;\n"]},"metadata":{},"sourceType":"script"}