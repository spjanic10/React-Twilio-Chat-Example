{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\n\nvar events_1 = require(\"events\");\n\nvar twilsock_1 = require(\"twilsock\");\n\nvar configuration_1 = require(\"./configuration\");\n\nvar registrar_1 = require(\"./registrar\");\n\nvar logger_1 = require(\"./logger\");\n/**\n * @class\n * @alias Notifications\n * @classdesc The helper library for the notification service.\n * Provides high level api for creating and managing notification subscriptions and receiving messages\n * Creates the instance of Notification helper library\n *\n * @constructor\n * @param {string} token - Twilio access token\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\n */\n\n\nvar Client = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Client, _events_1$EventEmitte);\n\n  var _super = _createSuper(Client);\n\n  function Client(token) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Client);\n\n    _this = _super.call(this);\n\n    if (!token || token.length === 0) {\n      throw new Error('Token is required for Notifications client');\n    }\n\n    options.logLevel = options.logLevel || 'error';\n    logger_1.log.setLevel(options.logLevel);\n    var minTokenRefreshInterval = options.minTokenRefreshInterval || 10000;\n    var productId = options.productId || 'notifications';\n    options.twilsockClient = options.twilsockClient || new twilsock_1.TwilsockClient(token, productId, options);\n    options.transport = options.transport || options.twilsockClient;\n    _this.services = {\n      twilsock: options.twilsockClient,\n      transport: options.transport,\n      config: new configuration_1.Configuration(null, options)\n    };\n    _this.registrar = new registrar_1.Registrar(productId, _this.services.transport, _this.services.twilsock, _this.services.config);\n    _this.reliableTransportState = {\n      overall: false,\n      transport: false,\n      registration: false,\n      lastEmitted: null\n    };\n\n    _this._onTransportStateChange(_this.services.twilsock.isConnected);\n\n    _this.registrar.on('transportReady', function (state) {\n      _this._onRegistrationStateChange(state ? 'registered' : '');\n    });\n\n    _this.registrar.on('stateChanged', function (state) {\n      _this._onRegistrationStateChange(state);\n    });\n\n    _this.registrar.on('needReliableTransport', _this._onNeedReliableTransport.bind(_assertThisInitialized(_this)));\n\n    _this.services.twilsock.on('message', function (type, message) {\n      return _this._routeMessage(type, message);\n    });\n\n    _this.services.twilsock.on('connected', function (notificationId) {\n      _this._onTransportStateChange(true);\n\n      _this.registrar.setNotificationId('twilsock', notificationId);\n    });\n\n    _this.services.twilsock.on('disconnected', function () {\n      _this._onTransportStateChange(false);\n    });\n\n    _this.services.config.updateToken(token);\n\n    _this.registrar.updateToken(token);\n\n    return _this;\n  }\n\n  _createClass(Client, [{\n    key: \"connectionState\",\n    get: function get() {\n      if (this.services.twilsock.state === 'disconnected') {\n        return 'disconnected';\n      } else if (this.services.twilsock.state === 'disconnecting') {\n        return 'disconnecting';\n      } else if (this.services.twilsock.state === 'connected' && this.reliableTransportState.registration) {\n        return 'connected';\n      } else if (this.services.twilsock.state === 'rejected') {\n        return 'denied';\n      }\n\n      return 'connecting';\n    }\n    /**\n     * Routes messages to the external subscribers\n     * @private\n     */\n\n  }, {\n    key: \"_routeMessage\",\n    value: function _routeMessage(type, message) {\n      logger_1.log.trace('Message arrived: ', type, message);\n      this.emit('message', type, message);\n    }\n  }, {\n    key: \"_onNeedReliableTransport\",\n    value: function _onNeedReliableTransport(isNeeded) {\n      if (isNeeded) {\n        this.services.twilsock.connect();\n      } else {\n        this.services.twilsock.disconnect();\n      }\n    }\n  }, {\n    key: \"_onRegistrationStateChange\",\n    value: function _onRegistrationStateChange(state) {\n      this.reliableTransportState.registration = state === 'registered';\n\n      this._updateTransportState();\n    }\n  }, {\n    key: \"_onTransportStateChange\",\n    value: function _onTransportStateChange(connected) {\n      this.reliableTransportState.transport = connected;\n\n      this._updateTransportState();\n    }\n  }, {\n    key: \"_updateTransportState\",\n    value: function _updateTransportState() {\n      var overallState = this.reliableTransportState.transport && this.reliableTransportState.registration;\n\n      if (this.reliableTransportState.overall !== overallState) {\n        this.reliableTransportState.overall = overallState;\n        logger_1.log.info('Transport ready:', overallState);\n        this.emit('transportReady', overallState);\n      }\n\n      if (this.reliableTransportState.lastEmitted !== this.connectionState) {\n        this.reliableTransportState.lastEmitted = this.connectionState;\n        this.emit('connectionStateChanged', this.connectionState);\n      }\n    }\n    /**\n     * Adds the subscription for the given message type\n     * @param {string} messageType The type of message that you want to receive\n     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(messageType) {\n      var channelType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'twilsock';\n      logger_1.log.trace('Add subscriptions for message type: ', messageType, channelType);\n      return this.registrar.subscribe(messageType, channelType);\n    }\n    /**\n     * Remove the subscription for the particular message type\n     * @param {string} messageType The type of message that you don't want to receive anymore\n     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(messageType) {\n      var channelType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'twilsock';\n      logger_1.log.trace('Remove subscriptions for message type: ', messageType, channelType);\n      return this.registrar.unsubscribe(messageType, channelType);\n    }\n    /**\n     * Handle incoming push notification.\n     * Client application should call this method when it receives push notifications and pass the received data\n     * @param {Object} message push message\n     * @return {PushNotification}\n     */\n\n  }, {\n    key: \"handlePushNotification\",\n    value: function handlePushNotification(message) {\n      return {\n        messageType: message.twi_message_type,\n        payload: message.payload\n      };\n    }\n    /**\n     * Set APN/GCM/FCM token to enable application register for a push messages\n     * @param {string} gcmToken/fcmToken Token received from GCM/FCM system\n     */\n\n  }, {\n    key: \"setPushRegistrationId\",\n    value: function setPushRegistrationId(registrationId, channelType) {\n      logger_1.log.trace('Set push registration id', registrationId, channelType);\n      this.registrar.setNotificationId(channelType, registrationId);\n    }\n    /**\n     * Updates auth token for registration\n     * @param {string} token Authentication token for registrations\n     */\n\n  }, {\n    key: \"updateToken\",\n    value: function () {\n      var _updateToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(token) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger_1.log.info('authTokenUpdated');\n\n                if (!(this.services.config.token === token)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                _context.next = 5;\n                return this.services.twilsock.updateToken(token);\n\n              case 5:\n                this.services.config.updateToken(token);\n                this.registrar.updateToken(token);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function updateToken(_x) {\n        return _updateToken.apply(this, arguments);\n      }\n\n      return updateToken;\n    }()\n  }]);\n\n  return Client;\n}(events_1.EventEmitter);\n\nexports.Client = Client;\n/**\n * Fired when new message arrived.\n * @param {Object} message`\n * @event Client#message\n */\n\n/**\n * Fired when transport state has changed\n * @param {boolean} transport state\n * @event Client#transportReady\n */\n\n/**\n * Fired when transport state has been changed\n * @param {string} transport state\n * @event Client#connectionStateChanged\n */\n\n/**\n * These options can be passed to Client constructor\n * @typedef {Object} Notifications#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n */","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilio-notifications/lib/client.js"],"names":["Object","defineProperty","exports","value","Client","events_1","require","twilsock_1","configuration_1","registrar_1","logger_1","token","options","length","Error","logLevel","log","setLevel","minTokenRefreshInterval","productId","twilsockClient","TwilsockClient","transport","services","twilsock","config","Configuration","registrar","Registrar","reliableTransportState","overall","registration","lastEmitted","_onTransportStateChange","isConnected","on","state","_onRegistrationStateChange","_onNeedReliableTransport","bind","type","message","_routeMessage","notificationId","setNotificationId","updateToken","trace","emit","isNeeded","connect","disconnect","_updateTransportState","connected","overallState","info","connectionState","messageType","channelType","subscribe","unsubscribe","twi_message_type","payload","registrationId","EventEmitter"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Client = void 0;\nconst events_1 = require(\"events\");\nconst twilsock_1 = require(\"twilsock\");\nconst configuration_1 = require(\"./configuration\");\nconst registrar_1 = require(\"./registrar\");\nconst logger_1 = require(\"./logger\");\n/**\n * @class\n * @alias Notifications\n * @classdesc The helper library for the notification service.\n * Provides high level api for creating and managing notification subscriptions and receiving messages\n * Creates the instance of Notification helper library\n *\n * @constructor\n * @param {string} token - Twilio access token\n * @param {Notifications#ClientOptions} options - Options to customize client behavior\n */\nclass Client extends events_1.EventEmitter {\n    constructor(token, options = {}) {\n        super();\n        if (!token || token.length === 0) {\n            throw new Error('Token is required for Notifications client');\n        }\n        options.logLevel = options.logLevel || 'error';\n        logger_1.log.setLevel(options.logLevel);\n        const minTokenRefreshInterval = options.minTokenRefreshInterval || 10000;\n        const productId = options.productId || 'notifications';\n        options.twilsockClient = options.twilsockClient || new twilsock_1.TwilsockClient(token, productId, options);\n        options.transport = options.transport || options.twilsockClient;\n        this.services = {\n            twilsock: options.twilsockClient,\n            transport: options.transport,\n            config: new configuration_1.Configuration(null, options)\n        };\n        this.registrar = new registrar_1.Registrar(productId, this.services.transport, this.services.twilsock, this.services.config);\n        this.reliableTransportState = {\n            overall: false,\n            transport: false,\n            registration: false,\n            lastEmitted: null\n        };\n        this._onTransportStateChange(this.services.twilsock.isConnected);\n        this.registrar.on('transportReady', state => {\n            this._onRegistrationStateChange(state ? 'registered' : '');\n        });\n        this.registrar.on('stateChanged', (state) => {\n            this._onRegistrationStateChange(state);\n        });\n        this.registrar.on('needReliableTransport', this._onNeedReliableTransport.bind(this));\n        this.services.twilsock.on('message', (type, message) => this._routeMessage(type, message));\n        this.services.twilsock.on('connected', (notificationId) => {\n            this._onTransportStateChange(true);\n            this.registrar.setNotificationId('twilsock', notificationId);\n        });\n        this.services.twilsock.on('disconnected', () => {\n            this._onTransportStateChange(false);\n        });\n        this.services.config.updateToken(token);\n        this.registrar.updateToken(token);\n    }\n    get connectionState() {\n        if (this.services.twilsock.state === 'disconnected') {\n            return 'disconnected';\n        }\n        else if (this.services.twilsock.state === 'disconnecting') {\n            return 'disconnecting';\n        }\n        else if (this.services.twilsock.state === 'connected' && this.reliableTransportState.registration) {\n            return 'connected';\n        }\n        else if (this.services.twilsock.state === 'rejected') {\n            return 'denied';\n        }\n        return 'connecting';\n    }\n    /**\n     * Routes messages to the external subscribers\n     * @private\n     */\n    _routeMessage(type, message) {\n        logger_1.log.trace('Message arrived: ', type, message);\n        this.emit('message', type, message);\n    }\n    _onNeedReliableTransport(isNeeded) {\n        if (isNeeded) {\n            this.services.twilsock.connect();\n        }\n        else {\n            this.services.twilsock.disconnect();\n        }\n    }\n    _onRegistrationStateChange(state) {\n        this.reliableTransportState.registration = (state === 'registered');\n        this._updateTransportState();\n    }\n    _onTransportStateChange(connected) {\n        this.reliableTransportState.transport = connected;\n        this._updateTransportState();\n    }\n    _updateTransportState() {\n        const overallState = this.reliableTransportState.transport\n            && this.reliableTransportState.registration;\n        if (this.reliableTransportState.overall !== overallState) {\n            this.reliableTransportState.overall = overallState;\n            logger_1.log.info('Transport ready:', overallState);\n            this.emit('transportReady', overallState);\n        }\n        if (this.reliableTransportState.lastEmitted !== this.connectionState) {\n            this.reliableTransportState.lastEmitted = this.connectionState;\n            this.emit('connectionStateChanged', this.connectionState);\n        }\n    }\n    /**\n     * Adds the subscription for the given message type\n     * @param {string} messageType The type of message that you want to receive\n     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n     */\n    subscribe(messageType, channelType = 'twilsock') {\n        logger_1.log.trace('Add subscriptions for message type: ', messageType, channelType);\n        return this.registrar.subscribe(messageType, channelType);\n    }\n    /**\n     * Remove the subscription for the particular message type\n     * @param {string} messageType The type of message that you don't want to receive anymore\n     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'\n     */\n    unsubscribe(messageType, channelType = 'twilsock') {\n        logger_1.log.trace('Remove subscriptions for message type: ', messageType, channelType);\n        return this.registrar.unsubscribe(messageType, channelType);\n    }\n    /**\n     * Handle incoming push notification.\n     * Client application should call this method when it receives push notifications and pass the received data\n     * @param {Object} message push message\n     * @return {PushNotification}\n     */\n    handlePushNotification(message) {\n        return {\n            messageType: message.twi_message_type,\n            payload: message.payload\n        };\n    }\n    /**\n     * Set APN/GCM/FCM token to enable application register for a push messages\n     * @param {string} gcmToken/fcmToken Token received from GCM/FCM system\n     */\n    setPushRegistrationId(registrationId, channelType) {\n        logger_1.log.trace('Set push registration id', registrationId, channelType);\n        this.registrar.setNotificationId(channelType, registrationId);\n    }\n    /**\n     * Updates auth token for registration\n     * @param {string} token Authentication token for registrations\n     */\n    async updateToken(token) {\n        logger_1.log.info('authTokenUpdated');\n        if (this.services.config.token === token) {\n            return;\n        }\n        await this.services.twilsock.updateToken(token);\n        this.services.config.updateToken(token);\n        this.registrar.updateToken(token);\n    }\n}\nexports.Client = Client;\n/**\n * Fired when new message arrived.\n * @param {Object} message`\n * @event Client#message\n */\n/**\n * Fired when transport state has changed\n * @param {boolean} transport state\n * @event Client#transportReady\n */\n/**\n * Fired when transport state has been changed\n * @param {string} transport state\n * @event Client#connectionStateChanged\n */\n/**\n * These options can be passed to Client constructor\n * @typedef {Object} Notifications#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']\n */\n"]},"metadata":{},"sourceType":"script"}