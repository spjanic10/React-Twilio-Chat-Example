{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar logger_1 = require(\"./logger\");\n\nvar uuid_1 = require(\"uuid\");\n\nvar twilsockerror_1 = require(\"./error/twilsockerror\");\n\nvar twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\n\nvar parser_1 = require(\"./parser\");\n\nvar Messages = require(\"./protocol/messages\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar REQUEST_TIMEOUT = 30000;\n\nfunction isHttpSuccess(code) {\n  return code >= 200 && code < 300;\n}\n/**\n * Makes sure that body is properly stringified\n */\n\n\nfunction preparePayload(payload) {\n  switch (typeof payload) {\n    case 'undefined':\n      return '';\n\n    case 'object':\n      return JSON.stringify(payload);\n\n    default:\n      return payload;\n  }\n}\n\nvar PacketRequest = function PacketRequest() {\n  _classCallCheck(this, PacketRequest);\n};\n\nvar PacketResponse = function PacketResponse() {\n  _classCallCheck(this, PacketResponse);\n};\n\nexports.PacketResponse = PacketResponse;\n\nvar PacketInterface = /*#__PURE__*/function () {\n  function PacketInterface(channel, config) {\n    var _this = this;\n\n    _classCallCheck(this, PacketInterface);\n\n    this.config = config;\n    this.activeRequests = new Map();\n    this.channel = channel;\n    this.channel.on('reply', function (reply) {\n      return _this.processReply(reply);\n    });\n    this.channel.on('disconnected', function () {\n      _this.activeRequests.forEach(function (descriptor) {\n        clearTimeout(descriptor.timeout);\n        descriptor.reject(new twilsockerror_1.TwilsockError('disconnected'));\n      });\n\n      _this.activeRequests.clear();\n    });\n  }\n\n  _createClass(PacketInterface, [{\n    key: \"isConnected\",\n    get: function get() {\n      return this.channel.isConnected;\n    }\n  }, {\n    key: \"processReply\",\n    value: function processReply(reply) {\n      var request = this.activeRequests.get(reply.id);\n\n      if (request) {\n        clearTimeout(request.timeout);\n        this.activeRequests.delete(reply.id);\n\n        if (!isHttpSuccess(reply.status.code)) {\n          request.reject(new twilsockreplyerror_1.TwilsockReplyError('Transport failure: ' + reply.status.status, reply));\n          logger_1.log.trace('message rejected');\n        } else {\n          request.resolve(reply);\n        }\n      }\n    }\n  }, {\n    key: \"storeRequest\",\n    value: function storeRequest(id, resolve, reject) {\n      var requestDescriptor = {\n        resolve: resolve,\n        reject: reject,\n        timeout: setTimeout(function () {\n          logger_1.log.trace('request', id, 'is timed out');\n          reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout: ' + id));\n        }, REQUEST_TIMEOUT)\n      };\n      this.activeRequests.set(id, requestDescriptor);\n    }\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      this.activeRequests.forEach(function (descriptor) {\n        clearTimeout(descriptor.timeout);\n        descriptor.reject(new twilsockerror_1.TwilsockError('Twilsock: request cancelled by user'));\n      });\n      this.activeRequests.clear();\n    }\n  }, {\n    key: \"sendInit\",\n    value: function () {\n      var _sendInit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var metadata, message, response;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                logger_1.log.trace('sendInit');\n                metadata = metadata_1.Metadata.getMetadata(this.config);\n                message = new Messages.Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);\n                _context.next = 5;\n                return this.sendWithReply(message);\n\n              case 5:\n                response = _context.sent;\n                return _context.abrupt(\"return\", new Messages.InitReply(response.id, response.header.continuation_token, response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info, new Set(response.header.capabilities)));\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sendInit() {\n        return _sendInit.apply(this, arguments);\n      }\n\n      return sendInit;\n    }()\n  }, {\n    key: \"sendClose\",\n    value: function sendClose() {\n      var message = new Messages.Close(); //@todo send telemetry AnyEventsIncludingUnfinished\n\n      this.send(message);\n    }\n  }, {\n    key: \"sendWithReply\",\n    value: function sendWithReply(header, payload) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        var id = _this2.send(header, payload);\n\n        _this2.storeRequest(id, resolve, reject);\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(header, payload) {\n      header.id = header.id || \"TM\".concat(uuid_1.v4());\n      var message = parser_1.Parser.createPacket(header, preparePayload(payload));\n\n      try {\n        this.channel.send(message);\n        return header.id;\n      } catch (e) {\n        logger_1.log.debug('failed to send ', header, e);\n        logger_1.log.trace(e.stack);\n        throw e;\n      }\n    }\n  }]);\n\n  return PacketInterface;\n}();\n\nexports.PacketInterface = PacketInterface;","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilio-notifications/node_modules/twilsock/lib/packetinterface.js"],"names":["Object","defineProperty","exports","value","logger_1","require","uuid_1","twilsockerror_1","twilsockreplyerror_1","parser_1","Messages","metadata_1","REQUEST_TIMEOUT","isHttpSuccess","code","preparePayload","payload","JSON","stringify","PacketRequest","PacketResponse","PacketInterface","channel","config","activeRequests","Map","on","reply","processReply","forEach","descriptor","clearTimeout","timeout","reject","TwilsockError","clear","isConnected","request","get","id","delete","status","TwilsockReplyError","log","trace","resolve","requestDescriptor","setTimeout","set","metadata","Metadata","getMetadata","message","Init","token","continuationToken","initRegistrations","tweaks","sendWithReply","response","InitReply","header","continuation_token","continuation_token_status","offline_storage","init_registrations","debug_info","Set","capabilities","Close","send","Promise","storeRequest","v4","Parser","createPacket","e","debug","stack"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logger_1 = require(\"./logger\");\nconst uuid_1 = require(\"uuid\");\nconst twilsockerror_1 = require(\"./error/twilsockerror\");\nconst twilsockreplyerror_1 = require(\"./error/twilsockreplyerror\");\nconst parser_1 = require(\"./parser\");\nconst Messages = require(\"./protocol/messages\");\nconst metadata_1 = require(\"./metadata\");\nconst REQUEST_TIMEOUT = 30000;\nfunction isHttpSuccess(code) {\n    return (code >= 200 && code < 300);\n}\n/**\n * Makes sure that body is properly stringified\n */\nfunction preparePayload(payload) {\n    switch (typeof payload) {\n        case 'undefined':\n            return '';\n        case 'object':\n            return JSON.stringify(payload);\n        default:\n            return payload;\n    }\n}\nclass PacketRequest {\n}\nclass PacketResponse {\n}\nexports.PacketResponse = PacketResponse;\nclass PacketInterface {\n    constructor(channel, config) {\n        this.config = config;\n        this.activeRequests = new Map();\n        this.channel = channel;\n        this.channel.on('reply', reply => this.processReply(reply));\n        this.channel.on('disconnected', () => {\n            this.activeRequests.forEach(descriptor => {\n                clearTimeout(descriptor.timeout);\n                descriptor.reject(new twilsockerror_1.TwilsockError('disconnected'));\n            });\n            this.activeRequests.clear();\n        });\n    }\n    get isConnected() { return this.channel.isConnected; }\n    processReply(reply) {\n        const request = this.activeRequests.get(reply.id);\n        if (request) {\n            clearTimeout(request.timeout);\n            this.activeRequests.delete(reply.id);\n            if (!isHttpSuccess(reply.status.code)) {\n                request.reject(new twilsockreplyerror_1.TwilsockReplyError('Transport failure: ' + reply.status.status, reply));\n                logger_1.log.trace('message rejected');\n            }\n            else {\n                request.resolve(reply);\n            }\n        }\n    }\n    storeRequest(id, resolve, reject) {\n        let requestDescriptor = {\n            resolve: resolve,\n            reject: reject,\n            timeout: setTimeout(() => {\n                logger_1.log.trace('request', id, 'is timed out');\n                reject(new twilsockerror_1.TwilsockError('Twilsock: request timeout: ' + id));\n            }, REQUEST_TIMEOUT)\n        };\n        this.activeRequests.set(id, requestDescriptor);\n    }\n    shutdown() {\n        this.activeRequests.forEach((descriptor) => {\n            clearTimeout(descriptor.timeout);\n            descriptor.reject(new twilsockerror_1.TwilsockError('Twilsock: request cancelled by user'));\n        });\n        this.activeRequests.clear();\n    }\n    async sendInit() {\n        logger_1.log.trace('sendInit');\n        let metadata = metadata_1.Metadata.getMetadata(this.config);\n        let message = new Messages.Init(this.config.token, this.config.continuationToken, metadata, this.config.initRegistrations, this.config.tweaks);\n        let response = await this.sendWithReply(message);\n        return new Messages.InitReply(response.id, response.header.continuation_token, response.header.continuation_token_status, response.header.offline_storage, response.header.init_registrations, response.header.debug_info, new Set(response.header.capabilities));\n    }\n    sendClose() {\n        let message = new Messages.Close();\n        //@todo send telemetry AnyEventsIncludingUnfinished\n        this.send(message);\n    }\n    sendWithReply(header, payload) {\n        return new Promise((resolve, reject) => {\n            let id = this.send(header, payload);\n            this.storeRequest(id, resolve, reject);\n        });\n    }\n    send(header, payload) {\n        header.id = header.id || `TM${uuid_1.v4()}`;\n        let message = parser_1.Parser.createPacket(header, preparePayload(payload));\n        try {\n            this.channel.send(message);\n            return header.id;\n        }\n        catch (e) {\n            logger_1.log.debug('failed to send ', header, e);\n            logger_1.log.trace(e.stack);\n            throw e;\n        }\n    }\n}\nexports.PacketInterface = PacketInterface;\n"]},"metadata":{},"sourceType":"script"}