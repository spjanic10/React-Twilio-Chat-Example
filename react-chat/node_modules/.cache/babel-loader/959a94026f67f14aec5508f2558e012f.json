{"ast":null,"code":"\"use strict\";\n\nvar _assertThisInitialized = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get2 = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _regeneratorRuntime = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncMap = exports.SyncMapImpl = void 0;\n\nvar sanitize_1 = require(\"./utils/sanitize\");\n\nvar uri_1 = require(\"./utils/uri\");\n\nvar syncerror_1 = require(\"./utils/syncerror\");\n\nvar logger_1 = require(\"./utils/logger\");\n\nvar entity_1 = require(\"./entity\");\n\nvar mapitem_1 = require(\"./mapitem\");\n\nvar paginator_1 = require(\"./paginator\");\n\nvar cache_1 = require(\"./cache\");\n\nvar mergingqueue_1 = require(\"./mergingqueue\");\n\nvar closeable_1 = require(\"./closeable\");\n\nvar SyncMapImpl = /*#__PURE__*/function (_entity_1$SyncEntity) {\n  _inherits(SyncMapImpl, _entity_1$SyncEntity);\n\n  var _super = _createSuper(SyncMapImpl);\n\n  /**\n   * @private\n   */\n  function SyncMapImpl(services, descriptor, removalHandler) {\n    var _this;\n\n    _classCallCheck(this, SyncMapImpl);\n\n    _this = _super.call(this, services, removalHandler);\n\n    var updateRequestReducer = function updateRequestReducer(acc, input) {\n      return typeof input.ttl === 'number' ? {\n        ttl: input.ttl\n      } : acc;\n    };\n\n    _this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n    _this.cache = new cache_1.Cache();\n    _this.descriptor = descriptor;\n    _this.descriptor.date_updated = new Date(_this.descriptor.date_updated);\n\n    if (descriptor.items) {\n      descriptor.items.forEach(function (itemDescriptor) {\n        itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\n\n        _this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\n      });\n    }\n\n    return _this;\n  } // private props\n\n\n  _createClass(SyncMapImpl, [{\n    key: \"uri\",\n    get: function get() {\n      return this.descriptor.url;\n    }\n  }, {\n    key: \"links\",\n    get: function get() {\n      return this.descriptor.links;\n    }\n  }, {\n    key: \"revision\",\n    get: function get() {\n      return this.descriptor.revision;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.descriptor.last_event_id;\n    }\n  }, {\n    key: \"dateExpires\",\n    get: function get() {\n      return this.descriptor.date_expires;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return 'map';\n    } // below properties are specific to Insights only\n\n  }, {\n    key: \"indexName\",\n    get: function get() {\n      return undefined;\n    }\n  }, {\n    key: \"queryString\",\n    get: function get() {\n      return undefined;\n    } // public props, documented along with class description\n\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.descriptor.sid;\n    }\n  }, {\n    key: \"uniqueName\",\n    get: function get() {\n      return this.descriptor.unique_name || null;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.descriptor.date_updated;\n    }\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, value, itemMetadataUpdates) {\n        var _this2 = this;\n\n        var input;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                input = itemMetadataUpdates || {};\n                sanitize_1.validateOptionalTtl(input.ttl);\n                return _context.abrupt(\"return\", this.updateMergingQueue.squashAndAdd(key, input, function (input) {\n                  return _this2._putItemUnconditionally(key, value, input.ttl);\n                }));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function set(_x, _x2, _x3) {\n        return _set.apply(this, arguments);\n      }\n\n      return set;\n    }()\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.cache.has(key)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this.cache.get(key));\n\n              case 4:\n                return _context2.abrupt(\"return\", this._getItemFromServer(key));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function get(_x4) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"_getItemFromServer\",\n    value: function () {\n      var _getItemFromServer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.queryItems({\n                  key: key\n                });\n\n              case 2:\n                result = _context3.sent;\n\n                if (!(result.items.length < 1)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                throw new syncerror_1.SyncError(\"No item with key \".concat(key, \" found\"), 404, 54201);\n\n              case 7:\n                return _context3.abrupt(\"return\", result.items[0]);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _getItemFromServer(_x5) {\n        return _getItemFromServer2.apply(this, arguments);\n      }\n\n      return _getItemFromServer;\n    }()\n  }, {\n    key: \"mutate\",\n    value: function () {\n      var _mutate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(key, mutator, itemMetadataUpdates) {\n        var _this3 = this;\n\n        var input;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                input = itemMetadataUpdates || {};\n                sanitize_1.validateOptionalTtl(input.ttl);\n                return _context4.abrupt(\"return\", this.updateMergingQueue.add(key, input, function (input) {\n                  return _this3._putItemWithIfMatch(key, mutator, input.ttl);\n                }));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function mutate(_x6, _x7, _x8) {\n        return _mutate.apply(this, arguments);\n      }\n\n      return mutate;\n    }()\n  }, {\n    key: \"update\",\n    value: function () {\n      var _update2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(key, obj, itemMetadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.mutate(key, function (remote) {\n                  return Object.assign(remote, obj);\n                }, itemMetadataUpdates));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function update(_x9, _x10, _x11) {\n        return _update2.apply(this, arguments);\n      }\n\n      return update;\n    }()\n  }, {\n    key: \"_putItemUnconditionally\",\n    value: function () {\n      var _putItemUnconditionally2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(key, data, ttl) {\n        var result, item;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this._putItemToServer(key, data, undefined, ttl);\n\n              case 2:\n                result = _context6.sent;\n                item = result.item;\n\n                this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n                return _context6.abrupt(\"return\", this.cache.get(item.key));\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _putItemUnconditionally(_x12, _x13, _x14) {\n        return _putItemUnconditionally2.apply(this, arguments);\n      }\n\n      return _putItemUnconditionally;\n    }()\n  }, {\n    key: \"_putItemWithIfMatch\",\n    value: function () {\n      var _putItemWithIfMatch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(key, mutatorFunction, ttl) {\n        var currentItem, data, ifMatch, result, item;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.get(key).catch(function (error) {\n                  if (error.status === 404) {\n                    // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\n                    return new mapitem_1.MapItem({\n                      key: key,\n                      data: {},\n                      last_event_id: -1,\n                      revision: '-1',\n                      url: null,\n                      date_updated: null,\n                      date_expires: null\n                    });\n                  } else {\n                    throw error;\n                  }\n                });\n\n              case 2:\n                currentItem = _context7.sent;\n                data = mutatorFunction(sanitize_1.deepClone(currentItem.value));\n\n                if (!data) {\n                  _context7.next = 26;\n                  break;\n                }\n\n                ifMatch = currentItem.revision;\n                _context7.prev = 6;\n                _context7.next = 9;\n                return this._putItemToServer(key, data, ifMatch, ttl);\n\n              case 9:\n                result = _context7.sent;\n                item = result.item;\n\n                this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n\n                return _context7.abrupt(\"return\", this.cache.get(item.key));\n\n              case 15:\n                _context7.prev = 15;\n                _context7.t0 = _context7[\"catch\"](6);\n\n                if (!(_context7.t0.status === 412)) {\n                  _context7.next = 23;\n                  break;\n                }\n\n                _context7.next = 20;\n                return this._getItemFromServer(key);\n\n              case 20:\n                return _context7.abrupt(\"return\", this._putItemWithIfMatch(key, mutatorFunction, ttl));\n\n              case 23:\n                throw _context7.t0;\n\n              case 24:\n                _context7.next = 27;\n                break;\n\n              case 26:\n                return _context7.abrupt(\"return\", currentItem);\n\n              case 27:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[6, 15]]);\n      }));\n\n      function _putItemWithIfMatch(_x15, _x16, _x17) {\n        return _putItemWithIfMatch2.apply(this, arguments);\n      }\n\n      return _putItemWithIfMatch;\n    }()\n  }, {\n    key: \"_putItemToServer\",\n    value: function () {\n      var _putItemToServer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(key, data, ifMatch, ttl) {\n        var url, requestBody, response, mapItemDescriptor, added;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                url = new uri_1.UriBuilder(this.links.items).pathSegment(key).build();\n                requestBody = {\n                  data: data\n                };\n\n                if (ttl !== undefined) {\n                  requestBody.ttl = ttl;\n                }\n\n                _context8.prev = 3;\n                _context8.next = 6;\n                return this.services.network.put(url, requestBody, ifMatch);\n\n              case 6:\n                response = _context8.sent;\n                mapItemDescriptor = response.body;\n                mapItemDescriptor.data = data; // The server does not return the data in the response\n\n                mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\n                added = response.status.code === 201;\n                return _context8.abrupt(\"return\", {\n                  added: added,\n                  item: mapItemDescriptor\n                });\n\n              case 14:\n                _context8.prev = 14;\n                _context8.t0 = _context8[\"catch\"](3);\n\n                if (_context8.t0.status === 404) {\n                  this.onRemoved(false);\n                }\n\n                throw _context8.t0;\n\n              case 18:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[3, 14]]);\n      }));\n\n      function _putItemToServer(_x18, _x19, _x20, _x21) {\n        return _putItemToServer2.apply(this, arguments);\n      }\n\n      return _putItemToServer;\n    }()\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(key) {\n        var item, response;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!(typeof key === 'undefined')) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw new Error('Key argument is invalid');\n\n              case 2:\n                _context9.next = 4;\n                return this.get(key);\n\n              case 4:\n                item = _context9.sent;\n                _context9.next = 7;\n                return this.services.network.delete(item.uri);\n\n              case 7:\n                response = _context9.sent;\n\n                this._handleItemRemoved(key, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n\n              case 9:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function remove(_x22) {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"queryItems\",\n    value: function () {\n      var _queryItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(args) {\n        var _this4 = this;\n\n        var uri, response, items, meta;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                args = args || {};\n                uri = new uri_1.UriBuilder(this.links.items).queryParam('From', args.from).queryParam('PageSize', args.limit).queryParam('Key', args.key).queryParam('PageToken', args.pageToken).queryParam('Order', args.order).build();\n                _context10.next = 4;\n                return this.services.network.get(uri);\n\n              case 4:\n                response = _context10.sent;\n                items = response.body.items.map(function (el) {\n                  el.date_updated = new Date(el.date_updated);\n\n                  var itemInCache = _this4.cache.get(el.key);\n\n                  if (itemInCache) {\n                    _this4._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n                  } else {\n                    _this4.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\n                  }\n\n                  return _this4.cache.get(el.key);\n                });\n                meta = response.body.meta;\n                return _context10.abrupt(\"return\", new paginator_1.Paginator(items, function (pageToken) {\n                  return _this4.queryItems({\n                    pageToken: pageToken\n                  });\n                }, meta.previous_token, meta.next_token));\n\n              case 8:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function queryItems(_x23) {\n        return _queryItems.apply(this, arguments);\n      }\n\n      return queryItems;\n    }()\n  }, {\n    key: \"getItems\",\n    value: function () {\n      var _getItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(args) {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                args = args || {};\n                sanitize_1.validatePageSize(args.pageSize);\n                args.limit = args.pageSize || args.limit || 50;\n                args.order = args.order || 'asc';\n                return _context11.abrupt(\"return\", this.queryItems(args));\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getItems(_x24) {\n        return _getItems.apply(this, arguments);\n      }\n\n      return getItems;\n    }()\n  }, {\n    key: \"shouldIgnoreEvent\",\n    value: function shouldIgnoreEvent(key, eventId) {\n      return this.cache.isKnown(key, eventId);\n    }\n    /**\n     * Handle update from the server\n     * @private\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update(update, isStrictlyOrdered) {\n      update.date_created = new Date(update.date_created);\n\n      switch (update.type) {\n        case 'map_item_added':\n        case 'map_item_updated':\n          {\n            this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\n            update.type === 'map_item_added', true);\n          }\n          break;\n\n        case 'map_item_removed':\n          {\n            this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\n          }\n          break;\n\n        case 'map_removed':\n          {\n            this.onRemoved(false);\n          }\n          break;\n      }\n\n      if (isStrictlyOrdered) {\n        this._advanceLastEventId(update.id, update.map_revision);\n      }\n    }\n  }, {\n    key: \"_advanceLastEventId\",\n    value: function _advanceLastEventId(eventId, revision) {\n      if (this.lastEventId < eventId) {\n        this.descriptor.last_event_id = eventId;\n\n        if (revision) {\n          this.descriptor.revision = revision;\n        }\n      }\n    }\n  }, {\n    key: \"_updateRootDateUpdated\",\n    value: function _updateRootDateUpdated(dateUpdated) {\n      if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n        this.descriptor.date_updated = dateUpdated;\n        this.services.storage.update(this.type, this.sid, this.uniqueName, {\n          date_updated: dateUpdated\n        });\n      }\n    }\n  }, {\n    key: \"_handleItemMutated\",\n    value: function _handleItemMutated(key, url, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n      if (this.shouldIgnoreEvent(key, lastEventId)) {\n        logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n        return;\n      } else {\n        this._updateRootDateUpdated(dateUpdated);\n\n        var item = this.cache.get(key);\n\n        if (!item) {\n          item = new mapitem_1.MapItem({\n            key: key,\n            url: url,\n            last_event_id: lastEventId,\n            revision: revision,\n            data: value,\n            date_updated: dateUpdated,\n            date_expires: dateExpires\n          });\n          this.cache.store(key, item, lastEventId);\n          this.emitItemMutationEvent(item, remote, added);\n        } else {\n          item.update(lastEventId, revision, value, dateUpdated);\n          this.cache.store(key, item, lastEventId);\n\n          if (dateExpires !== undefined) {\n            item.updateDateExpires(dateExpires);\n          }\n\n          this.emitItemMutationEvent(item, remote, false);\n        }\n      }\n    }\n  }, {\n    key: \"emitItemMutationEvent\",\n    value: function emitItemMutationEvent(item, remote, added) {\n      var eventName = added ? 'itemAdded' : 'itemUpdated';\n      this.broadcastEventToListeners(eventName, {\n        item: item,\n        isLocal: !remote\n      });\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_handleItemRemoved\",\n    value: function _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\n      this._updateRootDateUpdated(dateUpdated);\n\n      this.cache.delete(key, eventId);\n      this.broadcastEventToListeners('itemRemoved', {\n        key: key,\n        isLocal: !remote,\n        value: oldData\n      });\n    }\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved(locally) {\n      this._unsubscribe();\n\n      this.removalHandler(this.type, this.sid, this.uniqueName);\n      this.broadcastEventToListeners('removed', {\n        isLocal: locally\n      });\n    }\n  }, {\n    key: \"setTtl\",\n    value: function () {\n      var _setTtl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(ttl) {\n        var requestBody, response;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                sanitize_1.validateMandatoryTtl(ttl);\n                _context12.prev = 1;\n                requestBody = {\n                  ttl: ttl\n                };\n                _context12.next = 5;\n                return this.services.network.post(this.uri, requestBody);\n\n              case 5:\n                response = _context12.sent;\n                this.descriptor.date_expires = response.body.date_expires;\n                _context12.next = 13;\n                break;\n\n              case 9:\n                _context12.prev = 9;\n                _context12.t0 = _context12[\"catch\"](1);\n\n                if (_context12.t0.status === 404) {\n                  this.onRemoved(false);\n                }\n\n                throw _context12.t0;\n\n              case 13:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[1, 9]]);\n      }));\n\n      function setTtl(_x25) {\n        return _setTtl.apply(this, arguments);\n      }\n\n      return setTtl;\n    }()\n  }, {\n    key: \"setItemTtl\",\n    value: function () {\n      var _setItemTtl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(key, ttl) {\n        var existingItem, requestBody, response;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                sanitize_1.validateMandatoryTtl(ttl);\n                _context13.next = 3;\n                return this.get(key);\n\n              case 3:\n                existingItem = _context13.sent;\n                requestBody = {\n                  ttl: ttl\n                };\n                _context13.next = 7;\n                return this.services.network.post(existingItem.uri, requestBody);\n\n              case 7:\n                response = _context13.sent;\n                existingItem.updateDateExpires(response.body.date_expires);\n\n              case 9:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function setItemTtl(_x26, _x27) {\n        return _setItemTtl.apply(this, arguments);\n      }\n\n      return setItemTtl;\n    }()\n  }, {\n    key: \"removeMap\",\n    value: function () {\n      var _removeMap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.services.network.delete(this.uri);\n\n              case 2:\n                this.onRemoved(true);\n\n              case 3:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function removeMap() {\n        return _removeMap.apply(this, arguments);\n      }\n\n      return removeMap;\n    }()\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'map';\n    }\n  }]);\n\n  return SyncMapImpl;\n}(entity_1.SyncEntity);\n\nexports.SyncMapImpl = SyncMapImpl;\n/**\n * @class\n * @alias Map\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\n * programmer to this map on creation. Unique among other Maps.\n * @property {Date} dateUpdated Date when the Map was last updated.\n *\n * @fires Map#removed\n * @fires Map#itemAdded\n * @fires Map#itemRemoved\n * @fires Map#itemUpdated\n */\n\nvar SyncMap = /*#__PURE__*/function (_closeable_1$Closeabl) {\n  _inherits(SyncMap, _closeable_1$Closeabl);\n\n  var _super2 = _createSuper(SyncMap);\n\n  function SyncMap(syncMapImpl) {\n    var _this5;\n\n    _classCallCheck(this, SyncMap);\n\n    _this5 = _super2.call(this);\n    _this5.syncMapImpl = syncMapImpl;\n\n    _this5.syncMapImpl.attach(_assertThisInitialized(_this5));\n\n    return _this5;\n  } // private props\n\n\n  _createClass(SyncMap, [{\n    key: \"uri\",\n    get: function get() {\n      return this.syncMapImpl.uri;\n    }\n  }, {\n    key: \"links\",\n    get: function get() {\n      return this.syncMapImpl.links;\n    }\n  }, {\n    key: \"revision\",\n    get: function get() {\n      return this.syncMapImpl.revision;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.syncMapImpl.lastEventId;\n    }\n  }, {\n    key: \"dateExpires\",\n    get: function get() {\n      return this.syncMapImpl.dateExpires;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return SyncMapImpl.type;\n    } // public props, documented along with class description\n\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.syncMapImpl.sid;\n    }\n  }, {\n    key: \"uniqueName\",\n    get: function get() {\n      return this.syncMapImpl.uniqueName;\n    }\n  }, {\n    key: \"dateUpdated\",\n    get: function get() {\n      return this.syncMapImpl.dateUpdated;\n    }\n    /**\n     * Add a new item to the map with the given key:value pair. Overwrites any value that might already exist at that key.\n     * @param {String} key Unique item identifier.\n     * @param {Object} value Value to be set.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known value.\n     * @public\n     * @example\n     * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('Map Item set() successful, item value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item set() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(key, value, itemMetadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context15.abrupt(\"return\", this.syncMapImpl.set(key, value, itemMetadataUpdates));\n\n              case 2:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function set(_x28, _x29, _x30) {\n        return _set2.apply(this, arguments);\n      }\n\n      return set;\n    }()\n    /**\n     * Retrieve an item by key.\n     * @param {String} key Identifies the desired item.\n     * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\n     * This promise will be rejected if item was not found.\n     * @public\n     * @example\n     * map.get('myKey')\n     *   .then(function(item) {\n     *     console.log('Map Item get() successful, item value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item get() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(key) {\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context16.abrupt(\"return\", this.syncMapImpl.get(key));\n\n              case 2:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function get(_x31) {\n        return _get3.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Schedules a modification to this Map Item that will apply a mutation function.\n     * If no Item with the given key exists, it will first be created, having the default value (<code>{}</code>).\n     * @param {String} key Selects the map item to be mutated.\n     * @param {Map~Mutator} mutator A function that outputs a new value based on the existing value.\n     * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\n     * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\n     * by this function.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\n     * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('Map Item mutate() successful, new value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item mutate() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"mutate\",\n    value: function () {\n      var _mutate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(key, mutator, itemMetadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context17.abrupt(\"return\", this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates));\n\n              case 2:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function mutate(_x32, _x33, _x34) {\n        return _mutate2.apply(this, arguments);\n      }\n\n      return mutate;\n    }()\n    /**\n     * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\n     * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\n     * into it.\n     * This is equivalent to\n     * <pre>\n     * map.mutate('myKey', function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {String} key Selects the map item to update.\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\n     * @public\n     * @example\n     * // Say, the Map Item (key: 'myKey') value is { name: 'John Smith' }\n     * map.update('myKey', { age: 34 }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     // Now the Map Item value is { name: 'John Smith', age: 34 }\n     *     console.log('Map Item update() successful, new value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item update() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"update\",\n    value: function () {\n      var _update3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(key, obj, itemMetadataUpdates) {\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context18.abrupt(\"return\", this.syncMapImpl.update(key, obj, itemMetadataUpdates));\n\n              case 2:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function update(_x35, _x36, _x37) {\n        return _update3.apply(this, arguments);\n      }\n\n      return update;\n    }()\n    /**\n     * Delete an item, given its key.\n     * @param {String} key Selects the item to delete.\n     * @returns {Promise<void>} A promise to remove an item.\n     * The promise will be rejected if 'key' is undefined or an item was not found.\n     * @public\n     * @example\n     * map.remove('myKey')\n     *   .then(function() {\n     *     console.log('Map Item remove() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item remove() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(key) {\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context19.abrupt(\"return\", this.syncMapImpl.remove(key));\n\n              case 2:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function remove(_x38) {\n        return _remove2.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n    /**\n     * Get a complete list of items from the map.\n     * @param {Object} [args] Arguments for query.\n     * @param {String} [args.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on args.order.\n     * @param {Number} [args.pageSize=50] Result page size.\n     * @param {'asc'|'desc'} [args.order='asc'] Lexicographical order of results.\n     * @return {Promise<Paginator<MapItem>>}\n     * @public\n     * @example\n     * var pageHandler = function(paginator) {\n     *   paginator.items.forEach(function(item) {\n     *     console.log('Item ' + item.key + ': ', item.value);\n     *   });\n     *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n     *                                : null;\n     * };\n     * map.getItems({ from: 'myKey', order: 'asc' })\n     *   .then(pageHandler)\n     *   .catch(function(error) {\n     *     console.error('Map getItems() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"getItems\",\n    value: function () {\n      var _getItems2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(args) {\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context20.abrupt(\"return\", this.syncMapImpl.getItems(args));\n\n              case 2:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function getItems(_x39) {\n        return _getItems2.apply(this, arguments);\n      }\n\n      return getItems;\n    }()\n    /**\n     * Update the time-to-live of the map.\n     * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * map.setTtl(3600)\n     *   .then(function() {\n     *     console.log('Map setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map setTtl() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"setTtl\",\n    value: function () {\n      var _setTtl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(ttl) {\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context21.abrupt(\"return\", this.syncMapImpl.setTtl(ttl));\n\n              case 2:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function setTtl(_x40) {\n        return _setTtl2.apply(this, arguments);\n      }\n\n      return setTtl;\n    }()\n    /**\n     * Update the time-to-live of a map item.\n     * @param {Number} key Item key.\n     * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * map.setItemTtl('myKey', 86400)\n     *   .then(function() {\n     *     console.log('Map setItemTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map setItemTtl() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"setItemTtl\",\n    value: function () {\n      var _setItemTtl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(key, ttl) {\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                this.ensureNotClosed();\n                return _context22.abrupt(\"return\", this.syncMapImpl.setItemTtl(key, ttl));\n\n              case 2:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function setItemTtl(_x41, _x42) {\n        return _setItemTtl2.apply(this, arguments);\n      }\n\n      return setItemTtl;\n    }()\n    /**\n     * Delete this map. It will be impossible to restore it.\n     * @return {Promise<void>} A promise that resolves when the map has been deleted.\n     * @public\n     * @example\n     * map.removeMap()\n     *   .then(function() {\n     *     console.log('Map removeMap() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map removeMap() failed', error);\n     *   });\n     */\n\n  }, {\n    key: \"removeMap\",\n    value: function () {\n      var _removeMap2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                this.ensureNotClosed();\n                _context23.next = 3;\n                return this.syncMapImpl.removeMap();\n\n              case 3:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function removeMap() {\n        return _removeMap2.apply(this, arguments);\n      }\n\n      return removeMap;\n    }()\n    /**\n     * Conclude work with the map instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this map will continue operating and receiving events normally.\n     * @public\n     * @example\n     * map.close();\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      _get2(_getPrototypeOf(SyncMap.prototype), \"close\", this).call(this);\n\n      this.syncMapImpl.detach(this.listenerUuid);\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return SyncMapImpl.type;\n    }\n  }]);\n\n  return SyncMap;\n}(closeable_1.Closeable);\n\nexports.SyncMap = SyncMap;\nexports.default = SyncMap;\n/**\n * Contains Map Item metadata.\n * @typedef {Object} Map#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback Map~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n\n/**\n * Fired when a new item appears in the map, whether its creator was local or remote.\n * @event Map#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * map.on('itemAdded', function(args) {\n *   console.log('Map item ' + args.item.key + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event Map#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * map.on('itemUpdated', function(args) {\n *   console.log('Map item ' + args.item.key + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map item is removed, whether the remover was local or remote.\n * @event Map#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * map.on('itemRemoved', function(args) {\n *   console.log('Map item ' + args.key + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n\n/**\n * Fired when a map is deleted entirely, by any actor local or remote.\n * @event Map#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\n * @example\n * map.on('removed', function(args) {\n *   console.log('Map ' + map.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilio-sync/lib/syncmap.js"],"names":["Object","defineProperty","exports","value","SyncMap","SyncMapImpl","sanitize_1","require","uri_1","syncerror_1","logger_1","entity_1","mapitem_1","paginator_1","cache_1","mergingqueue_1","closeable_1","services","descriptor","removalHandler","updateRequestReducer","acc","input","ttl","updateMergingQueue","NamespacedMergingQueue","cache","Cache","date_updated","Date","items","forEach","itemDescriptor","store","key","MapItem","last_event_id","url","links","revision","date_expires","undefined","sid","unique_name","itemMetadataUpdates","validateOptionalTtl","squashAndAdd","_putItemUnconditionally","has","get","_getItemFromServer","queryItems","result","length","SyncError","mutator","add","_putItemWithIfMatch","obj","mutate","remote","assign","data","_putItemToServer","item","_handleItemMutated","added","mutatorFunction","catch","error","status","currentItem","deepClone","ifMatch","UriBuilder","pathSegment","build","requestBody","network","put","response","mapItemDescriptor","body","code","onRemoved","Error","delete","uri","_handleItemRemoved","args","queryParam","from","limit","pageToken","order","map","el","itemInCache","meta","Paginator","previous_token","next_token","validatePageSize","pageSize","eventId","isKnown","update","isStrictlyOrdered","date_created","type","item_key","item_url","id","item_revision","item_data","_advanceLastEventId","map_revision","lastEventId","dateUpdated","getTime","storage","uniqueName","dateExpires","shouldIgnoreEvent","default","trace","_updateRootDateUpdated","emitItemMutationEvent","updateDateExpires","eventName","broadcastEventToListeners","isLocal","oldData","locally","_unsubscribe","validateMandatoryTtl","post","existingItem","SyncEntity","syncMapImpl","attach","ensureNotClosed","set","remove","getItems","setTtl","setItemTtl","removeMap","detach","listenerUuid","Closeable"],"mappings":"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FX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;iFACI;AAAA;AAAA;AAAA;AAAA;AACI,qBAAKsH,eAAL;AADJ;AAAA,uBAEU,KAAKF,WAAL,CAAiBQ,SAAjB,EAFV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,iBAAQ;AACJ;;AACA,WAAKR,WAAL,CAAiBS,MAAjB,CAAwB,KAAKC,YAA7B;AACH;;;SAhOD,eAAkB;AACd,aAAOhJ,WAAW,CAACwG,IAAnB;AACH;;;;EAxBiB7F,WAAW,CAACsI,S;;AAwPlCpJ,OAAO,CAACE,OAAR,GAAkBA,OAAlB;AACAF,OAAO,CAAC0H,OAAR,GAAkBxH,OAAlB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyncMap = exports.SyncMapImpl = void 0;\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst entity_1 = require(\"./entity\");\nconst mapitem_1 = require(\"./mapitem\");\nconst paginator_1 = require(\"./paginator\");\nconst cache_1 = require(\"./cache\");\nconst mergingqueue_1 = require(\"./mergingqueue\");\nconst closeable_1 = require(\"./closeable\");\nclass SyncMapImpl extends entity_1.SyncEntity {\n    /**\n     * @private\n     */\n    constructor(services, descriptor, removalHandler) {\n        super(services, removalHandler);\n        const updateRequestReducer = (acc, input) => (typeof input.ttl === 'number') ? { ttl: input.ttl }\n            : acc;\n        this.updateMergingQueue = new mergingqueue_1.NamespacedMergingQueue(updateRequestReducer);\n        this.cache = new cache_1.Cache();\n        this.descriptor = descriptor;\n        this.descriptor.date_updated = new Date(this.descriptor.date_updated);\n        if (descriptor.items) {\n            descriptor.items.forEach(itemDescriptor => {\n                itemDescriptor.date_updated = new Date(itemDescriptor.date_updated);\n                this.cache.store(itemDescriptor.key, new mapitem_1.MapItem(itemDescriptor), itemDescriptor.last_event_id);\n            });\n        }\n    }\n    // private props\n    get uri() {\n        return this.descriptor.url;\n    }\n    get links() {\n        return this.descriptor.links;\n    }\n    get revision() {\n        return this.descriptor.revision;\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get dateExpires() {\n        return this.descriptor.date_expires;\n    }\n    static get type() {\n        return 'map';\n    }\n    get type() {\n        return 'map';\n    }\n    // below properties are specific to Insights only\n    get indexName() {\n        return undefined;\n    }\n    get queryString() {\n        return undefined;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.descriptor.sid;\n    }\n    get uniqueName() {\n        return this.descriptor.unique_name || null;\n    }\n    get dateUpdated() {\n        return this.descriptor.date_updated;\n    }\n    async set(key, value, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.squashAndAdd(key, input, (input) => this._putItemUnconditionally(key, value, input.ttl));\n    }\n    async get(key) {\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        else {\n            return this._getItemFromServer(key);\n        }\n    }\n    async _getItemFromServer(key) {\n        let result = await this.queryItems({ key: key });\n        if (result.items.length < 1) {\n            throw new syncerror_1.SyncError(`No item with key ${key} found`, 404, 54201);\n        }\n        else {\n            return result.items[0];\n        }\n    }\n    async mutate(key, mutator, itemMetadataUpdates) {\n        const input = itemMetadataUpdates || {};\n        sanitize_1.validateOptionalTtl(input.ttl);\n        return this.updateMergingQueue.add(key, input, (input) => this._putItemWithIfMatch(key, mutator, input.ttl));\n    }\n    async update(key, obj, itemMetadataUpdates) {\n        return this.mutate(key, remote => Object.assign(remote, obj), itemMetadataUpdates);\n    }\n    async _putItemUnconditionally(key, data, ttl) {\n        const result = await this._putItemToServer(key, data, undefined, ttl);\n        const item = result.item;\n        this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n        return this.cache.get(item.key);\n    }\n    async _putItemWithIfMatch(key, mutatorFunction, ttl) {\n        const currentItem = await this.get(key)\n            .catch(error => {\n            if (error.status === 404) {\n                // PUT /Items/myKey with `If-Match: -1` acts as \"put if not exists\"\n                return new mapitem_1.MapItem({ key: key, data: {}, last_event_id: -1, revision: '-1', url: null, date_updated: null, date_expires: null });\n            }\n            else {\n                throw error;\n            }\n        });\n        let data = mutatorFunction(sanitize_1.deepClone(currentItem.value));\n        if (data) {\n            let ifMatch = currentItem.revision;\n            try {\n                const result = await this._putItemToServer(key, data, ifMatch, ttl);\n                const item = result.item;\n                this._handleItemMutated(item.key, item.url, item.last_event_id, item.revision, item.data, item.date_updated, item.date_expires, result.added, false);\n                return this.cache.get(item.key);\n            }\n            catch (error) {\n                if (error.status === 412) {\n                    await this._getItemFromServer(key);\n                    return this._putItemWithIfMatch(key, mutatorFunction, ttl);\n                }\n                else {\n                    throw error;\n                }\n            }\n        }\n        else {\n            return currentItem;\n        }\n    }\n    async _putItemToServer(key, data, ifMatch, ttl) {\n        const url = new uri_1.UriBuilder(this.links.items).pathSegment(key).build();\n        const requestBody = { data };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        try {\n            const response = await this.services.network.put(url, requestBody, ifMatch);\n            const mapItemDescriptor = response.body;\n            mapItemDescriptor.data = data; // The server does not return the data in the response\n            mapItemDescriptor.date_updated = new Date(mapItemDescriptor.date_updated);\n            const added = response.status.code === 201;\n            return { added, item: mapItemDescriptor };\n        }\n        catch (error) {\n            if (error.status === 404) {\n                this.onRemoved(false);\n            }\n            throw error;\n        }\n    }\n    async remove(key) {\n        if (typeof key === 'undefined') {\n            throw new Error('Key argument is invalid');\n        }\n        let item = await this.get(key);\n        let response = await this.services.network.delete(item.uri);\n        this._handleItemRemoved(key, response.body.last_event_id, undefined, new Date(response.body.date_updated), false);\n    }\n    /**\n     * @private\n     */\n    async queryItems(args) {\n        args = args || {};\n        const uri = new uri_1.UriBuilder(this.links.items)\n            .queryParam('From', args.from)\n            .queryParam('PageSize', args.limit)\n            .queryParam('Key', args.key)\n            .queryParam('PageToken', args.pageToken)\n            .queryParam('Order', args.order)\n            .build();\n        let response = await this.services.network.get(uri);\n        let items = response.body.items.map(el => {\n            el.date_updated = new Date(el.date_updated);\n            let itemInCache = this.cache.get(el.key);\n            if (itemInCache) {\n                this._handleItemMutated(el.key, el.url, el.last_event_id, el.revision, el.data, el.date_updated, el.date_expires, false, true);\n            }\n            else {\n                this.cache.store(el.key, new mapitem_1.MapItem(el), el.last_event_id);\n            }\n            return this.cache.get(el.key);\n        });\n        const meta = response.body.meta;\n        return new paginator_1.Paginator(items, pageToken => this.queryItems({ pageToken }), meta.previous_token, meta.next_token);\n    }\n    async getItems(args) {\n        args = args || {};\n        sanitize_1.validatePageSize(args.pageSize);\n        args.limit = args.pageSize || args.limit || 50;\n        args.order = args.order || 'asc';\n        return this.queryItems(args);\n    }\n    shouldIgnoreEvent(key, eventId) {\n        return this.cache.isKnown(key, eventId);\n    }\n    /**\n     * Handle update from the server\n     * @private\n     */\n    _update(update, isStrictlyOrdered) {\n        update.date_created = new Date(update.date_created);\n        switch (update.type) {\n            case 'map_item_added':\n            case 'map_item_updated':\n                {\n                    this._handleItemMutated(update.item_key, update.item_url, update.id, update.item_revision, update.item_data, update.date_created, undefined, // orchestration events do not include date_expires\n                    update.type === 'map_item_added', true);\n                }\n                break;\n            case 'map_item_removed':\n                {\n                    this._handleItemRemoved(update.item_key, update.id, update.item_data, update.date_created, true);\n                }\n                break;\n            case 'map_removed':\n                {\n                    this.onRemoved(false);\n                }\n                break;\n        }\n        if (isStrictlyOrdered) {\n            this._advanceLastEventId(update.id, update.map_revision);\n        }\n    }\n    _advanceLastEventId(eventId, revision) {\n        if (this.lastEventId < eventId) {\n            this.descriptor.last_event_id = eventId;\n            if (revision) {\n                this.descriptor.revision = revision;\n            }\n        }\n    }\n    _updateRootDateUpdated(dateUpdated) {\n        if (!this.descriptor.date_updated || dateUpdated.getTime() > this.descriptor.date_updated.getTime()) {\n            this.descriptor.date_updated = dateUpdated;\n            this.services.storage.update(this.type, this.sid, this.uniqueName, { date_updated: dateUpdated });\n        }\n    }\n    _handleItemMutated(key, url, lastEventId, revision, value, dateUpdated, dateExpires, added, remote) {\n        if (this.shouldIgnoreEvent(key, lastEventId)) {\n            logger_1.default.trace('Item ', key, ' update skipped, current:', this.lastEventId, ', remote:', lastEventId);\n            return;\n        }\n        else {\n            this._updateRootDateUpdated(dateUpdated);\n            let item = this.cache.get(key);\n            if (!item) {\n                item = new mapitem_1.MapItem({ key: key, url, last_event_id: lastEventId, revision, data: value, date_updated: dateUpdated, date_expires: dateExpires });\n                this.cache.store(key, item, lastEventId);\n                this.emitItemMutationEvent(item, remote, added);\n            }\n            else {\n                item.update(lastEventId, revision, value, dateUpdated);\n                this.cache.store(key, item, lastEventId);\n                if (dateExpires !== undefined) {\n                    item.updateDateExpires(dateExpires);\n                }\n                this.emitItemMutationEvent(item, remote, false);\n            }\n        }\n    }\n    emitItemMutationEvent(item, remote, added) {\n        let eventName = added ? 'itemAdded' : 'itemUpdated';\n        this.broadcastEventToListeners(eventName, { item: item, isLocal: !remote });\n    }\n    /**\n     * @private\n     */\n    _handleItemRemoved(key, eventId, oldData, dateUpdated, remote) {\n        this._updateRootDateUpdated(dateUpdated);\n        this.cache.delete(key, eventId);\n        this.broadcastEventToListeners('itemRemoved', { key: key, isLocal: !remote, value: oldData });\n    }\n    onRemoved(locally) {\n        this._unsubscribe();\n        this.removalHandler(this.type, this.sid, this.uniqueName);\n        this.broadcastEventToListeners('removed', { isLocal: locally });\n    }\n    async setTtl(ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        try {\n            const requestBody = { ttl };\n            const response = await this.services.network.post(this.uri, requestBody);\n            this.descriptor.date_expires = response.body.date_expires;\n        }\n        catch (error) {\n            if (error.status === 404) {\n                this.onRemoved(false);\n            }\n            throw error;\n        }\n    }\n    async setItemTtl(key, ttl) {\n        sanitize_1.validateMandatoryTtl(ttl);\n        let existingItem = await this.get(key);\n        const requestBody = { ttl };\n        const response = await this.services.network.post(existingItem.uri, requestBody);\n        existingItem.updateDateExpires(response.body.date_expires);\n    }\n    async removeMap() {\n        await this.services.network.delete(this.uri);\n        this.onRemoved(true);\n    }\n}\nexports.SyncMapImpl = SyncMapImpl;\n/**\n * @class\n * @alias Map\n * @classdesc Represents a Sync Map, which stores an unordered set of key:value pairs.\n * Use the {@link Client#map} method to obtain a reference to a Sync Map.\n * @property {String} sid An immutable identifier (a SID) assigned by the system on creation.\n * @property {String} [uniqueName=null] - An optional immutable identifier that may be assigned by the\n * programmer to this map on creation. Unique among other Maps.\n * @property {Date} dateUpdated Date when the Map was last updated.\n *\n * @fires Map#removed\n * @fires Map#itemAdded\n * @fires Map#itemRemoved\n * @fires Map#itemUpdated\n */\nclass SyncMap extends closeable_1.Closeable {\n    constructor(syncMapImpl) {\n        super();\n        this.syncMapImpl = syncMapImpl;\n        this.syncMapImpl.attach(this);\n    }\n    // private props\n    get uri() {\n        return this.syncMapImpl.uri;\n    }\n    get links() {\n        return this.syncMapImpl.links;\n    }\n    get revision() {\n        return this.syncMapImpl.revision;\n    }\n    get lastEventId() {\n        return this.syncMapImpl.lastEventId;\n    }\n    get dateExpires() {\n        return this.syncMapImpl.dateExpires;\n    }\n    static get type() {\n        return SyncMapImpl.type;\n    }\n    get type() {\n        return SyncMapImpl.type;\n    }\n    // public props, documented along with class description\n    get sid() {\n        return this.syncMapImpl.sid;\n    }\n    get uniqueName() {\n        return this.syncMapImpl.uniqueName;\n    }\n    get dateUpdated() {\n        return this.syncMapImpl.dateUpdated;\n    }\n    /**\n     * Add a new item to the map with the given key:value pair. Overwrites any value that might already exist at that key.\n     * @param {String} key Unique item identifier.\n     * @param {Object} value Value to be set.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} Newly added item, or modified one if already exists, with the latest known value.\n     * @public\n     * @example\n     * map.set('myKey', { name: 'John Smith' }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('Map Item set() successful, item value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item set() failed', error);\n     *   });\n     */\n    async set(key, value, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.set(key, value, itemMetadataUpdates);\n    }\n    /**\n     * Retrieve an item by key.\n     * @param {String} key Identifies the desired item.\n     * @returns {Promise<MapItem>} A promise that resolves when the item has been fetched.\n     * This promise will be rejected if item was not found.\n     * @public\n     * @example\n     * map.get('myKey')\n     *   .then(function(item) {\n     *     console.log('Map Item get() successful, item value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item get() failed', error);\n     *   });\n     */\n    async get(key) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.get(key);\n    }\n    /**\n     * Schedules a modification to this Map Item that will apply a mutation function.\n     * If no Item with the given key exists, it will first be created, having the default value (<code>{}</code>).\n     * @param {String} key Selects the map item to be mutated.\n     * @param {Map~Mutator} mutator A function that outputs a new value based on the existing value.\n     * May be called multiple times, particularly if this Map Item is modified concurrently by remote code.\n     * If the mutation ultimately succeeds, the Map Item will have made the particular transition described\n     * by this function.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} Resolves with the most recent item state, the output of a successful\n     * mutation or a state that prompted graceful cancellation (mutator returned <code>null</code>).\n     * @public\n     * @example\n     * var mutatorFunction = function(currentValue) {\n     *     currentValue.viewCount = (currentValue.viewCount || 0) + 1;\n     *     return currentValue;\n     * };\n     * map.mutate('myKey', mutatorFunction, { ttl: 86400 })\n     *   .then(function(item) {\n     *     console.log('Map Item mutate() successful, new value:', item.value)\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item mutate() failed', error);\n     *   });\n     */\n    async mutate(key, mutator, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.mutate(key, mutator, itemMetadataUpdates);\n    }\n    /**\n     * Modify a map item by appending new fields (or by overwriting existing ones) with the values from\n     * the provided Object. Creates a new item if no item by this key exists, copying all given fields and values\n     * into it.\n     * This is equivalent to\n     * <pre>\n     * map.mutate('myKey', function(currentValue) {\n     *   return Object.assign(currentValue, obj));\n     * });\n     * </pre>\n     * @param {String} key Selects the map item to update.\n     * @param {Object} obj Specifies the particular (top-level) attributes that will receive new values.\n     * @param {Map#ItemMetadata} [itemMetadataUpdates] New item metadata.\n     * @returns {Promise<MapItem>} A promise resolving to the modified item in its new state.\n     * @public\n     * @example\n     * // Say, the Map Item (key: 'myKey') value is { name: 'John Smith' }\n     * map.update('myKey', { age: 34 }, { ttl: 86400 })\n     *   .then(function(item) {\n     *     // Now the Map Item value is { name: 'John Smith', age: 34 }\n     *     console.log('Map Item update() successful, new value:', item.value);\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item update() failed', error);\n     *   });\n     */\n    async update(key, obj, itemMetadataUpdates) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.update(key, obj, itemMetadataUpdates);\n    }\n    /**\n     * Delete an item, given its key.\n     * @param {String} key Selects the item to delete.\n     * @returns {Promise<void>} A promise to remove an item.\n     * The promise will be rejected if 'key' is undefined or an item was not found.\n     * @public\n     * @example\n     * map.remove('myKey')\n     *   .then(function() {\n     *     console.log('Map Item remove() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map Item remove() failed', error);\n     *   });\n     */\n    async remove(key) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.remove(key);\n    }\n    /**\n     * Get a complete list of items from the map.\n     * @param {Object} [args] Arguments for query.\n     * @param {String} [args.from] Item key, which should be used as the offset. If undefined, starts from the beginning or end depending on args.order.\n     * @param {Number} [args.pageSize=50] Result page size.\n     * @param {'asc'|'desc'} [args.order='asc'] Lexicographical order of results.\n     * @return {Promise<Paginator<MapItem>>}\n     * @public\n     * @example\n     * var pageHandler = function(paginator) {\n     *   paginator.items.forEach(function(item) {\n     *     console.log('Item ' + item.key + ': ', item.value);\n     *   });\n     *   return paginator.hasNextPage ? paginator.nextPage().then(pageHandler)\n     *                                : null;\n     * };\n     * map.getItems({ from: 'myKey', order: 'asc' })\n     *   .then(pageHandler)\n     *   .catch(function(error) {\n     *     console.error('Map getItems() failed', error);\n     *   });\n     */\n    async getItems(args) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.getItems(args);\n    }\n    /**\n     * Update the time-to-live of the map.\n     * @param {Number} ttl Specifies the TTL in seconds after which the map is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * map.setTtl(3600)\n     *   .then(function() {\n     *     console.log('Map setTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map setTtl() failed', error);\n     *   });\n     */\n    async setTtl(ttl) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.setTtl(ttl);\n    }\n    /**\n     * Update the time-to-live of a map item.\n     * @param {Number} key Item key.\n     * @param {Number} ttl Specifies the TTL in seconds after which the map item is subject to automatic deletion. The value 0 means infinity.\n     * @return {Promise<void>} A promise that resolves after the TTL update was successful.\n     * @public\n     * @example\n     * map.setItemTtl('myKey', 86400)\n     *   .then(function() {\n     *     console.log('Map setItemTtl() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map setItemTtl() failed', error);\n     *   });\n     */\n    async setItemTtl(key, ttl) {\n        this.ensureNotClosed();\n        return this.syncMapImpl.setItemTtl(key, ttl);\n    }\n    /**\n     * Delete this map. It will be impossible to restore it.\n     * @return {Promise<void>} A promise that resolves when the map has been deleted.\n     * @public\n     * @example\n     * map.removeMap()\n     *   .then(function() {\n     *     console.log('Map removeMap() successful');\n     *   })\n     *   .catch(function(error) {\n     *     console.error('Map removeMap() failed', error);\n     *   });\n     */\n    async removeMap() {\n        this.ensureNotClosed();\n        await this.syncMapImpl.removeMap();\n    }\n    /**\n     * Conclude work with the map instance and remove all event listeners attached to it.\n     * Any subsequent operation on this object will be rejected with error.\n     * Other local copies of this map will continue operating and receiving events normally.\n     * @public\n     * @example\n     * map.close();\n     */\n    close() {\n        super.close();\n        this.syncMapImpl.detach(this.listenerUuid);\n    }\n}\nexports.SyncMap = SyncMap;\nexports.default = SyncMap;\n/**\n * Contains Map Item metadata.\n * @typedef {Object} Map#ItemMetadata\n * @property {Number} [ttl] Specifies the time-to-live in seconds after which the map item is subject to automatic deletion.\n * The value 0 means infinity.\n */\n/**\n * Applies a transformation to the item value. May be called multiple times on the\n * same datum in case of collisions with remote code.\n * @callback Map~Mutator\n * @param {Object} currentValue The current value of the item in the cloud.\n * @return {Object} The desired new value for the item or <code>null</code> to gracefully cancel the mutation.\n */\n/**\n * Fired when a new item appears in the map, whether its creator was local or remote.\n * @event Map#itemAdded\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Added item.\n * @param {Boolean} args.isLocal Equals 'true' if item was added by local actor, 'false' otherwise.\n * @example\n * map.on('itemAdded', function(args) {\n *   console.log('Map item ' + args.item.key + ' was added');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map item is updated (not added or removed, but changed), whether the updater was local or remote.\n * @event Map#itemUpdated\n * @param {Object} args Arguments provided with the event.\n * @param {MapItem} args.item Updated item.\n * @param {Boolean} args.isLocal Equals 'true' if item was updated by local actor, 'false' otherwise.\n * @example\n * map.on('itemUpdated', function(args) {\n *   console.log('Map item ' + args.item.key + ' was updated');\n *   console.log('args.item.value:', args.item.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map item is removed, whether the remover was local or remote.\n * @event Map#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @param {Boolean} args.isLocal Equals 'true' if item was removed by local actor, 'false' otherwise.\n * @param {Object} args.value In case item was removed by a remote actor, contains a snapshot of item data before removal.\n * @example\n * map.on('itemRemoved', function(args) {\n *   console.log('Map item ' + args.key + ' was removed');\n *   console.log('args.value:', args.value);\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n/**\n * Fired when a map is deleted entirely, by any actor local or remote.\n * @event Map#removed\n * @param {Object} args Arguments provided with the event.\n * @param {Boolean} args.isLocal Equals 'true' if map was removed by local actor, 'false' otherwise.\n * @example\n * map.on('removed', function(args) {\n *   console.log('Map ' + map.sid + ' was removed');\n *   console.log('args.isLocal:', args.isLocal);\n * });\n */\n"]},"metadata":{},"sourceType":"script"}