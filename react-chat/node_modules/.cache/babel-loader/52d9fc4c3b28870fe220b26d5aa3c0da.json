{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncClient = exports.Client = void 0;\n\nvar events_1 = require(\"events\");\n\nvar twilsock_1 = require(\"twilsock\");\n\nvar twilio_notifications_1 = require(\"twilio-notifications\");\n\nvar uri_1 = require(\"./utils/uri\");\n\nvar syncerror_1 = require(\"./utils/syncerror\");\n\nvar sanitize_1 = require(\"./utils/sanitize\");\n\nvar logger_1 = require(\"./utils/logger\");\n\nvar configuration_1 = require(\"./configuration\");\n\nvar subscriptions_1 = require(\"./subscriptions\");\n\nvar router_1 = require(\"./router\");\n\nvar network_1 = require(\"./services/network\");\n\nvar syncdocument_1 = require(\"./syncdocument\");\n\nvar synclist_1 = require(\"./synclist\");\n\nvar syncmap_1 = require(\"./syncmap\");\n\nvar clientInfo_1 = require(\"./clientInfo\");\n\nvar entitiesCache_1 = require(\"./entitiesCache\");\n\nvar storage_1 = require(\"./services/storage\");\n\nvar syncstream_1 = require(\"./streams/syncstream\");\n\nvar livequery_1 = require(\"./livequery\");\n\nvar livequery_2 = require(\"./livequery\");\n\nvar SYNC_PRODUCT_ID = 'data_sync';\n\nvar SDK_VERSION = require('../package.json').version;\n\nfunction decompose(arg) {\n  if (!arg) {\n    return {\n      mode: 'create_new'\n    };\n  } else if (typeof arg === 'string') {\n    return {\n      id: arg,\n      mode: 'open_or_create'\n    };\n  } else {\n    sanitize_1.validateOptionalTtl(arg.ttl);\n    sanitize_1.validateId(arg.id);\n    var mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');\n    return Object.assign(Object.assign({}, arg), {\n      mode: mode\n    });\n  }\n}\n/**\n * @class Client\n * @classdesc\n * Client for the Twilio Sync service.\n * @constructor\n * @param {String} token - Twilio access token.\n * @param {Client#ClientOptions} [options] - Options to customize the Client.\n * @example\n * // Using NPM\n * var SyncClient = require('twilio-sync');\n * var syncClient = new SyncClient(token, { logLevel: 'debug' });\n *\n * // Using CDN\n * var SyncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });\n *\n * @property {Client#ConnectionState} connectionState - Contains current service connection state.\n * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].\n */\n\n\nvar Client = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Client, _events_1$EventEmitte);\n\n  var _super = _createSuper(Client);\n\n  function Client(fpaToken) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Client);\n\n    _this = _super.call(this);\n\n    if (!fpaToken) {\n      throw new Error('Sync library needs a valid Twilio token to be passed');\n    }\n\n    if (options.hasOwnProperty('logLevel')) {\n      logger_1.default.setLevel(options.logLevel);\n    } else {\n      logger_1.default.setLevel('silent');\n    }\n\n    var productId = options.productId = options.productId || SYNC_PRODUCT_ID; // Filling ClientMetadata\n\n    options.clientMetadata = options.clientMetadata || {};\n\n    if (!options.clientMetadata.hasOwnProperty('type')) {\n      options.clientMetadata.type = 'sync';\n    }\n\n    if (!options.clientMetadata.hasOwnProperty('sdk')) {\n      options.clientMetadata.sdk = 'JS';\n      options.clientMetadata.sdkv = SDK_VERSION;\n    }\n\n    var twilsock = options.twilsockClient = options.twilsockClient || new twilsock_1.Twilsock(fpaToken, productId, options);\n    twilsock.on('tokenAboutToExpire', function (ttl) {\n      return _this.emit('tokenAboutToExpire', ttl);\n    });\n    twilsock.on('tokenExpired', function () {\n      return _this.emit('tokenExpired');\n    });\n    twilsock.on('connectionError', function (err) {\n      return _this.emit('connectionError', err);\n    });\n    var notifications = options.notificationsClient = options.notificationsClient || new twilio_notifications_1.Notifications(fpaToken, options);\n    var config = new configuration_1.Configuration(options);\n    var network = new network_1.NetworkService(new clientInfo_1.ClientInfo(SDK_VERSION), config, twilsock);\n    var storage = new storage_1.SessionStorage(config);\n    _this.localStorageId = null;\n    twilsock.connect();\n    _this.services = {\n      config: config,\n      twilsock: twilsock,\n      notifications: notifications,\n      network: network,\n      storage: storage,\n      router: null,\n      subscriptions: null\n    };\n    var subscriptions = new subscriptions_1.Subscriptions(_this.services);\n    var router = new router_1.Router({\n      config: config,\n      subscriptions: subscriptions,\n      notifications: notifications\n    });\n    _this.services.router = router;\n    _this.services.subscriptions = subscriptions;\n    _this.entities = new entitiesCache_1.EntitiesCache();\n    notifications.on('connectionStateChanged', function () {\n      _this.emit('connectionStateChanged', _this.services.notifications.connectionState);\n    });\n    return _this;\n  }\n  /**\n   * Current version of Sync client.\n   * @name Client#version\n   * @type String\n   * @readonly\n   */\n\n\n  _createClass(Client, [{\n    key: \"connectionState\",\n    get: function get() {\n      return this.services.notifications.connectionState;\n    }\n    /**\n     * Returns promise which resolves when library is correctly initialized\n     * Or throws if initialization is impossible\n     * @private\n     */\n\n  }, {\n    key: \"ensureReady\",\n    value: function () {\n      var _ensureReady = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var storageSettings;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.services.config.sessionStorageEnabled) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                _context.prev = 2;\n                _context.next = 5;\n                return this.services.twilsock.storageId();\n\n              case 5:\n                storageSettings = _context.sent;\n                this.services.storage.updateStorageId(storageSettings.id);\n                _context.next = 12;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](2);\n                logger_1.default.warn('Failed to initialize storage', _context.t0);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 9]]);\n      }));\n\n      function ensureReady() {\n        return _ensureReady.apply(this, arguments);\n      }\n\n      return ensureReady;\n    }()\n  }, {\n    key: \"storeRootInSessionCache\",\n    value: function storeRootInSessionCache(type, id, value) {\n      // can't store without id\n      if (!this.services.config.sessionStorageEnabled || !id) {\n        return;\n      }\n\n      var valueToStore = sanitize_1.deepClone(value);\n\n      if (type === synclist_1.SyncList.type || type === syncmap_1.SyncMap.type) {\n        valueToStore['last_event_id'] = null;\n        delete valueToStore['items'];\n      }\n\n      this.services.storage.store(type, id, valueToStore);\n    }\n  }, {\n    key: \"readRootFromSessionCache\",\n    value: function readRootFromSessionCache(type, id) {\n      if (!this.services.config.sessionStorageEnabled || !id) {\n        return null;\n      }\n\n      return this.services.storage.read(type, id);\n    }\n  }, {\n    key: \"_get\",\n    value: function () {\n      var _get2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(baseUri, id) {\n        var optimistic,\n            uri,\n            response,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                optimistic = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false;\n\n                if (id) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new syncerror_1.SyncError(\"Cannot get entity without id\", 404);\n\n              case 3:\n                uri = new uri_1.UriBuilder(baseUri).pathSegment(id).queryParam('Include', optimistic ? 'items' : undefined).build();\n                _context2.next = 6;\n                return this.services.network.get(uri);\n\n              case 6:\n                response = _context2.sent;\n                return _context2.abrupt(\"return\", response.body);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _get(_x, _x2) {\n        return _get2.apply(this, arguments);\n      }\n\n      return _get;\n    }()\n  }, {\n    key: \"_createDocument\",\n    value: function _createDocument(id, data, ttl) {\n      var requestBody = {\n        unique_name: id,\n        data: data || {}\n      };\n\n      if (ttl !== undefined) {\n        requestBody.ttl = ttl;\n      }\n\n      return this.services.network.post(this.services.config.documentsUri, requestBody).then(function (response) {\n        response.body.data = requestBody.data;\n        return response.body;\n      });\n    }\n  }, {\n    key: \"_getDocument\",\n    value: function () {\n      var _getDocument2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(id) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.readRootFromSessionCache(syncdocument_1.SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _getDocument(_x3) {\n        return _getDocument2.apply(this, arguments);\n      }\n\n      return _getDocument;\n    }()\n  }, {\n    key: \"_createList\",\n    value: function _createList(id, purpose, context, ttl) {\n      var requestBody = {\n        unique_name: id,\n        purpose: purpose,\n        context: context\n      };\n\n      if (ttl !== undefined) {\n        requestBody.ttl = ttl;\n      }\n\n      return this.services.network.post(this.services.config.listsUri, requestBody).then(function (response) {\n        return response.body;\n      });\n    }\n  }, {\n    key: \"_getList\",\n    value: function () {\n      var _getList2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(id) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this.readRootFromSessionCache(synclist_1.SyncList.type, id) || this._get(this.services.config.listsUri, id));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _getList(_x4) {\n        return _getList2.apply(this, arguments);\n      }\n\n      return _getList;\n    }()\n  }, {\n    key: \"_createMap\",\n    value: function _createMap(id, ttl) {\n      var requestBody = {\n        unique_name: id\n      };\n\n      if (ttl !== undefined) {\n        requestBody.ttl = ttl;\n      }\n\n      return this.services.network.post(this.services.config.mapsUri, requestBody).then(function (response) {\n        return response.body;\n      });\n    }\n  }, {\n    key: \"_getMap\",\n    value: function () {\n      var _getMap2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(id) {\n        var optimistic,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                optimistic = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : false;\n                return _context5.abrupt(\"return\", this.readRootFromSessionCache(syncmap_1.SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));\n\n              case 2:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _getMap(_x5) {\n        return _getMap2.apply(this, arguments);\n      }\n\n      return _getMap;\n    }()\n  }, {\n    key: \"_getStream\",\n    value: function () {\n      var _getStream2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(id) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.readRootFromSessionCache(syncstream_1.SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _getStream(_x6) {\n        return _getStream2.apply(this, arguments);\n      }\n\n      return _getStream;\n    }()\n  }, {\n    key: \"_createStream\",\n    value: function () {\n      var _createStream2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(id, ttl) {\n        var requestBody, response;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                requestBody = {\n                  unique_name: id\n                };\n\n                if (ttl !== undefined) {\n                  requestBody.ttl = ttl;\n                }\n\n                _context7.next = 4;\n                return this.services.network.post(this.services.config.streamsUri, requestBody);\n\n              case 4:\n                response = _context7.sent;\n                return _context7.abrupt(\"return\", response.body);\n\n              case 6:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _createStream(_x7, _x8) {\n        return _createStream2.apply(this, arguments);\n      }\n\n      return _createStream;\n    }()\n  }, {\n    key: \"_getLiveQuery\",\n    value: function _getLiveQuery(sid) {\n      return this.readRootFromSessionCache(livequery_1.LiveQuery.type, sid);\n    }\n  }, {\n    key: \"getCached\",\n    value: function getCached(id, type) {\n      if (id) {\n        return this.entities.get(id, type) || null;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"removeFromCacheAndSession\",\n    value: function removeFromCacheAndSession(type, sid, uniqueName) {\n      this.entities.remove(sid);\n\n      if (this.services.config.sessionStorageEnabled) {\n        this.services.storage.remove(type, sid, uniqueName);\n      }\n    }\n    /**\n     * Read or create a Sync Document.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Sync Document - opens a Document with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new Document with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<Document>} a promise which resolves after the Document is successfully read (or created).\n     * This promise may reject if the Document could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.document('MyDocument')\n     *   .then(function(document) {\n     *     console.log('Successfully opened a Document. SID: ' + document.sid);\n     *     document.on('updated', function(event) {\n     *       console.log('Received updated event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n\n  }, {\n    key: \"document\",\n    value: function () {\n      var _document = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(arg) {\n        var _this2 = this;\n\n        var opts, docDescriptor, docFromInMemoryCache, syncDocumentImpl;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.ensureReady();\n\n              case 2:\n                opts = decompose(arg);\n\n                if (!(opts.mode === 'create_new')) {\n                  _context8.next = 9;\n                  break;\n                }\n\n                _context8.next = 6;\n                return this._createDocument(opts.id, opts.value, opts.ttl);\n\n              case 6:\n                docDescriptor = _context8.sent;\n                _context8.next = 39;\n                break;\n\n              case 9:\n                docFromInMemoryCache = this.getCached(opts.id, syncdocument_1.SyncDocument.type);\n\n                if (!docFromInMemoryCache) {\n                  _context8.next = 14;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", new syncdocument_1.SyncDocument(docFromInMemoryCache));\n\n              case 14:\n                _context8.prev = 14;\n                _context8.next = 17;\n                return this._getDocument(opts.id);\n\n              case 17:\n                docDescriptor = _context8.sent;\n                _context8.next = 39;\n                break;\n\n              case 20:\n                _context8.prev = 20;\n                _context8.t0 = _context8[\"catch\"](14);\n\n                if (!(_context8.t0.status !== 404 || opts.mode === 'open_existing')) {\n                  _context8.next = 26;\n                  break;\n                }\n\n                throw _context8.t0;\n\n              case 26:\n                _context8.prev = 26;\n                _context8.next = 29;\n                return this._createDocument(opts.id, opts.value, opts.ttl);\n\n              case 29:\n                docDescriptor = _context8.sent;\n                _context8.next = 39;\n                break;\n\n              case 32:\n                _context8.prev = 32;\n                _context8.t1 = _context8[\"catch\"](26);\n\n                if (!(_context8.t1.status === 409)) {\n                  _context8.next = 38;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", this.document(arg));\n\n              case 38:\n                throw _context8.t1;\n\n              case 39:\n                this.storeRootInSessionCache(syncdocument_1.SyncDocument.type, opts.id, docDescriptor);\n                syncDocumentImpl = new syncdocument_1.SyncDocumentImpl(this.services, docDescriptor, function (type, sid, uniqueName) {\n                  return _this2.removeFromCacheAndSession(type, sid, uniqueName);\n                });\n                syncDocumentImpl = this.entities.store(syncDocumentImpl);\n                return _context8.abrupt(\"return\", new syncdocument_1.SyncDocument(syncDocumentImpl));\n\n              case 43:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[14, 20], [26, 32]]);\n      }));\n\n      function document(_x9) {\n        return _document.apply(this, arguments);\n      }\n\n      return document;\n    }()\n    /**\n     * Read or create a Sync Map.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Sync Map - opens a Map with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new Map with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<Map>} a promise which resolves after the Map is successfully read (or created).\n     * This promise may reject if the Map could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.map('MyMap')\n     *   .then(function(map) {\n     *     console.log('Successfully opened a Map. SID: ' + map.sid);\n     *     map.on('itemUpdated', function(event) {\n     *       console.log('Received itemUpdated event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n\n  }, {\n    key: \"map\",\n    value: function () {\n      var _map = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(arg) {\n        var _this3 = this;\n\n        var opts, mapDescriptor, mapFromInMemoryCache, syncMapImpl;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.ensureReady();\n\n              case 2:\n                opts = decompose(arg);\n\n                if (!(opts.mode === 'create_new')) {\n                  _context9.next = 9;\n                  break;\n                }\n\n                _context9.next = 6;\n                return this._createMap(opts.id, opts.ttl);\n\n              case 6:\n                mapDescriptor = _context9.sent;\n                _context9.next = 39;\n                break;\n\n              case 9:\n                mapFromInMemoryCache = this.getCached(opts.id, syncmap_1.SyncMap.type);\n\n                if (!mapFromInMemoryCache) {\n                  _context9.next = 14;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", new syncmap_1.SyncMap(mapFromInMemoryCache));\n\n              case 14:\n                _context9.prev = 14;\n                _context9.next = 17;\n                return this._getMap(opts.id, opts.includeItems);\n\n              case 17:\n                mapDescriptor = _context9.sent;\n                _context9.next = 39;\n                break;\n\n              case 20:\n                _context9.prev = 20;\n                _context9.t0 = _context9[\"catch\"](14);\n\n                if (!(_context9.t0.status !== 404 || opts.mode === 'open_existing')) {\n                  _context9.next = 26;\n                  break;\n                }\n\n                throw _context9.t0;\n\n              case 26:\n                _context9.prev = 26;\n                _context9.next = 29;\n                return this._createMap(opts.id, opts.ttl);\n\n              case 29:\n                mapDescriptor = _context9.sent;\n                _context9.next = 39;\n                break;\n\n              case 32:\n                _context9.prev = 32;\n                _context9.t1 = _context9[\"catch\"](26);\n\n                if (!(_context9.t1.status === 409)) {\n                  _context9.next = 38;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", this.map(arg));\n\n              case 38:\n                throw _context9.t1;\n\n              case 39:\n                this.storeRootInSessionCache(syncmap_1.SyncMap.type, opts.id, mapDescriptor);\n                syncMapImpl = new syncmap_1.SyncMapImpl(this.services, mapDescriptor, function (type, sid, uniqueName) {\n                  return _this3.removeFromCacheAndSession(type, sid, uniqueName);\n                });\n                syncMapImpl = this.entities.store(syncMapImpl);\n                return _context9.abrupt(\"return\", new syncmap_1.SyncMap(syncMapImpl));\n\n              case 43:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[14, 20], [26, 32]]);\n      }));\n\n      function map(_x10) {\n        return _map.apply(this, arguments);\n      }\n\n      return map;\n    }()\n    /**\n     * Read or create a Sync List.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Sync List - opens a List with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new List with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<List>} a promise which resolves after the List is successfully read (or created).\n     * This promise may reject if the List could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.list('MyList')\n     *   .then(function(list) {\n     *     console.log('Successfully opened a List. SID: ' + list.sid);\n     *     list.on('itemAdded', function(event) {\n     *       console.log('Received itemAdded event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n\n  }, {\n    key: \"list\",\n    value: function () {\n      var _list = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(arg) {\n        var _this4 = this;\n\n        var opts, listDescriptor, listFromInMemoryCache, syncListImpl;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.ensureReady();\n\n              case 2:\n                opts = decompose(arg);\n\n                if (!(opts.mode === 'create_new')) {\n                  _context10.next = 9;\n                  break;\n                }\n\n                _context10.next = 6;\n                return this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n\n              case 6:\n                listDescriptor = _context10.sent;\n                _context10.next = 39;\n                break;\n\n              case 9:\n                listFromInMemoryCache = this.getCached(opts.id, synclist_1.SyncList.type);\n\n                if (!listFromInMemoryCache) {\n                  _context10.next = 14;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", new synclist_1.SyncList(listFromInMemoryCache));\n\n              case 14:\n                _context10.prev = 14;\n                _context10.next = 17;\n                return this._getList(opts.id);\n\n              case 17:\n                listDescriptor = _context10.sent;\n                _context10.next = 39;\n                break;\n\n              case 20:\n                _context10.prev = 20;\n                _context10.t0 = _context10[\"catch\"](14);\n\n                if (!(_context10.t0.status !== 404 || opts.mode === 'open_existing')) {\n                  _context10.next = 26;\n                  break;\n                }\n\n                throw _context10.t0;\n\n              case 26:\n                _context10.prev = 26;\n                _context10.next = 29;\n                return this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n\n              case 29:\n                listDescriptor = _context10.sent;\n                _context10.next = 39;\n                break;\n\n              case 32:\n                _context10.prev = 32;\n                _context10.t1 = _context10[\"catch\"](26);\n\n                if (!(_context10.t1.status === 409)) {\n                  _context10.next = 38;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", this.list(arg));\n\n              case 38:\n                throw _context10.t1;\n\n              case 39:\n                this.storeRootInSessionCache(synclist_1.SyncList.type, opts.id, listDescriptor);\n                syncListImpl = new synclist_1.SyncListImpl(this.services, listDescriptor, function (type, sid, uniqueName) {\n                  return _this4.removeFromCacheAndSession(type, sid, uniqueName);\n                });\n                syncListImpl = this.entities.store(syncListImpl);\n                return _context10.abrupt(\"return\", new synclist_1.SyncList(syncListImpl));\n\n              case 43:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[14, 20], [26, 32]]);\n      }));\n\n      function list(_x11) {\n        return _list.apply(this, arguments);\n      }\n\n      return list;\n    }()\n    /**\n     * Read or create a Sync Message Stream.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Stream - opens a Stream with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new Stream with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<Stream>} a promise which resolves after the Stream is successfully read (or created).\n     * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.\n     * This promise may reject if the Stream could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.stream('MyStream')\n     *   .then(function(stream) {\n     *     console.log('Successfully opened a Message Stream. SID: ' + stream.sid);\n     *     stream.on('messagePublished', function(event) {\n     *       console.log('Received messagePublished event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n\n  }, {\n    key: \"stream\",\n    value: function () {\n      var _stream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(arg) {\n        var _this5 = this;\n\n        var opts, streamDescriptor, streamFromInMemoryCache, streamRemovalHandler, syncStreamImpl;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.ensureReady();\n\n              case 2:\n                opts = decompose(arg);\n\n                if (!(opts.mode === 'create_new')) {\n                  _context11.next = 9;\n                  break;\n                }\n\n                _context11.next = 6;\n                return this._createStream(opts.id, opts.ttl);\n\n              case 6:\n                streamDescriptor = _context11.sent;\n                _context11.next = 39;\n                break;\n\n              case 9:\n                streamFromInMemoryCache = this.getCached(opts.id, syncstream_1.SyncStream.type);\n\n                if (!streamFromInMemoryCache) {\n                  _context11.next = 14;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", new syncstream_1.SyncStream(streamFromInMemoryCache));\n\n              case 14:\n                _context11.prev = 14;\n                _context11.next = 17;\n                return this._getStream(opts.id);\n\n              case 17:\n                streamDescriptor = _context11.sent;\n                _context11.next = 39;\n                break;\n\n              case 20:\n                _context11.prev = 20;\n                _context11.t0 = _context11[\"catch\"](14);\n\n                if (!(_context11.t0.status !== 404 || opts.mode === 'open_existing')) {\n                  _context11.next = 26;\n                  break;\n                }\n\n                throw _context11.t0;\n\n              case 26:\n                _context11.prev = 26;\n                _context11.next = 29;\n                return this._createStream(opts.id, opts.ttl);\n\n              case 29:\n                streamDescriptor = _context11.sent;\n                _context11.next = 39;\n                break;\n\n              case 32:\n                _context11.prev = 32;\n                _context11.t1 = _context11[\"catch\"](26);\n\n                if (!(_context11.t1.status === 409)) {\n                  _context11.next = 38;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", this.stream(arg));\n\n              case 38:\n                throw _context11.t1;\n\n              case 39:\n                this.storeRootInSessionCache(syncstream_1.SyncStream.type, opts.id, streamDescriptor);\n\n                streamRemovalHandler = function streamRemovalHandler(type, sid, uniqueName) {\n                  return _this5.removeFromCacheAndSession(type, sid, uniqueName);\n                };\n\n                syncStreamImpl = new syncstream_1.SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);\n                syncStreamImpl = this.entities.store(syncStreamImpl);\n                return _context11.abrupt(\"return\", new syncstream_1.SyncStream(syncStreamImpl));\n\n              case 44:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[14, 20], [26, 32]]);\n      }));\n\n      function stream(_x12) {\n        return _stream.apply(this, arguments);\n      }\n\n      return stream;\n    }()\n    /**\n     * Gracefully shutdown the libray\n     * Currently it is not properly implemented and being used only in tests\n     * But should be made a part of public API\n     * @private\n     */\n\n  }, {\n    key: \"shutdown\",\n    value: function () {\n      var _shutdown = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.services.subscriptions.shutdown();\n\n              case 2:\n                _context12.next = 4;\n                return this.services.twilsock.disconnect();\n\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function shutdown() {\n        return _shutdown.apply(this, arguments);\n      }\n\n      return shutdown;\n    }()\n    /**\n     * Set new authentication token.\n     * @param {String} token New token to set.\n     * @return {Promise<void>}\n     * @public\n     */\n\n  }, {\n    key: \"updateToken\",\n    value: function updateToken(token) {\n      if (!token) {\n        return Promise.reject(new Error('A valid Twilio token should be provided'));\n      }\n\n      return this.services.twilsock.updateToken(token);\n    }\n    /**\n     * For Flex customers only. Establishes a long-running query against Flex data wherein the returned\n     * result set is updated whenever new (or updated) records match the given expression. Updated results\n     * are presented row-by-row according to the lifetime of the returned LiveQuery object.\n     *\n     * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\n     * @param queryExpression {String} A query expression to be executed against the given data index.\n     * Please review <a href=\"https://www.twilio.com/docs/sync/live-query\" target=\"_blank\">Live Query Language</a>\n     * page for Sync Client limits and full list of operators currently supported in query expressions.\n     *\n     * @return {Promise<LiveQuery>} a promise that resolves when the query has been successfully executed.\n     * @public\n     * @example\n     * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == \"Bob\"')\n     *     .then(function(args) {\n     *        console.log('Subscribed to live data updates for worker Bob');\n     *        let items = args.getItems();\n     *        Object.entries(items).forEach(([key, value]) => {\n     *          console.log('Search result item key: ' + key);\n     *          console.log('Search result item value: ' + value);\n     *        });\n     *     })\n     *     .catch(function(err) {\n     *        console.log('Error when subscribing to live updates for worker Bob', err);\n     *     });\n     */\n\n  }, {\n    key: \"liveQuery\",\n    value: function () {\n      var _liveQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(indexName, queryExpression) {\n        var _this6 = this;\n\n        var queryUri, response, liveQueryImpl, descriptor, liveQueryRemovalHandler;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.ensureReady();\n\n              case 2:\n                if (!(!indexName || typeof indexName !== 'string')) {\n                  _context13.next = 4;\n                  break;\n                }\n\n                throw new Error('Index name must contain a non-empty string value');\n\n              case 4:\n                queryUri = new uri_1.UriBuilder(this.services.config.insightsUri).pathSegment(indexName).pathSegment('Items').build(); // send query to CDS to get server-generated sid and item list\n\n                _context13.next = 7;\n                return livequery_2.queryItems({\n                  network: this.services.network,\n                  uri: queryUri,\n                  queryString: queryExpression,\n                  type: livequery_1.LiveQuery.type\n                });\n\n              case 7:\n                response = _context13.sent;\n                liveQueryImpl = this.getCached(response.query_id, livequery_1.LiveQuery.type);\n\n                if (!liveQueryImpl) {\n                  descriptor = this._getLiveQuery(response.query_id);\n\n                  if (!descriptor) {\n                    descriptor = {\n                      indexName: indexName,\n                      queryExpression: queryExpression,\n                      sid: response.query_id,\n                      queryUri: queryUri,\n                      last_event_id: response.last_event_id\n                    };\n                  }\n\n                  liveQueryRemovalHandler = function liveQueryRemovalHandler(type, sid, uniqueName) {\n                    return _this6.removeFromCacheAndSession(type, sid, uniqueName);\n                  };\n\n                  liveQueryImpl = new livequery_1.LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);\n                }\n\n                this.storeRootInSessionCache(livequery_1.LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);\n                liveQueryImpl = this.entities.store(liveQueryImpl);\n                return _context13.abrupt(\"return\", new livequery_1.LiveQuery(liveQueryImpl));\n\n              case 13:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function liveQuery(_x13, _x14) {\n        return _liveQuery.apply(this, arguments);\n      }\n\n      return liveQuery;\n    }()\n    /**\n     * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly\n     * against the target index.\n     *\n     * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\n     * @return {Promise<InstantQuery>} a promise which resolves after the InstantQuery is successfully created.\n     * @public\n     * @example\n     * syncClient.instantQuery('tr-worker')\n     *    .then(function(q) {\n     *        q.on('searchResult', function(items) {\n     *          Object.entries(items).forEach(([key, value]) => {\n     *             console.log('Search result item key: ' + key);\n     *             console.log('Search result item value: ' + value);\n     *          });\n     *       });\n     *    });\n     */\n\n  }, {\n    key: \"instantQuery\",\n    value: function () {\n      var _instantQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(indexName) {\n        var _this7 = this;\n\n        var liveQueryCreator, search;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.ensureReady();\n\n              case 2:\n                liveQueryCreator = function liveQueryCreator(indexName, queryExpression) {\n                  return _this7.liveQuery(indexName, queryExpression);\n                };\n\n                search = new livequery_1.InstantQuery({\n                  indexName: indexName,\n                  network: this.services.network,\n                  insightsUri: this.services.config.insightsUri,\n                  liveQueryCreator: liveQueryCreator\n                });\n                return _context14.abrupt(\"return\", search);\n\n              case 5:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function instantQuery(_x15) {\n        return _instantQuery.apply(this, arguments);\n      }\n\n      return instantQuery;\n    }()\n  }], [{\n    key: \"version\",\n    get: function get() {\n      return SDK_VERSION;\n    }\n  }]);\n\n  return Client;\n}(events_1.EventEmitter);\n\nexports.Client = Client;\nexports.SyncClient = Client;\nexports.default = Client;\n/**\n * Indicates current state of connection between the client and Sync service.\n * <p>Valid options are as follows:\n * <li>'connecting' - client is offline and connection attempt is in process.\n * <li>'connected' - client is online and ready.\n * <li>'disconnecting' - client is going offline as disconnection is in process.\n * <li>'disconnected' - client is offline and no connection attempt is in process.\n * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.\n * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.\n * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} Client#ConnectionState\n */\n\n/**\n * These options can be passed to Client constructor.\n * @typedef {Object} Client#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace'].\n */\n\n/**\n * Fired when connection state has been changed.\n * @param {Client#ConnectionState} connectionState Contains current service connection state.\n * @event Client#connectionStateChanged\n * @example\n * syncClient.on('connectionStateChanged', function(newState) {\n *   console.log('Received new connection state: ' + newState);\n * });\n */\n\n/**\n * Fired when connection is interrupted by unexpected reason\n * @property {Object} error - connection error details\n * @property {Boolean} error.terminal - twilsock will stop connection attempts\n * @property {String} error.message - root cause\n * @property {Number} [error.httpStatusCode] - http status code if available\n * @property {Number} [error.errorCode] - Twilio public error code if available\n * @event Client#connectionError\n * @example\n * syncClient.on('connectionError', function(connectionError) {\n *   console.log('Connection was interrupted: ' + connectionError.message +\n *     ' (isTerminal: ' + connectionError.terminal')');\n * });\n */\n\n/**\n * Options for opening a Sync Object.\n * @typedef {Object} Client#OpenOptions\n * @property {String} [id] Sync object SID or unique name.\n * @property {'open_or_create' | 'open_existing' | 'create_new'} [mode='open_or_create'] - The mode for opening the Sync object:\n * <li>'open_or_create' - reads a Sync object or creates one if it does not exist.\n * <li>'open_existing' - reads an existing Sync object. The promise is rejected if the object does not exist.\n * <li>'create_new' - creates a new Sync object. If the <i>id</i> property is specified, it will be used as the unique name.\n * @property {Number} [ttl] - The time-to-live of the Sync object in seconds. This is applied only if the object is created.\n * @property {Object} [value={ }] - The initial value for the Sync Document (only applicable to Documents).\n * @example <caption>The following example is applicable to all Sync objects\n * (i.e., <code>syncClient.document(), syncClient.list(), syncClient.map(), syncClient.stream()</code>)</caption>\n * // Attempts to open an existing Document with unique name 'MyDocument'\n * // If no such Document exists, the promise is rejected\n * syncClient.document({\n *     id: 'MyDocument',\n *     mode: 'open_existing'\n *   })\n *   .then(...)\n *   .catch(...);\n *\n * // Attempts to create a new Document with unique name 'MyDocument', TTL of 24 hours and initial value { name: 'John Smith' }\n * // If such a Document already exists, the promise is rejected\n * syncClient.document({\n *     id: 'MyDocument',\n *     mode: 'create_new',\n *     ttl: 86400\n *     value: { name: 'John Smith' } // the `value` property is only applicable for Documents\n *   })\n *   .then(...)\n *   .catch(...);\n */\n\n/**\n * Fired when the access token is about to expire and needs to be updated.\n * The trigger takes place three minutes before the JWT access token expiry.\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\n * @event Client#tokenAboutToExpire\n * @type {void}\n * @example <caption>The following example illustrates access token refresh</caption>\n * syncClient.on('tokenAboutToExpire', function() {\n *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens\n *   var token = '<your-access-token-here>';\n *   syncClient.updateToken(token);\n * });\n */\n\n/**\n * Fired when the access token is expired.\n * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\n * @event Client#tokenExpired\n * @type {void}\n */","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilio-sync/lib/client.js"],"names":["Object","defineProperty","exports","value","SyncClient","Client","events_1","require","twilsock_1","twilio_notifications_1","uri_1","syncerror_1","sanitize_1","logger_1","configuration_1","subscriptions_1","router_1","network_1","syncdocument_1","synclist_1","syncmap_1","clientInfo_1","entitiesCache_1","storage_1","syncstream_1","livequery_1","livequery_2","SYNC_PRODUCT_ID","SDK_VERSION","version","decompose","arg","mode","id","validateOptionalTtl","ttl","validateId","assign","fpaToken","options","Error","hasOwnProperty","default","setLevel","logLevel","productId","clientMetadata","type","sdk","sdkv","twilsock","twilsockClient","Twilsock","on","emit","err","notifications","notificationsClient","Notifications","config","Configuration","network","NetworkService","ClientInfo","storage","SessionStorage","localStorageId","connect","services","router","subscriptions","Subscriptions","Router","entities","EntitiesCache","connectionState","sessionStorageEnabled","storageId","storageSettings","updateStorageId","warn","valueToStore","deepClone","SyncList","SyncMap","store","read","baseUri","optimistic","SyncError","uri","UriBuilder","pathSegment","queryParam","undefined","build","get","response","body","data","requestBody","unique_name","post","documentsUri","then","readRootFromSessionCache","SyncDocument","_get","purpose","context","listsUri","mapsUri","SyncStream","streamsUri","sid","LiveQuery","uniqueName","remove","ensureReady","opts","_createDocument","docDescriptor","docFromInMemoryCache","getCached","_getDocument","status","document","storeRootInSessionCache","syncDocumentImpl","SyncDocumentImpl","removeFromCacheAndSession","_createMap","mapDescriptor","mapFromInMemoryCache","_getMap","includeItems","map","syncMapImpl","SyncMapImpl","_createList","listDescriptor","listFromInMemoryCache","_getList","list","syncListImpl","SyncListImpl","_createStream","streamDescriptor","streamFromInMemoryCache","_getStream","stream","streamRemovalHandler","syncStreamImpl","SyncStreamImpl","shutdown","disconnect","token","Promise","reject","updateToken","indexName","queryExpression","queryUri","insightsUri","queryItems","queryString","liveQueryImpl","query_id","descriptor","_getLiveQuery","last_event_id","liveQueryRemovalHandler","LiveQueryImpl","items","liveQueryDescriptor","liveQueryCreator","liveQuery","search","InstantQuery","EventEmitter"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyncClient = exports.Client = void 0;\nconst events_1 = require(\"events\");\nconst twilsock_1 = require(\"twilsock\");\nconst twilio_notifications_1 = require(\"twilio-notifications\");\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst sanitize_1 = require(\"./utils/sanitize\");\nconst logger_1 = require(\"./utils/logger\");\nconst configuration_1 = require(\"./configuration\");\nconst subscriptions_1 = require(\"./subscriptions\");\nconst router_1 = require(\"./router\");\nconst network_1 = require(\"./services/network\");\nconst syncdocument_1 = require(\"./syncdocument\");\nconst synclist_1 = require(\"./synclist\");\nconst syncmap_1 = require(\"./syncmap\");\nconst clientInfo_1 = require(\"./clientInfo\");\nconst entitiesCache_1 = require(\"./entitiesCache\");\nconst storage_1 = require(\"./services/storage\");\nconst syncstream_1 = require(\"./streams/syncstream\");\nconst livequery_1 = require(\"./livequery\");\nconst livequery_2 = require(\"./livequery\");\nconst SYNC_PRODUCT_ID = 'data_sync';\nconst SDK_VERSION = require('../package.json').version;\nfunction decompose(arg) {\n    if (!arg) {\n        return { mode: 'create_new' };\n    }\n    else if (typeof arg === 'string') {\n        return { id: arg, mode: 'open_or_create' };\n    }\n    else {\n        sanitize_1.validateOptionalTtl(arg.ttl);\n        sanitize_1.validateId(arg.id);\n        let mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');\n        return Object.assign(Object.assign({}, arg), { mode: mode });\n    }\n}\n/**\n * @class Client\n * @classdesc\n * Client for the Twilio Sync service.\n * @constructor\n * @param {String} token - Twilio access token.\n * @param {Client#ClientOptions} [options] - Options to customize the Client.\n * @example\n * // Using NPM\n * var SyncClient = require('twilio-sync');\n * var syncClient = new SyncClient(token, { logLevel: 'debug' });\n *\n * // Using CDN\n * var SyncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });\n *\n * @property {Client#ConnectionState} connectionState - Contains current service connection state.\n * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].\n */\nclass Client extends events_1.EventEmitter {\n    constructor(fpaToken, options = {}) {\n        super();\n        if (!fpaToken) {\n            throw new Error('Sync library needs a valid Twilio token to be passed');\n        }\n        if (options.hasOwnProperty('logLevel')) {\n            logger_1.default.setLevel(options.logLevel);\n        }\n        else {\n            logger_1.default.setLevel('silent');\n        }\n        const productId = options.productId = options.productId || SYNC_PRODUCT_ID;\n        // Filling ClientMetadata\n        options.clientMetadata = options.clientMetadata || {};\n        if (!options.clientMetadata.hasOwnProperty('type')) {\n            options.clientMetadata.type = 'sync';\n        }\n        if (!options.clientMetadata.hasOwnProperty('sdk')) {\n            options.clientMetadata.sdk = 'JS';\n            options.clientMetadata.sdkv = SDK_VERSION;\n        }\n        let twilsock = options.twilsockClient = options.twilsockClient || new twilsock_1.Twilsock(fpaToken, productId, options);\n        twilsock.on('tokenAboutToExpire', ttl => this.emit('tokenAboutToExpire', ttl));\n        twilsock.on('tokenExpired', () => this.emit('tokenExpired'));\n        twilsock.on('connectionError', err => this.emit('connectionError', err));\n        let notifications = options.notificationsClient = options.notificationsClient || new twilio_notifications_1.Notifications(fpaToken, options);\n        let config = new configuration_1.Configuration(options);\n        let network = new network_1.NetworkService(new clientInfo_1.ClientInfo(SDK_VERSION), config, twilsock);\n        let storage = new storage_1.SessionStorage(config);\n        this.localStorageId = null;\n        twilsock.connect();\n        this.services = {\n            config,\n            twilsock,\n            notifications,\n            network,\n            storage,\n            router: null,\n            subscriptions: null\n        };\n        let subscriptions = new subscriptions_1.Subscriptions(this.services);\n        let router = new router_1.Router({ config, subscriptions, notifications });\n        this.services.router = router;\n        this.services.subscriptions = subscriptions;\n        this.entities = new entitiesCache_1.EntitiesCache();\n        notifications.on('connectionStateChanged', () => {\n            this.emit('connectionStateChanged', this.services.notifications.connectionState);\n        });\n    }\n    /**\n     * Current version of Sync client.\n     * @name Client#version\n     * @type String\n     * @readonly\n     */\n    static get version() {\n        return SDK_VERSION;\n    }\n    get connectionState() {\n        return this.services.notifications.connectionState;\n    }\n    /**\n     * Returns promise which resolves when library is correctly initialized\n     * Or throws if initialization is impossible\n     * @private\n     */\n    async ensureReady() {\n        if (!this.services.config.sessionStorageEnabled) {\n            return;\n        }\n        try {\n            let storageSettings = await this.services.twilsock.storageId();\n            this.services.storage.updateStorageId(storageSettings.id);\n        }\n        catch (e) {\n            logger_1.default.warn('Failed to initialize storage', e);\n        }\n    }\n    storeRootInSessionCache(type, id, value) {\n        // can't store without id\n        if (!this.services.config.sessionStorageEnabled || !id) {\n            return;\n        }\n        let valueToStore = sanitize_1.deepClone(value);\n        if (type === synclist_1.SyncList.type || type === syncmap_1.SyncMap.type) {\n            valueToStore['last_event_id'] = null;\n            delete valueToStore['items'];\n        }\n        this.services.storage.store(type, id, valueToStore);\n    }\n    readRootFromSessionCache(type, id) {\n        if (!this.services.config.sessionStorageEnabled || !id) {\n            return null;\n        }\n        return this.services.storage.read(type, id);\n    }\n    async _get(baseUri, id, optimistic = false) {\n        if (!id) {\n            throw new syncerror_1.SyncError(`Cannot get entity without id`, 404);\n        }\n        const uri = new uri_1.UriBuilder(baseUri).pathSegment(id)\n            .queryParam('Include', optimistic ? 'items' : undefined).build();\n        let response = await this.services.network.get(uri);\n        return response.body;\n    }\n    _createDocument(id, data, ttl) {\n        const requestBody = {\n            unique_name: id,\n            data: data || {}\n        };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        return this.services.network.post(this.services.config.documentsUri, requestBody)\n            .then(response => {\n            response.body.data = requestBody.data;\n            return response.body;\n        });\n    }\n    async _getDocument(id) {\n        return (this.readRootFromSessionCache(syncdocument_1.SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));\n    }\n    _createList(id, purpose, context, ttl) {\n        const requestBody = {\n            unique_name: id,\n            purpose: purpose,\n            context: context\n        };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        return this.services.network.post(this.services.config.listsUri, requestBody).then(response => response.body);\n    }\n    async _getList(id) {\n        return (this.readRootFromSessionCache(synclist_1.SyncList.type, id) || this._get(this.services.config.listsUri, id));\n    }\n    _createMap(id, ttl) {\n        const requestBody = {\n            unique_name: id\n        };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        return this.services.network.post(this.services.config.mapsUri, requestBody).then(response => response.body);\n    }\n    async _getMap(id, optimistic = false) {\n        return (this.readRootFromSessionCache(syncmap_1.SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));\n    }\n    async _getStream(id) {\n        return (this.readRootFromSessionCache(syncstream_1.SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false));\n    }\n    async _createStream(id, ttl) {\n        const requestBody = {\n            unique_name: id\n        };\n        if (ttl !== undefined) {\n            requestBody.ttl = ttl;\n        }\n        const response = await this.services.network.post(this.services.config.streamsUri, requestBody);\n        return response.body;\n    }\n    _getLiveQuery(sid) {\n        return this.readRootFromSessionCache(livequery_1.LiveQuery.type, sid);\n    }\n    getCached(id, type) {\n        if (id) {\n            return this.entities.get(id, type) || null;\n        }\n        return null;\n    }\n    removeFromCacheAndSession(type, sid, uniqueName) {\n        this.entities.remove(sid);\n        if (this.services.config.sessionStorageEnabled) {\n            this.services.storage.remove(type, sid, uniqueName);\n        }\n    }\n    /**\n     * Read or create a Sync Document.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Sync Document - opens a Document with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new Document with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<Document>} a promise which resolves after the Document is successfully read (or created).\n     * This promise may reject if the Document could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.document('MyDocument')\n     *   .then(function(document) {\n     *     console.log('Successfully opened a Document. SID: ' + document.sid);\n     *     document.on('updated', function(event) {\n     *       console.log('Received updated event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n    async document(arg) {\n        await this.ensureReady();\n        let opts = decompose(arg);\n        let docDescriptor;\n        if (opts.mode === 'create_new') {\n            docDescriptor = await this._createDocument(opts.id, opts.value, opts.ttl);\n        }\n        else {\n            let docFromInMemoryCache = this.getCached(opts.id, syncdocument_1.SyncDocument.type);\n            if (docFromInMemoryCache) {\n                return new syncdocument_1.SyncDocument(docFromInMemoryCache);\n            }\n            else {\n                try {\n                    docDescriptor = await this._getDocument(opts.id);\n                }\n                catch (err) {\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\n                        throw err;\n                    }\n                    else {\n                        try {\n                            docDescriptor = await this._createDocument(opts.id, opts.value, opts.ttl);\n                        }\n                        catch (err) {\n                            if (err.status === 409) {\n                                return this.document(arg);\n                            }\n                            else {\n                                throw err;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.storeRootInSessionCache(syncdocument_1.SyncDocument.type, opts.id, docDescriptor);\n        let syncDocumentImpl = new syncdocument_1.SyncDocumentImpl(this.services, docDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n        syncDocumentImpl = this.entities.store(syncDocumentImpl);\n        return new syncdocument_1.SyncDocument(syncDocumentImpl);\n    }\n    /**\n     * Read or create a Sync Map.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Sync Map - opens a Map with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new Map with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<Map>} a promise which resolves after the Map is successfully read (or created).\n     * This promise may reject if the Map could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.map('MyMap')\n     *   .then(function(map) {\n     *     console.log('Successfully opened a Map. SID: ' + map.sid);\n     *     map.on('itemUpdated', function(event) {\n     *       console.log('Received itemUpdated event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n    async map(arg) {\n        await this.ensureReady();\n        let opts = decompose(arg);\n        let mapDescriptor;\n        if (opts.mode === 'create_new') {\n            mapDescriptor = await this._createMap(opts.id, opts.ttl);\n        }\n        else {\n            let mapFromInMemoryCache = this.getCached(opts.id, syncmap_1.SyncMap.type);\n            if (mapFromInMemoryCache) {\n                return new syncmap_1.SyncMap(mapFromInMemoryCache);\n            }\n            else {\n                try {\n                    mapDescriptor = await this._getMap(opts.id, opts.includeItems);\n                }\n                catch (err) {\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\n                        throw err;\n                    }\n                    else {\n                        try {\n                            mapDescriptor = await this._createMap(opts.id, opts.ttl);\n                        }\n                        catch (err) {\n                            if (err.status === 409) {\n                                return this.map(arg);\n                            }\n                            else {\n                                throw err;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.storeRootInSessionCache(syncmap_1.SyncMap.type, opts.id, mapDescriptor);\n        let syncMapImpl = new syncmap_1.SyncMapImpl(this.services, mapDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n        syncMapImpl = this.entities.store(syncMapImpl);\n        return new syncmap_1.SyncMap(syncMapImpl);\n    }\n    /**\n     * Read or create a Sync List.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Sync List - opens a List with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new List with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<List>} a promise which resolves after the List is successfully read (or created).\n     * This promise may reject if the List could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.list('MyList')\n     *   .then(function(list) {\n     *     console.log('Successfully opened a List. SID: ' + list.sid);\n     *     list.on('itemAdded', function(event) {\n     *       console.log('Received itemAdded event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n    async list(arg) {\n        await this.ensureReady();\n        let opts = decompose(arg);\n        let listDescriptor;\n        if (opts.mode === 'create_new') {\n            listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n        }\n        else {\n            let listFromInMemoryCache = this.getCached(opts.id, synclist_1.SyncList.type);\n            if (listFromInMemoryCache) {\n                return new synclist_1.SyncList(listFromInMemoryCache);\n            }\n            else {\n                try {\n                    listDescriptor = await this._getList(opts.id);\n                }\n                catch (err) {\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\n                        throw err;\n                    }\n                    else {\n                        try {\n                            listDescriptor = await this._createList(opts.id, opts.purpose, opts.context, opts.ttl);\n                        }\n                        catch (err) {\n                            if (err.status === 409) {\n                                return this.list(arg);\n                            }\n                            else {\n                                throw err;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.storeRootInSessionCache(synclist_1.SyncList.type, opts.id, listDescriptor);\n        let syncListImpl = new synclist_1.SyncListImpl(this.services, listDescriptor, (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName));\n        syncListImpl = this.entities.store(syncListImpl);\n        return new synclist_1.SyncList(syncListImpl);\n    }\n    /**\n     * Read or create a Sync Message Stream.\n     * @param {String | Client#OpenOptions} [arg] One of:\n     * <li>Unique name or SID identifying a Stream - opens a Stream with the given identifier or creates one if it does not exist.</li>\n     * <li>none - creates a new Stream with a randomly assigned SID and no unique name.</li>\n     * <li>{@link Client#OpenOptions} object for more granular control.</li>\n     * @return {Promise<Stream>} a promise which resolves after the Stream is successfully read (or created).\n     * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.\n     * This promise may reject if the Stream could not be created or if this endpoint lacks the necessary permissions to access it.\n     * @public\n     * @example\n     * syncClient.stream('MyStream')\n     *   .then(function(stream) {\n     *     console.log('Successfully opened a Message Stream. SID: ' + stream.sid);\n     *     stream.on('messagePublished', function(event) {\n     *       console.log('Received messagePublished event: ', event);\n     *     });\n     *   })\n     *   .catch(function(error) {\n     *     console.log('Unexpected error', error);\n     *   });\n     */\n    async stream(arg) {\n        await this.ensureReady();\n        let opts = decompose(arg);\n        let streamDescriptor;\n        if (opts.mode === 'create_new') {\n            streamDescriptor = await this._createStream(opts.id, opts.ttl);\n        }\n        else {\n            let streamFromInMemoryCache = this.getCached(opts.id, syncstream_1.SyncStream.type);\n            if (streamFromInMemoryCache) {\n                return new syncstream_1.SyncStream(streamFromInMemoryCache);\n            }\n            else {\n                try {\n                    streamDescriptor = await this._getStream(opts.id);\n                }\n                catch (err) {\n                    if (err.status !== 404 || opts.mode === 'open_existing') {\n                        throw err;\n                    }\n                    else {\n                        try {\n                            streamDescriptor = await this._createStream(opts.id, opts.ttl);\n                        }\n                        catch (err) {\n                            if (err.status === 409) {\n                                return this.stream(arg);\n                            }\n                            else {\n                                throw err;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        this.storeRootInSessionCache(syncstream_1.SyncStream.type, opts.id, streamDescriptor);\n        const streamRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\n        let syncStreamImpl = new syncstream_1.SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);\n        syncStreamImpl = this.entities.store(syncStreamImpl);\n        return new syncstream_1.SyncStream(syncStreamImpl);\n    }\n    /**\n     * Gracefully shutdown the libray\n     * Currently it is not properly implemented and being used only in tests\n     * But should be made a part of public API\n     * @private\n     */\n    async shutdown() {\n        await this.services.subscriptions.shutdown();\n        await this.services.twilsock.disconnect();\n    }\n    /**\n     * Set new authentication token.\n     * @param {String} token New token to set.\n     * @return {Promise<void>}\n     * @public\n     */\n    updateToken(token) {\n        if (!token) {\n            return Promise.reject(new Error('A valid Twilio token should be provided'));\n        }\n        return this.services.twilsock.updateToken(token);\n    }\n    /**\n     * For Flex customers only. Establishes a long-running query against Flex data wherein the returned\n     * result set is updated whenever new (or updated) records match the given expression. Updated results\n     * are presented row-by-row according to the lifetime of the returned LiveQuery object.\n     *\n     * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\n     * @param queryExpression {String} A query expression to be executed against the given data index.\n     * Please review <a href=\"https://www.twilio.com/docs/sync/live-query\" target=\"_blank\">Live Query Language</a>\n     * page for Sync Client limits and full list of operators currently supported in query expressions.\n     *\n     * @return {Promise<LiveQuery>} a promise that resolves when the query has been successfully executed.\n     * @public\n     * @example\n     * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == \"Bob\"')\n     *     .then(function(args) {\n     *        console.log('Subscribed to live data updates for worker Bob');\n     *        let items = args.getItems();\n     *        Object.entries(items).forEach(([key, value]) => {\n     *          console.log('Search result item key: ' + key);\n     *          console.log('Search result item value: ' + value);\n     *        });\n     *     })\n     *     .catch(function(err) {\n     *        console.log('Error when subscribing to live updates for worker Bob', err);\n     *     });\n     */\n    async liveQuery(indexName, queryExpression) {\n        await this.ensureReady();\n        if (!indexName || typeof indexName !== 'string') {\n            throw new Error('Index name must contain a non-empty string value');\n        }\n        let queryUri = new uri_1.UriBuilder(this.services.config.insightsUri)\n            .pathSegment(indexName)\n            .pathSegment('Items')\n            .build();\n        // send query to CDS to get server-generated sid and item list\n        let response = await livequery_2.queryItems({\n            network: this.services.network,\n            uri: queryUri,\n            queryString: queryExpression,\n            type: livequery_1.LiveQuery.type\n        });\n        let liveQueryImpl = this.getCached(response.query_id, livequery_1.LiveQuery.type);\n        if (!liveQueryImpl) {\n            let descriptor = this._getLiveQuery(response.query_id);\n            if (!descriptor) {\n                descriptor = {\n                    indexName,\n                    queryExpression,\n                    sid: response.query_id,\n                    queryUri,\n                    last_event_id: response.last_event_id\n                };\n            }\n            const liveQueryRemovalHandler = (type, sid, uniqueName) => this.removeFromCacheAndSession(type, sid, uniqueName);\n            liveQueryImpl = new livequery_1.LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);\n        }\n        this.storeRootInSessionCache(livequery_1.LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);\n        liveQueryImpl = this.entities.store(liveQueryImpl);\n        return new livequery_1.LiveQuery(liveQueryImpl);\n    }\n    /**\n     * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly\n     * against the target index.\n     *\n     * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.\n     * @return {Promise<InstantQuery>} a promise which resolves after the InstantQuery is successfully created.\n     * @public\n     * @example\n     * syncClient.instantQuery('tr-worker')\n     *    .then(function(q) {\n     *        q.on('searchResult', function(items) {\n     *          Object.entries(items).forEach(([key, value]) => {\n     *             console.log('Search result item key: ' + key);\n     *             console.log('Search result item value: ' + value);\n     *          });\n     *       });\n     *    });\n     */\n    async instantQuery(indexName) {\n        await this.ensureReady();\n        let liveQueryCreator = (indexName, queryExpression) => {\n            return this.liveQuery(indexName, queryExpression);\n        };\n        const search = new livequery_1.InstantQuery({\n            indexName,\n            network: this.services.network,\n            insightsUri: this.services.config.insightsUri,\n            liveQueryCreator\n        });\n        return search;\n    }\n}\nexports.Client = Client;\nexports.SyncClient = Client;\nexports.default = Client;\n/**\n * Indicates current state of connection between the client and Sync service.\n * <p>Valid options are as follows:\n * <li>'connecting' - client is offline and connection attempt is in process.\n * <li>'connected' - client is online and ready.\n * <li>'disconnecting' - client is going offline as disconnection is in process.\n * <li>'disconnected' - client is offline and no connection attempt is in process.\n * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.\n * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.\n * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} Client#ConnectionState\n */\n/**\n * These options can be passed to Client constructor.\n * @typedef {Object} Client#ClientOptions\n * @property {String} [logLevel='error'] - The level of logging to enable. Valid options\n *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace'].\n */\n/**\n * Fired when connection state has been changed.\n * @param {Client#ConnectionState} connectionState Contains current service connection state.\n * @event Client#connectionStateChanged\n * @example\n * syncClient.on('connectionStateChanged', function(newState) {\n *   console.log('Received new connection state: ' + newState);\n * });\n */\n/**\n * Fired when connection is interrupted by unexpected reason\n * @property {Object} error - connection error details\n * @property {Boolean} error.terminal - twilsock will stop connection attempts\n * @property {String} error.message - root cause\n * @property {Number} [error.httpStatusCode] - http status code if available\n * @property {Number} [error.errorCode] - Twilio public error code if available\n * @event Client#connectionError\n * @example\n * syncClient.on('connectionError', function(connectionError) {\n *   console.log('Connection was interrupted: ' + connectionError.message +\n *     ' (isTerminal: ' + connectionError.terminal')');\n * });\n */\n/**\n * Options for opening a Sync Object.\n * @typedef {Object} Client#OpenOptions\n * @property {String} [id] Sync object SID or unique name.\n * @property {'open_or_create' | 'open_existing' | 'create_new'} [mode='open_or_create'] - The mode for opening the Sync object:\n * <li>'open_or_create' - reads a Sync object or creates one if it does not exist.\n * <li>'open_existing' - reads an existing Sync object. The promise is rejected if the object does not exist.\n * <li>'create_new' - creates a new Sync object. If the <i>id</i> property is specified, it will be used as the unique name.\n * @property {Number} [ttl] - The time-to-live of the Sync object in seconds. This is applied only if the object is created.\n * @property {Object} [value={ }] - The initial value for the Sync Document (only applicable to Documents).\n * @example <caption>The following example is applicable to all Sync objects\n * (i.e., <code>syncClient.document(), syncClient.list(), syncClient.map(), syncClient.stream()</code>)</caption>\n * // Attempts to open an existing Document with unique name 'MyDocument'\n * // If no such Document exists, the promise is rejected\n * syncClient.document({\n *     id: 'MyDocument',\n *     mode: 'open_existing'\n *   })\n *   .then(...)\n *   .catch(...);\n *\n * // Attempts to create a new Document with unique name 'MyDocument', TTL of 24 hours and initial value { name: 'John Smith' }\n * // If such a Document already exists, the promise is rejected\n * syncClient.document({\n *     id: 'MyDocument',\n *     mode: 'create_new',\n *     ttl: 86400\n *     value: { name: 'John Smith' } // the `value` property is only applicable for Documents\n *   })\n *   .then(...)\n *   .catch(...);\n */\n/**\n * Fired when the access token is about to expire and needs to be updated.\n * The trigger takes place three minutes before the JWT access token expiry.\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\n * @event Client#tokenAboutToExpire\n * @type {void}\n * @example <caption>The following example illustrates access token refresh</caption>\n * syncClient.on('tokenAboutToExpire', function() {\n *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens\n *   var token = '<your-access-token-here>';\n *   syncClient.updateToken(token);\n * });\n */\n/**\n * Fired when the access token is expired.\n * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.\n * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or\n * <code>tokenExpired</code> events occur; handling just one of them is sufficient.\n * @event Client#tokenExpired\n * @type {void}\n */\n"]},"metadata":{},"sourceType":"script"}