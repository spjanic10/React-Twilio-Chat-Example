{"ast":null,"code":"var _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\n// Generated by CoffeeScript 2.4.1\n(function () {\n  var XMLStringWriter, XMLWriterBase;\n  XMLWriterBase = require('./XMLWriterBase'); // Prints XML nodes as plain text\n\n  module.exports = XMLStringWriter = /*#__PURE__*/function (_XMLWriterBase) {\n    \"use strict\";\n\n    _inherits(XMLStringWriter, _XMLWriterBase);\n\n    var _super = _createSuper(XMLStringWriter);\n\n    // Initializes a new instance of `XMLStringWriter`\n    // `options.pretty` pretty prints the result\n    // `options.indent` indentation string\n    // `options.newline` newline sequence\n    // `options.offset` a fixed number of indentations to add to every line\n    // `options.allowEmpty` do not self close empty element tags\n    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF\n    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements\n    function XMLStringWriter(options) {\n      _classCallCheck(this, XMLStringWriter);\n\n      return _super.call(this, options);\n    }\n\n    _createClass(XMLStringWriter, [{\n      key: \"document\",\n      value: function document(doc, options) {\n        var child, i, len, r, ref;\n        options = this.filterOptions(options);\n        r = '';\n        ref = doc.children;\n\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          r += this.writeChildNode(child, options, 0);\n        } // remove trailing newline\n\n\n        if (options.pretty && r.slice(-options.newline.length) === options.newline) {\n          r = r.slice(0, -options.newline.length);\n        }\n\n        return r;\n      }\n    }]);\n\n    return XMLStringWriter;\n  }(XMLWriterBase);\n}).call(this);","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/xmlbuilder/lib/XMLStringWriter.js"],"names":["XMLStringWriter","XMLWriterBase","require","module","exports","options","doc","child","i","len","r","ref","filterOptions","children","length","writeChildNode","pretty","slice","newline","call"],"mappings":";;;;;;;;AAAA;AACA,CAAC,YAAW;AACV,MAAIA,eAAJ,EAAqBC,aAArB;AAEAA,EAAAA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAAvB,CAHU,CAKV;;AACAC,EAAAA,MAAM,CAACC,OAAP,GAAiBJ,eAAe;AAAA;;AAAA;;AAAA;;AAC9B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAAYK,OAAZ,EAAqB;AAAA;;AAAA,+BACbA,OADa;AAEpB;;AAZ6B;AAAA;AAAA,aAc9B,kBAASC,GAAT,EAAcD,OAAd,EAAuB;AACrB,YAAIE,KAAJ,EAAWC,CAAX,EAAcC,GAAd,EAAmBC,CAAnB,EAAsBC,GAAtB;AACAN,QAAAA,OAAO,GAAG,KAAKO,aAAL,CAAmBP,OAAnB,CAAV;AACAK,QAAAA,CAAC,GAAG,EAAJ;AACAC,QAAAA,GAAG,GAAGL,GAAG,CAACO,QAAV;;AACA,aAAKL,CAAC,GAAG,CAAJ,EAAOC,GAAG,GAAGE,GAAG,CAACG,MAAtB,EAA8BN,CAAC,GAAGC,GAAlC,EAAuCD,CAAC,EAAxC,EAA4C;AAC1CD,UAAAA,KAAK,GAAGI,GAAG,CAACH,CAAD,CAAX;AACAE,UAAAA,CAAC,IAAI,KAAKK,cAAL,CAAoBR,KAApB,EAA2BF,OAA3B,EAAoC,CAApC,CAAL;AACD,SARoB,CASrB;;;AACA,YAAIA,OAAO,CAACW,MAAR,IAAkBN,CAAC,CAACO,KAAF,CAAQ,CAACZ,OAAO,CAACa,OAAR,CAAgBJ,MAAzB,MAAqCT,OAAO,CAACa,OAAnE,EAA4E;AAC1ER,UAAAA,CAAC,GAAGA,CAAC,CAACO,KAAF,CAAQ,CAAR,EAAW,CAACZ,OAAO,CAACa,OAAR,CAAgBJ,MAA5B,CAAJ;AACD;;AACD,eAAOJ,CAAP;AACD;AA5B6B;;AAAA;AAAA,IAAiCT,aAAjC,CAAhC;AAgCD,CAtCD,EAsCGkB,IAtCH,CAsCQ,IAtCR","sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var XMLStringWriter, XMLWriterBase;\n\n  XMLWriterBase = require('./XMLWriterBase');\n\n  // Prints XML nodes as plain text\n  module.exports = XMLStringWriter = class XMLStringWriter extends XMLWriterBase {\n    // Initializes a new instance of `XMLStringWriter`\n\n    // `options.pretty` pretty prints the result\n    // `options.indent` indentation string\n    // `options.newline` newline sequence\n    // `options.offset` a fixed number of indentations to add to every line\n    // `options.allowEmpty` do not self close empty element tags\n    // 'options.dontPrettyTextNodes' if any text is present in node, don't indent or LF\n    // `options.spaceBeforeSlash` add a space before the closing slash of empty elements\n    constructor(options) {\n      super(options);\n    }\n\n    document(doc, options) {\n      var child, i, len, r, ref;\n      options = this.filterOptions(options);\n      r = '';\n      ref = doc.children;\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        r += this.writeChildNode(child, options, 0);\n      }\n      // remove trailing newline\n      if (options.pretty && r.slice(-options.newline.length) === options.newline) {\n        r = r.slice(0, -options.newline.length);\n      }\n      return r;\n    }\n\n  };\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}