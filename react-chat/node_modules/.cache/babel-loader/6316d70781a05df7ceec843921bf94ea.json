{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar operation_retrier_1 = require(\"operation-retrier\");\n/**\n * Retrier with backoff override capability\n*/\n\n\nvar BackoffRetrier = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(BackoffRetrier, _events_1$EventEmitte);\n\n  var _super = _createSuper(BackoffRetrier);\n\n  function BackoffRetrier(options) {\n    var _this;\n\n    _classCallCheck(this, BackoffRetrier);\n\n    _this = _super.call(this);\n    _this.options = options ? Object.assign({}, options) : {};\n    return _this;\n  }\n\n  _createClass(BackoffRetrier, [{\n    key: \"inProgress\",\n    get: function get() {\n      return !!this.retrier;\n    }\n    /**\n     * Should be called once per attempt series to start retrier.\n    */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.inProgress) {\n        throw new Error('Already waiting for next attempt, call finishAttempt(success : boolean) to finish it');\n      }\n\n      this.createRetrier();\n    }\n    /**\n     * Should be called to stop retrier entirely.\n    */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.cleanRetrier();\n      this.newBackoff = null;\n      this.usedBackoff = null;\n    }\n    /**\n     * Modifies backoff for next attempt.\n     * Expected behavior:\n     * - If there was no backoff passed previously reschedulling next attempt to given backoff\n     * - If previous backoff was longer then ignoring this one.\n     * - If previous backoff was shorter then reschedulling with this one.\n     * With or without backoff retrier will keep growing normally.\n     * @param delay delay of next attempts in ms.\n     */\n\n  }, {\n    key: \"modifyBackoff\",\n    value: function modifyBackoff(delay) {\n      this.newBackoff = delay;\n    }\n    /**\n     * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.\n    */\n\n  }, {\n    key: \"attemptFailed\",\n    value: function attemptFailed() {\n      if (!this.inProgress) {\n        throw new Error('No attempt is in progress');\n      }\n\n      if (this.newBackoff) {\n        var shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;\n\n        if (shouldUseNewBackoff) {\n          this.createRetrier();\n        } else {\n          this.retrier.failed(new Error());\n        }\n      } else {\n        this.retrier.failed(new Error());\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.retrier) {\n        this.retrier.cancel();\n      }\n    }\n  }, {\n    key: \"cleanRetrier\",\n    value: function cleanRetrier() {\n      if (this.retrier) {\n        this.retrier.removeAllListeners();\n        this.retrier.cancel();\n        this.retrier = null;\n      }\n    }\n  }, {\n    key: \"getRetryPolicy\",\n    value: function getRetryPolicy() {\n      var clone = Object.assign({}, this.options);\n\n      if (this.newBackoff) {\n        clone.min = this.newBackoff;\n        clone.max = this.options.max && this.options.max > this.newBackoff ? this.options.max : this.newBackoff;\n      } // As we're always skipping first attempt we should add one extra if limit is present\n\n\n      clone.maxAttemptsCount = this.options.maxAttemptsCount ? this.options.maxAttemptsCount + 1 : undefined;\n      return clone;\n    }\n  }, {\n    key: \"createRetrier\",\n    value: function createRetrier() {\n      var _this2 = this;\n\n      this.cleanRetrier();\n      var retryPolicy = this.getRetryPolicy();\n      this.retrier = new operation_retrier_1.Retrier(retryPolicy);\n      this.retrier.once('attempt', function () {\n        _this2.retrier.on('attempt', function () {\n          return _this2.emit('attempt');\n        });\n\n        _this2.retrier.failed(new Error('Skipping first attempt'));\n      });\n      this.retrier.on('failed', function (err) {\n        return _this2.emit('failed', err);\n      });\n      this.usedBackoff = this.newBackoff;\n      this.newBackoff = null;\n      this.retrier.start().catch(function (err) {});\n    }\n  }]);\n\n  return BackoffRetrier;\n}(events_1.EventEmitter);\n\nexports.BackoffRetrier = BackoffRetrier;","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilio-notifications/node_modules/twilsock/lib/backoffretrier.js"],"names":["Object","defineProperty","exports","value","events_1","require","operation_retrier_1","BackoffRetrier","options","assign","retrier","inProgress","Error","createRetrier","cleanRetrier","newBackoff","usedBackoff","delay","shouldUseNewBackoff","failed","cancel","removeAllListeners","clone","min","max","maxAttemptsCount","undefined","retryPolicy","getRetryPolicy","Retrier","once","on","emit","err","start","catch","EventEmitter"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst operation_retrier_1 = require(\"operation-retrier\");\n/**\n * Retrier with backoff override capability\n*/\nclass BackoffRetrier extends events_1.EventEmitter {\n    constructor(options) {\n        super();\n        this.options = options ? Object.assign({}, options) : {};\n    }\n    get inProgress() { return !!this.retrier; }\n    /**\n     * Should be called once per attempt series to start retrier.\n    */\n    start() {\n        if (this.inProgress) {\n            throw new Error('Already waiting for next attempt, call finishAttempt(success : boolean) to finish it');\n        }\n        this.createRetrier();\n    }\n    /**\n     * Should be called to stop retrier entirely.\n    */\n    stop() {\n        this.cleanRetrier();\n        this.newBackoff = null;\n        this.usedBackoff = null;\n    }\n    /**\n     * Modifies backoff for next attempt.\n     * Expected behavior:\n     * - If there was no backoff passed previously reschedulling next attempt to given backoff\n     * - If previous backoff was longer then ignoring this one.\n     * - If previous backoff was shorter then reschedulling with this one.\n     * With or without backoff retrier will keep growing normally.\n     * @param delay delay of next attempts in ms.\n     */\n    modifyBackoff(delay) {\n        this.newBackoff = delay;\n    }\n    /**\n     * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.\n    */\n    attemptFailed() {\n        if (!this.inProgress) {\n            throw new Error('No attempt is in progress');\n        }\n        if (this.newBackoff) {\n            const shouldUseNewBackoff = !this.usedBackoff || this.usedBackoff < this.newBackoff;\n            if (shouldUseNewBackoff) {\n                this.createRetrier();\n            }\n            else {\n                this.retrier.failed(new Error());\n            }\n        }\n        else {\n            this.retrier.failed(new Error());\n        }\n    }\n    cancel() {\n        if (this.retrier) {\n            this.retrier.cancel();\n        }\n    }\n    cleanRetrier() {\n        if (this.retrier) {\n            this.retrier.removeAllListeners();\n            this.retrier.cancel();\n            this.retrier = null;\n        }\n    }\n    getRetryPolicy() {\n        const clone = Object.assign({}, this.options);\n        if (this.newBackoff) {\n            clone.min = this.newBackoff;\n            clone.max = this.options.max && this.options.max > this.newBackoff\n                ? this.options.max\n                : this.newBackoff;\n        }\n        // As we're always skipping first attempt we should add one extra if limit is present\n        clone.maxAttemptsCount = this.options.maxAttemptsCount\n            ? this.options.maxAttemptsCount + 1\n            : undefined;\n        return clone;\n    }\n    createRetrier() {\n        this.cleanRetrier();\n        const retryPolicy = this.getRetryPolicy();\n        this.retrier = new operation_retrier_1.Retrier(retryPolicy);\n        this.retrier.once('attempt', () => {\n            this.retrier.on('attempt', () => this.emit('attempt'));\n            this.retrier.failed(new Error('Skipping first attempt'));\n        });\n        this.retrier.on('failed', err => this.emit('failed', err));\n        this.usedBackoff = this.newBackoff;\n        this.newBackoff = null;\n        this.retrier.start()\n            .catch(err => { });\n    }\n}\nexports.BackoffRetrier = BackoffRetrier;\n"]},"metadata":{},"sourceType":"script"}