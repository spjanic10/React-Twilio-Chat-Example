{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _assertThisInitialized = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _asyncToGenerator = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InstantQuery = exports.LiveQuery = exports.queryItems = exports.LiveQueryImpl = exports.InsightsItem = void 0;\n\nvar uri_1 = require(\"./utils/uri\");\n\nvar syncerror_1 = require(\"./utils/syncerror\");\n\nvar logger_1 = require(\"./utils/logger\");\n\nvar events_1 = require(\"events\");\n\nvar entity_1 = require(\"./entity\");\n\nvar closeable_1 = require(\"./closeable\");\n\nvar cache_1 = require(\"./cache\");\n\nvar InsightsItem = function InsightsItem() {\n  _classCallCheck(this, InsightsItem);\n};\n\nexports.InsightsItem = InsightsItem;\n\nvar LiveQueryImpl = /*#__PURE__*/function (_entity_1$SyncEntity) {\n  _inherits(LiveQueryImpl, _entity_1$SyncEntity);\n\n  var _super = _createSuper(LiveQueryImpl);\n\n  function LiveQueryImpl(descriptor, services, removalHandler, items) {\n    var _this;\n\n    _classCallCheck(this, LiveQueryImpl);\n\n    _this = _super.call(this, services, removalHandler);\n    _this.descriptor = descriptor;\n    _this.cache = new cache_1.Cache();\n\n    if (items) {\n      items.forEach(function (item) {\n        _this.cache.store(item.key, {\n          key: item.key,\n          value: item.data\n        }, item.revision);\n      });\n    }\n\n    return _this;\n  } // public\n\n\n  _createClass(LiveQueryImpl, [{\n    key: \"sid\",\n    get: function get() {\n      return this.descriptor.sid;\n    } // private extension of SyncEntity\n\n  }, {\n    key: \"uniqueName\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return LiveQueryImpl.type;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.descriptor.last_event_id;\n    }\n  }, {\n    key: \"indexName\",\n    get: function get() {\n      return this.descriptor.indexName;\n    }\n  }, {\n    key: \"queryString\",\n    get: function get() {\n      return this.descriptor.queryExpression;\n    } // custom private props\n\n  }, {\n    key: \"queryUri\",\n    get: function get() {\n      return this.descriptor.queryUri;\n    }\n  }, {\n    key: \"liveQueryDescriptor\",\n    get: function get() {\n      return this.descriptor;\n    } // dummy stub from iface\n\n  }, {\n    key: \"onRemoved\",\n    value: function onRemoved() {}\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      var dataByKey = {};\n      this.cache.forEach(function (key, item) {\n        dataByKey[key] = item.value;\n      });\n      return dataByKey;\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_update\",\n    value: function _update(message, isStrictlyOrdered) {\n      switch (message.type) {\n        case 'live_query_item_updated':\n          this.handleItemMutated(message.item_key, message.item_data, message.item_revision);\n          break;\n\n        case 'live_query_item_removed':\n          this.handleItemRemoved(message.item_key, message.item_revision);\n          break;\n\n        case 'live_query_updated':\n          this.handleBatchUpdate(message.items);\n          break;\n      }\n\n      if (isStrictlyOrdered) {\n        this._advanceLastEventId(message.last_event_id);\n      }\n    }\n  }, {\n    key: \"handleItemMutated\",\n    value: function handleItemMutated(key, value, revision) {\n      if (this.shouldIgnoreEvent(key, revision)) {\n        logger_1.default.trace(\"Item \".concat(key, \" update skipped, revision: \").concat(revision));\n      } else {\n        var newItem = {\n          key: key,\n          value: value\n        };\n        this.cache.store(key, newItem, revision);\n        this.broadcastEventToListeners('itemUpdated', newItem);\n      }\n    }\n  }, {\n    key: \"handleItemRemoved\",\n    value: function handleItemRemoved(key, revision) {\n      var force = revision === null;\n\n      if (this.shouldIgnoreEvent(key, revision)) {\n        logger_1.default.trace(\"Item \".concat(key, \" delete skipped, revision: \").concat(revision));\n      } else {\n        this.cache.delete(key, revision, force);\n        this.broadcastEventToListeners('itemRemoved', {\n          key: key\n        });\n      }\n    }\n  }, {\n    key: \"handleBatchUpdate\",\n    value: function handleBatchUpdate(items) {\n      var _this2 = this;\n\n      // preprocess item set for easy key-based access (it's a one-time constant time operation)\n      var newItems = {};\n\n      if (items != null) {\n        items.forEach(function (item) {\n          newItems[item.key] = {\n            data: item.data,\n            revision: item.revision\n          };\n        });\n      } // go through existing items and generate update/remove events for them\n\n\n      this.cache.forEach(function (key, item) {\n        var newItem = newItems[key];\n\n        if (newItem != null) {\n          _this2.handleItemMutated(key, newItem.data, newItem.revision);\n        } else {\n          _this2.handleItemRemoved(key, null); // force deletion w/o revision\n\n        } // once item is handled, remove it from incoming array\n\n\n        delete newItems[key];\n      }); // once we handled all the known items, handle remaining pack\n\n      for (var key in newItems) {\n        this.handleItemMutated(key, newItems[key].data, newItems[key].revision);\n      }\n    }\n  }, {\n    key: \"shouldIgnoreEvent\",\n    value: function shouldIgnoreEvent(key, eventId) {\n      return key != null && eventId != null && this.cache.isKnown(key, eventId);\n    }\n    /**\n     * @private\n     */\n\n  }, {\n    key: \"_advanceLastEventId\",\n    value: function _advanceLastEventId(eventId, revision) {\n      // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only\n      if (this.lastEventId < eventId) {\n        this.descriptor.last_event_id = eventId;\n      }\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'live_query';\n    }\n  }]);\n\n  return LiveQueryImpl;\n}(entity_1.SyncEntity);\n\nexports.LiveQueryImpl = LiveQueryImpl;\n\nfunction queryItems(_x) {\n  return _queryItems.apply(this, arguments);\n}\n\nfunction _queryItems() {\n  _queryItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(params) {\n    var network, queryString, uri, type, liveQueryRequestBody, response;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            network = params.network, queryString = params.queryString, uri = params.uri, type = params.type;\n\n            if (!(queryString == null)) {\n              _context3.next = 3;\n              break;\n            }\n\n            throw new syncerror_1.SyncError(\"Invalid query\", 400, 54507);\n\n          case 3:\n            liveQueryRequestBody = {\n              query_string: queryString // raw query string (like `key == \"value\" AND key2 != \"value2\"`)\n\n            };\n\n            if (type === LiveQuery.type) {\n              liveQueryRequestBody.type = type;\n            }\n\n            _context3.next = 7;\n            return network.post(uri, liveQueryRequestBody, undefined, true);\n\n          case 7:\n            response = _context3.sent;\n            return _context3.abrupt(\"return\", response.body);\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _queryItems.apply(this, arguments);\n}\n\nexports.queryItems = queryItems;\n/**\n * @class\n * @alias LiveQuery\n * @classdesc Represents a long-running query against Flex data wherein the returned result set\n *     subsequently receives pushed updates whenever new (or updated) records would match the\n *     given expression. Updated results are presented row-by-row until this query is explicitly\n *     closed.\n *\n *     Use the {@link Client#liveQuery} method to create a live query.\n *\n * @property {String} sid The immutable identifier of this query object, assigned by the system.\n *\n * @fires LiveQuery#itemUpdated\n * @fires LiveQuery#itemRemoved\n */\n\nvar LiveQuery = /*#__PURE__*/function (_closeable_1$Closeabl) {\n  _inherits(LiveQuery, _closeable_1$Closeabl);\n\n  var _super2 = _createSuper(LiveQuery);\n\n  /**\n   * @private\n   */\n  function LiveQuery(liveQueryImpl) {\n    var _this3;\n\n    _classCallCheck(this, LiveQuery);\n\n    _this3 = _super2.call(this);\n    _this3.liveQueryImpl = liveQueryImpl;\n\n    _this3.liveQueryImpl.attach(_assertThisInitialized(_this3));\n\n    return _this3;\n  } // private props\n\n\n  _createClass(LiveQuery, [{\n    key: \"type\",\n    get: function get() {\n      return LiveQueryImpl.type;\n    }\n  }, {\n    key: \"lastEventId\",\n    get: function get() {\n      return this.liveQueryImpl.lastEventId;\n    } // public\n\n  }, {\n    key: \"sid\",\n    get: function get() {\n      return this.liveQueryImpl.sid;\n    }\n    /**\n     * Closes this query instance and unsubscribes from further service events.\n     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.\n     * @public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      _get(_getPrototypeOf(LiveQuery.prototype), \"close\", this).call(this);\n\n      this.liveQueryImpl.detach(this.listenerUuid);\n    }\n    /**\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.\n     * @public\n     */\n\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      this.ensureNotClosed();\n      return this.liveQueryImpl.getItems();\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return LiveQueryImpl.type;\n    }\n  }]);\n\n  return LiveQuery;\n}(closeable_1.Closeable);\n\nexports.LiveQuery = LiveQuery;\n/**\n * @class\n * @alias InstantQuery\n * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a\n * LiveQuery, this result set does not subscribe to any updates and therefore receives no events\n * beyond the initial result set.\n *\n * Use the {@link Client#instantQuery} method to create an Instant Query.\n *\n * @fires InstantQuery#searchResult\n */\n\nvar InstantQuery = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(InstantQuery, _events_1$EventEmitte);\n\n  var _super3 = _createSuper(InstantQuery);\n\n  /**\n   * @private\n   */\n  function InstantQuery(params) {\n    var _this4;\n\n    _classCallCheck(this, InstantQuery);\n\n    _this4 = _super3.call(this);\n    _this4.queryExpression = null;\n    _this4.items = {};\n    Object.assign(_assertThisInitialized(_this4), params);\n\n    _this4.updateIndexName(params.indexName);\n\n    return _this4;\n  } // private props\n\n\n  _createClass(InstantQuery, [{\n    key: \"type\",\n    get: function get() {\n      return InstantQuery.type;\n    }\n    /**\n     * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}\n     * event.\n     * @param {String} queryExpression A query expression to be executed against the given data index. For more information\n     * on the syntax read {@link Client#liveQuery}.\n     * @returns {Promise<void>} A promise that resolves when query result has been received.\n     * @public\n     */\n\n  }, {\n    key: \"search\",\n    value: function () {\n      var _search = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(queryExpression) {\n        var _this5 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.items = {};\n                return _context.abrupt(\"return\", queryItems({\n                  network: this.network,\n                  uri: this.queryUri,\n                  queryString: queryExpression\n                }).then(function (response) {\n                  _this5.queryExpression = queryExpression;\n\n                  if (response.items) {\n                    response.items.forEach(function (item) {\n                      _this5.items[item.key] = item.data;\n                    });\n                  }\n\n                  _this5.emit('searchResult', _this5.getItems());\n                }).catch(function (err) {\n                  logger_1.default.error(\"Error '\".concat(err.message, \"' while executing query '\").concat(queryExpression, \"'\"));\n                  _this5.queryExpression = null;\n                  throw err;\n                }));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function search(_x2) {\n        return _search.apply(this, arguments);\n      }\n\n      return search;\n    }()\n    /**\n     * Instantiates a LiveQuery object based on the last known query expression that was passed to the\n     * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,\n     * while current object can be still used to execute repetitive searches.\n     * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.\n     * @public\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.queryExpression == null)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", Promise.reject(new syncerror_1.SyncError(\"Invalid query\", 400, 54507)));\n\n              case 2:\n                return _context2.abrupt(\"return\", this.liveQueryCreator(this.indexName, this.queryExpression));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function subscribe() {\n        return _subscribe.apply(this, arguments);\n      }\n\n      return subscribe;\n    }()\n    /**\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.\n     * @public\n     */\n\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      return this.items;\n    }\n    /**\n     * Set new index name\n     * @param {String} indexName New index name to set\n     * @returns void\n     * @public\n     */\n\n  }, {\n    key: \"updateIndexName\",\n    value: function updateIndexName(indexName) {\n      if (!indexName || typeof indexName !== 'string') {\n        throw new Error('Index name must contain a non-empty string value');\n      }\n\n      this.indexName = indexName;\n      this.queryUri = this.generateQueryUri(this.indexName);\n    }\n  }, {\n    key: \"generateQueryUri\",\n    value: function generateQueryUri(indexName) {\n      return new uri_1.UriBuilder(this.insightsUri).pathSegment(indexName).pathSegment('Items').build();\n    }\n  }], [{\n    key: \"type\",\n    get: function get() {\n      return 'instant_query';\n    }\n  }]);\n\n  return InstantQuery;\n}(events_1.EventEmitter);\n\nexports.InstantQuery = InstantQuery;\nexports.default = LiveQuery;\n/**\n * @class InsightsItem\n * @classdesc An individual result from a LiveQuery or InstantQuery result set.\n * @property {String} key The identifier that maps to this item within the search result.\n * @property {Object} value The contents of the item.\n */\n\n/**\n * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a\n * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of\n * {@link InsightsItem}-s.\n * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot\n */\n\n/**\n * Fired when an item has been added or updated.\n * @event LiveQuery#itemUpdated\n * @param {InsightsItem} item Updated item.\n * @example\n * liveQuery.on('itemUpdated', function(item) {\n *   console.log('Item ' + item.key + ' was updated');\n *   console.log('Item value: ', item.value);\n * });\n */\n\n/**\n * Fired when an existing item has been removed.\n * @event LiveQuery#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @example\n * liveQuery.on('itemRemoved', function(args) {\n *   console.log('Item ' + args.key + ' was removed');\n * });\n */\n\n/**\n * Fired when a search result is ready.\n * @event InstantQuery#searchResult\n * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.\n * @example\n * instantQuery.on('searchResult', function(items) {\n *    Object.entries(items).forEach(([key, value]) => {\n *      console.log('Search result item key: ' + key);\n *      console.log('Search result item value: ' + value);\n *    });\n * });\n */","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/twilio-sync/lib/livequery.js"],"names":["Object","defineProperty","exports","value","InstantQuery","LiveQuery","queryItems","LiveQueryImpl","InsightsItem","uri_1","require","syncerror_1","logger_1","events_1","entity_1","closeable_1","cache_1","descriptor","services","removalHandler","items","cache","Cache","forEach","item","store","key","data","revision","sid","type","last_event_id","indexName","queryExpression","queryUri","dataByKey","message","isStrictlyOrdered","handleItemMutated","item_key","item_data","item_revision","handleItemRemoved","handleBatchUpdate","_advanceLastEventId","shouldIgnoreEvent","default","trace","newItem","broadcastEventToListeners","force","delete","newItems","eventId","isKnown","lastEventId","SyncEntity","params","network","queryString","uri","SyncError","liveQueryRequestBody","query_string","post","undefined","response","body","liveQueryImpl","attach","detach","listenerUuid","ensureNotClosed","getItems","Closeable","assign","updateIndexName","then","emit","catch","err","error","Promise","reject","liveQueryCreator","Error","generateQueryUri","UriBuilder","insightsUri","pathSegment","build","EventEmitter"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InstantQuery = exports.LiveQuery = exports.queryItems = exports.LiveQueryImpl = exports.InsightsItem = void 0;\nconst uri_1 = require(\"./utils/uri\");\nconst syncerror_1 = require(\"./utils/syncerror\");\nconst logger_1 = require(\"./utils/logger\");\nconst events_1 = require(\"events\");\nconst entity_1 = require(\"./entity\");\nconst closeable_1 = require(\"./closeable\");\nconst cache_1 = require(\"./cache\");\nclass InsightsItem {\n}\nexports.InsightsItem = InsightsItem;\nclass LiveQueryImpl extends entity_1.SyncEntity {\n    constructor(descriptor, services, removalHandler, items) {\n        super(services, removalHandler);\n        this.descriptor = descriptor;\n        this.cache = new cache_1.Cache();\n        if (items) {\n            items.forEach(item => {\n                this.cache.store(item.key, { key: item.key, value: item.data }, item.revision);\n            });\n        }\n    }\n    // public\n    get sid() {\n        return this.descriptor.sid;\n    }\n    // private extension of SyncEntity\n    get uniqueName() {\n        return null;\n    }\n    get type() {\n        return LiveQueryImpl.type;\n    }\n    static get type() {\n        return 'live_query';\n    }\n    get lastEventId() {\n        return this.descriptor.last_event_id;\n    }\n    get indexName() {\n        return this.descriptor.indexName;\n    }\n    get queryString() {\n        return this.descriptor.queryExpression;\n    }\n    // custom private props\n    get queryUri() {\n        return this.descriptor.queryUri;\n    }\n    get liveQueryDescriptor() {\n        return this.descriptor;\n    }\n    // dummy stub from iface\n    onRemoved() {\n    }\n    getItems() {\n        const dataByKey = {};\n        this.cache.forEach((key, item) => {\n            dataByKey[key] = item.value;\n        });\n        return dataByKey;\n    }\n    /**\n     * @private\n     */\n    _update(message, isStrictlyOrdered) {\n        switch (message.type) {\n            case 'live_query_item_updated':\n                this.handleItemMutated(message.item_key, message.item_data, message.item_revision);\n                break;\n            case 'live_query_item_removed':\n                this.handleItemRemoved(message.item_key, message.item_revision);\n                break;\n            case 'live_query_updated':\n                this.handleBatchUpdate(message.items);\n                break;\n        }\n        if (isStrictlyOrdered) {\n            this._advanceLastEventId(message.last_event_id);\n        }\n    }\n    handleItemMutated(key, value, revision) {\n        if (this.shouldIgnoreEvent(key, revision)) {\n            logger_1.default.trace(`Item ${key} update skipped, revision: ${revision}`);\n        }\n        else {\n            const newItem = { key, value };\n            this.cache.store(key, newItem, revision);\n            this.broadcastEventToListeners('itemUpdated', newItem);\n        }\n    }\n    handleItemRemoved(key, revision) {\n        const force = (revision === null);\n        if (this.shouldIgnoreEvent(key, revision)) {\n            logger_1.default.trace(`Item ${key} delete skipped, revision: ${revision}`);\n        }\n        else {\n            this.cache.delete(key, revision, force);\n            this.broadcastEventToListeners('itemRemoved', { key });\n        }\n    }\n    handleBatchUpdate(items) {\n        // preprocess item set for easy key-based access (it's a one-time constant time operation)\n        let newItems = {};\n        if (items != null) {\n            items.forEach(item => {\n                newItems[item.key] = {\n                    data: item.data,\n                    revision: item.revision\n                };\n            });\n        }\n        // go through existing items and generate update/remove events for them\n        this.cache.forEach((key, item) => {\n            const newItem = newItems[key];\n            if (newItem != null) {\n                this.handleItemMutated(key, newItem.data, newItem.revision);\n            }\n            else {\n                this.handleItemRemoved(key, null); // force deletion w/o revision\n            }\n            // once item is handled, remove it from incoming array\n            delete newItems[key];\n        });\n        // once we handled all the known items, handle remaining pack\n        for (let key in newItems) {\n            this.handleItemMutated(key, newItems[key].data, newItems[key].revision);\n        }\n    }\n    shouldIgnoreEvent(key, eventId) {\n        return key != null && eventId != null && this.cache.isKnown(key, eventId);\n    }\n    /**\n     * @private\n     */\n    _advanceLastEventId(eventId, revision) {\n        // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only\n        if (this.lastEventId < eventId) {\n            this.descriptor.last_event_id = eventId;\n        }\n    }\n}\nexports.LiveQueryImpl = LiveQueryImpl;\nasync function queryItems(params) {\n    let { network, queryString, uri, type } = params;\n    if (queryString == null) { // should not be null or undefined\n        throw new syncerror_1.SyncError(`Invalid query`, 400, 54507);\n    }\n    const liveQueryRequestBody = {\n        query_string: queryString // raw query string (like `key == \"value\" AND key2 != \"value2\"`)\n    };\n    if (type === LiveQuery.type) {\n        liveQueryRequestBody.type = type;\n    }\n    let response = await network.post(uri, liveQueryRequestBody, undefined, true);\n    return response.body;\n}\nexports.queryItems = queryItems;\n/**\n * @class\n * @alias LiveQuery\n * @classdesc Represents a long-running query against Flex data wherein the returned result set\n *     subsequently receives pushed updates whenever new (or updated) records would match the\n *     given expression. Updated results are presented row-by-row until this query is explicitly\n *     closed.\n *\n *     Use the {@link Client#liveQuery} method to create a live query.\n *\n * @property {String} sid The immutable identifier of this query object, assigned by the system.\n *\n * @fires LiveQuery#itemUpdated\n * @fires LiveQuery#itemRemoved\n */\nclass LiveQuery extends closeable_1.Closeable {\n    /**\n     * @private\n     */\n    constructor(liveQueryImpl) {\n        super();\n        this.liveQueryImpl = liveQueryImpl;\n        this.liveQueryImpl.attach(this);\n    }\n    // private props\n    static get type() {\n        return LiveQueryImpl.type;\n    }\n    get type() {\n        return LiveQueryImpl.type;\n    }\n    get lastEventId() {\n        return this.liveQueryImpl.lastEventId;\n    }\n    // public\n    get sid() {\n        return this.liveQueryImpl.sid;\n    }\n    /**\n     * Closes this query instance and unsubscribes from further service events.\n     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.\n     * @public\n     */\n    close() {\n        super.close();\n        this.liveQueryImpl.detach(this.listenerUuid);\n    }\n    /**\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.\n     * @public\n     */\n    getItems() {\n        this.ensureNotClosed();\n        return this.liveQueryImpl.getItems();\n    }\n}\nexports.LiveQuery = LiveQuery;\n/**\n * @class\n * @alias InstantQuery\n * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a\n * LiveQuery, this result set does not subscribe to any updates and therefore receives no events\n * beyond the initial result set.\n *\n * Use the {@link Client#instantQuery} method to create an Instant Query.\n *\n * @fires InstantQuery#searchResult\n */\nclass InstantQuery extends events_1.EventEmitter {\n    /**\n     * @private\n     */\n    constructor(params) {\n        super();\n        this.queryExpression = null;\n        this.items = {};\n        Object.assign(this, params);\n        this.updateIndexName(params.indexName);\n    }\n    // private props\n    static get type() {\n        return 'instant_query';\n    }\n    get type() {\n        return InstantQuery.type;\n    }\n    /**\n     * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}\n     * event.\n     * @param {String} queryExpression A query expression to be executed against the given data index. For more information\n     * on the syntax read {@link Client#liveQuery}.\n     * @returns {Promise<void>} A promise that resolves when query result has been received.\n     * @public\n     */\n    async search(queryExpression) {\n        this.items = {};\n        return queryItems({\n            network: this.network,\n            uri: this.queryUri,\n            queryString: queryExpression\n        })\n            .then(response => {\n            this.queryExpression = queryExpression;\n            if (response.items) {\n                response.items.forEach((item) => {\n                    this.items[item.key] = item.data;\n                });\n            }\n            this.emit('searchResult', this.getItems());\n        })\n            .catch(err => {\n            logger_1.default.error(`Error '${err.message}' while executing query '${queryExpression}'`);\n            this.queryExpression = null;\n            throw err;\n        });\n    }\n    /**\n     * Instantiates a LiveQuery object based on the last known query expression that was passed to the\n     * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,\n     * while current object can be still used to execute repetitive searches.\n     * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.\n     * @public\n     */\n    async subscribe() {\n        if (this.queryExpression == null) { // should not be null or undefined\n            return Promise.reject(new syncerror_1.SyncError(`Invalid query`, 400, 54507));\n        }\n        return this.liveQueryCreator(this.indexName, this.queryExpression);\n    }\n    /**\n     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.\n     * @public\n     */\n    getItems() {\n        return this.items;\n    }\n    /**\n     * Set new index name\n     * @param {String} indexName New index name to set\n     * @returns void\n     * @public\n     */\n    updateIndexName(indexName) {\n        if (!indexName || typeof indexName !== 'string') {\n            throw new Error('Index name must contain a non-empty string value');\n        }\n        this.indexName = indexName;\n        this.queryUri = this.generateQueryUri(this.indexName);\n    }\n    generateQueryUri(indexName) {\n        return new uri_1.UriBuilder(this.insightsUri)\n            .pathSegment(indexName)\n            .pathSegment('Items')\n            .build();\n    }\n}\nexports.InstantQuery = InstantQuery;\nexports.default = LiveQuery;\n/**\n * @class InsightsItem\n * @classdesc An individual result from a LiveQuery or InstantQuery result set.\n * @property {String} key The identifier that maps to this item within the search result.\n * @property {Object} value The contents of the item.\n */\n/**\n * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a\n * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of\n * {@link InsightsItem}-s.\n * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot\n */\n/**\n * Fired when an item has been added or updated.\n * @event LiveQuery#itemUpdated\n * @param {InsightsItem} item Updated item.\n * @example\n * liveQuery.on('itemUpdated', function(item) {\n *   console.log('Item ' + item.key + ' was updated');\n *   console.log('Item value: ', item.value);\n * });\n */\n/**\n * Fired when an existing item has been removed.\n * @event LiveQuery#itemRemoved\n * @param {Object} args Arguments provided with the event.\n * @param {String} args.key The key of the removed item.\n * @example\n * liveQuery.on('itemRemoved', function(args) {\n *   console.log('Item ' + args.key + ' was removed');\n * });\n */\n/**\n * Fired when a search result is ready.\n * @event InstantQuery#searchResult\n * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.\n * @example\n * instantQuery.on('searchResult', function(items) {\n *    Object.entries(items).forEach(([key, value]) => {\n *      console.log('Search result item key: ' + key);\n *      console.log('Search result item value: ' + value);\n *    });\n * });\n */\n"]},"metadata":{},"sourceType":"script"}