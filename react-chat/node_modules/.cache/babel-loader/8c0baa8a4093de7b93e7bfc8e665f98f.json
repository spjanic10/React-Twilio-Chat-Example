{"ast":null,"code":"var _classCallCheck = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/stefanpjanic/Desktop/mango_dev/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n// Generated by CoffeeScript 2.4.1\n(function () {\n  var DocumentPosition,\n      NodeType,\n      XMLCData,\n      XMLComment,\n      XMLDeclaration,\n      XMLDocType,\n      XMLDummy,\n      XMLElement,\n      XMLNamedNodeMap,\n      XMLNode,\n      XMLNodeList,\n      XMLProcessingInstruction,\n      XMLRaw,\n      XMLText,\n      getValue,\n      isEmpty,\n      isFunction,\n      isObject,\n      hasProp = {}.hasOwnProperty,\n      splice = [].splice;\n\n  var _require = require('./Utility');\n\n  isObject = _require.isObject;\n  isFunction = _require.isFunction;\n  isEmpty = _require.isEmpty;\n  getValue = _require.getValue;\n  XMLElement = null;\n  XMLCData = null;\n  XMLComment = null;\n  XMLDeclaration = null;\n  XMLDocType = null;\n  XMLRaw = null;\n  XMLText = null;\n  XMLProcessingInstruction = null;\n  XMLDummy = null;\n  NodeType = null;\n  XMLNodeList = null;\n  XMLNamedNodeMap = null;\n  DocumentPosition = null; // Represents a generic XMl element\n\n  module.exports = XMLNode = function () {\n    var XMLNode = /*#__PURE__*/function () {\n      \"use strict\";\n\n      // Initializes a new instance of `XMLNode`\n      // `parent` the parent node\n      function XMLNode(parent1) {\n        _classCallCheck(this, XMLNode);\n\n        this.parent = parent1;\n\n        if (this.parent) {\n          this.options = this.parent.options;\n          this.stringify = this.parent.stringify;\n        }\n\n        this.value = null;\n        this.children = [];\n        this.baseURI = null; // first execution, load dependencies that are otherwise\n        // circular (so we can't load them at the top)\n\n        if (!XMLElement) {\n          XMLElement = require('./XMLElement');\n          XMLCData = require('./XMLCData');\n          XMLComment = require('./XMLComment');\n          XMLDeclaration = require('./XMLDeclaration');\n          XMLDocType = require('./XMLDocType');\n          XMLRaw = require('./XMLRaw');\n          XMLText = require('./XMLText');\n          XMLProcessingInstruction = require('./XMLProcessingInstruction');\n          XMLDummy = require('./XMLDummy');\n          NodeType = require('./NodeType');\n          XMLNodeList = require('./XMLNodeList');\n          XMLNamedNodeMap = require('./XMLNamedNodeMap');\n          DocumentPosition = require('./DocumentPosition');\n        }\n      } // Sets the parent node of this node and its children recursively\n      // `parent` the parent node\n\n\n      _createClass(XMLNode, [{\n        key: \"setParent\",\n        value: function setParent(parent) {\n          var child, j, len, ref1, results;\n          this.parent = parent;\n\n          if (parent) {\n            this.options = parent.options;\n            this.stringify = parent.stringify;\n          }\n\n          ref1 = this.children;\n          results = [];\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n            results.push(child.setParent(this));\n          }\n\n          return results;\n        } // Creates a child element node\n        // `name` node name or an object describing the XML tree\n        // `attributes` an object containing name/value pairs of attributes\n        // `text` element text\n\n      }, {\n        key: \"element\",\n        value: function element(name, attributes, text) {\n          var childNode, item, j, k, key, lastChild, len, len1, val;\n          lastChild = null;\n\n          if (attributes === null && text == null) {\n            attributes = {};\n            text = null;\n          }\n\n          if (attributes == null) {\n            attributes = {};\n          }\n\n          attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n          if (!isObject(attributes)) {\n            var _ref = [attributes, text];\n            text = _ref[0];\n            attributes = _ref[1];\n          }\n\n          if (name != null) {\n            name = getValue(name);\n          } // expand if array\n\n\n          if (Array.isArray(name)) {\n            for (j = 0, len = name.length; j < len; j++) {\n              item = name[j];\n              lastChild = this.element(item);\n            } // evaluate if function\n\n          } else if (isFunction(name)) {\n            lastChild = this.element(name.apply()); // expand if object\n          } else if (isObject(name)) {\n            for (key in name) {\n              if (!hasProp.call(name, key)) continue;\n              val = name[key];\n\n              if (isFunction(val)) {\n                // evaluate if function\n                val = val.apply();\n              } // assign attributes\n\n\n              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val); // skip empty arrays\n              } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n                lastChild = this.dummy(); // empty objects produce one node\n              } else if (isObject(val) && isEmpty(val)) {\n                lastChild = this.element(key); // skip null and undefined nodes\n              } else if (!this.options.keepNullNodes && val == null) {\n                lastChild = this.dummy(); // expand list by creating child nodes\n              } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n                for (k = 0, len1 = val.length; k < len1; k++) {\n                  item = val[k];\n                  childNode = {};\n                  childNode[key] = item;\n                  lastChild = this.element(childNode);\n                } // expand child nodes under parent\n\n              } else if (isObject(val)) {\n                // if the key is #text expand child nodes under this node to support mixed content\n                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n                  lastChild = this.element(val);\n                } else {\n                  lastChild = this.element(key);\n                  lastChild.element(val);\n                }\n              } else {\n                // text node\n                lastChild = this.element(key, val);\n              }\n            } // skip null nodes\n\n          } else if (!this.options.keepNullNodes && text === null) {\n            lastChild = this.dummy();\n          } else {\n            // text node\n            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n              lastChild = this.text(text); // cdata node\n            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n              lastChild = this.cdata(text); // comment node\n            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n              lastChild = this.comment(text); // raw text node\n            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n              lastChild = this.raw(text); // processing instruction\n            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n            } else {\n              // element node\n              lastChild = this.node(name, attributes, text);\n            }\n          }\n\n          if (lastChild == null) {\n            throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n          }\n\n          return lastChild;\n        } // Creates a child element node before the current node\n        // `name` node name or an object describing the XML tree\n        // `attributes` an object containing name/value pairs of attributes\n        // `text` element text\n\n      }, {\n        key: \"insertBefore\",\n        value: function insertBefore(name, attributes, text) {\n          var child, i, newChild, refChild, removed; // DOM level 1\n          // insertBefore(newChild, refChild) inserts the child node newChild before refChild\n\n          if (name != null ? name.type : void 0) {\n            newChild = name;\n            refChild = attributes;\n            newChild.setParent(this);\n\n            if (refChild) {\n              // temporarily remove children starting *with* refChild\n              i = children.indexOf(refChild);\n              removed = children.splice(i); // add the new child\n\n              children.push(newChild); // add back removed children after new child\n\n              Array.prototype.push.apply(children, removed);\n            } else {\n              children.push(newChild);\n            }\n\n            return newChild;\n          } else {\n            if (this.isRoot) {\n              throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n            } // temporarily remove children starting *with* this\n\n\n            i = this.parent.children.indexOf(this);\n            removed = this.parent.children.splice(i); // add the new child\n\n            child = this.parent.element(name, attributes, text); // add back removed children after new child\n\n            Array.prototype.push.apply(this.parent.children, removed);\n            return child;\n          }\n        } // Creates a child element node after the current node\n        // `name` node name or an object describing the XML tree\n        // `attributes` an object containing name/value pairs of attributes\n        // `text` element text\n\n      }, {\n        key: \"insertAfter\",\n        value: function insertAfter(name, attributes, text) {\n          var child, i, removed;\n\n          if (this.isRoot) {\n            throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n          } // temporarily remove children starting *after* this\n\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i + 1); // add the new child\n\n          child = this.parent.element(name, attributes, text); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return child;\n        } // Deletes a child element node\n\n      }, {\n        key: \"remove\",\n        value: function remove() {\n          var i, ref1;\n\n          if (this.isRoot) {\n            throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n          }\n\n          i = this.parent.children.indexOf(this);\n          splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n          return this.parent;\n        } // Creates a node\n        // `name` name of the node\n        // `attributes` an object containing name/value pairs of attributes\n        // `text` element text\n\n      }, {\n        key: \"node\",\n        value: function node(name, attributes, text) {\n          var child;\n\n          if (name != null) {\n            name = getValue(name);\n          }\n\n          attributes || (attributes = {});\n          attributes = getValue(attributes); // swap argument order: text <-> attributes\n\n          if (!isObject(attributes)) {\n            var _ref2 = [attributes, text];\n            text = _ref2[0];\n            attributes = _ref2[1];\n          }\n\n          child = new XMLElement(this, name, attributes);\n\n          if (text != null) {\n            child.text(text);\n          }\n\n          this.children.push(child);\n          return child;\n        } // Creates a text node\n        // `value` element text\n\n      }, {\n        key: \"text\",\n        value: function text(value) {\n          var child;\n\n          if (isObject(value)) {\n            this.element(value);\n          }\n\n          child = new XMLText(this, value);\n          this.children.push(child);\n          return this;\n        } // Creates a CDATA node\n        // `value` element text without CDATA delimiters\n\n      }, {\n        key: \"cdata\",\n        value: function cdata(value) {\n          var child;\n          child = new XMLCData(this, value);\n          this.children.push(child);\n          return this;\n        } // Creates a comment node\n        // `value` comment text\n\n      }, {\n        key: \"comment\",\n        value: function comment(value) {\n          var child;\n          child = new XMLComment(this, value);\n          this.children.push(child);\n          return this;\n        } // Creates a comment node before the current node\n        // `value` comment text\n\n      }, {\n        key: \"commentBefore\",\n        value: function commentBefore(value) {\n          var child, i, removed; // temporarily remove children starting *with* this\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i); // add the new child\n\n          child = this.parent.comment(value); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return this;\n        } // Creates a comment node after the current node\n        // `value` comment text\n\n      }, {\n        key: \"commentAfter\",\n        value: function commentAfter(value) {\n          var child, i, removed; // temporarily remove children starting *after* this\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i + 1); // add the new child\n\n          child = this.parent.comment(value); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return this;\n        } // Adds unescaped raw text\n        // `value` text\n\n      }, {\n        key: \"raw\",\n        value: function raw(value) {\n          var child;\n          child = new XMLRaw(this, value);\n          this.children.push(child);\n          return this;\n        } // Adds a dummy node\n\n      }, {\n        key: \"dummy\",\n        value: function dummy() {\n          var child;\n          child = new XMLDummy(this); // Normally when a new node is created it is added to the child node collection.\n          // However, dummy nodes are never added to the XML tree. They are created while\n          // converting JS objects to XML nodes in order not to break the recursive function\n          // chain. They can be thought of as invisible nodes. They can be traversed through\n          // by using prev(), next(), up(), etc. functions but they do not exists in the tree.\n          // @children.push child\n\n          return child;\n        } // Adds a processing instruction\n        // `target` instruction target\n        // `value` instruction value\n\n      }, {\n        key: \"instruction\",\n        value: function instruction(target, value) {\n          var insTarget, insValue, instruction, j, len;\n\n          if (target != null) {\n            target = getValue(target);\n          }\n\n          if (value != null) {\n            value = getValue(value);\n          }\n\n          if (Array.isArray(target)) {\n            // expand if array\n            for (j = 0, len = target.length; j < len; j++) {\n              insTarget = target[j];\n              this.instruction(insTarget);\n            }\n          } else if (isObject(target)) {\n            // expand if object\n            for (insTarget in target) {\n              if (!hasProp.call(target, insTarget)) continue;\n              insValue = target[insTarget];\n              this.instruction(insTarget, insValue);\n            }\n          } else {\n            if (isFunction(value)) {\n              value = value.apply();\n            }\n\n            instruction = new XMLProcessingInstruction(this, target, value);\n            this.children.push(instruction);\n          }\n\n          return this;\n        } // Creates a processing instruction node before the current node\n        // `target` instruction target\n        // `value` instruction value\n\n      }, {\n        key: \"instructionBefore\",\n        value: function instructionBefore(target, value) {\n          var child, i, removed; // temporarily remove children starting *with* this\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i); // add the new child\n\n          child = this.parent.instruction(target, value); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return this;\n        } // Creates a processing instruction node after the current node\n        // `target` instruction target\n        // `value` instruction value\n\n      }, {\n        key: \"instructionAfter\",\n        value: function instructionAfter(target, value) {\n          var child, i, removed; // temporarily remove children starting *after* this\n\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i + 1); // add the new child\n\n          child = this.parent.instruction(target, value); // add back removed children after new child\n\n          Array.prototype.push.apply(this.parent.children, removed);\n          return this;\n        } // Creates the xml declaration\n        // `version` A version number string, e.g. 1.0\n        // `encoding` Encoding declaration, e.g. UTF-8\n        // `standalone` standalone document declaration: true or false\n\n      }, {\n        key: \"declaration\",\n        value: function declaration(version, encoding, standalone) {\n          var doc, xmldec;\n          doc = this.document();\n          xmldec = new XMLDeclaration(doc, version, encoding, standalone); // Replace XML declaration if exists, otherwise insert at top\n\n          if (doc.children.length === 0) {\n            doc.children.unshift(xmldec);\n          } else if (doc.children[0].type === NodeType.Declaration) {\n            doc.children[0] = xmldec;\n          } else {\n            doc.children.unshift(xmldec);\n          }\n\n          return doc.root() || doc;\n        } // Creates the document type declaration\n        // `pubID` the public identifier of the external subset\n        // `sysID` the system identifier of the external subset\n\n      }, {\n        key: \"dtd\",\n        value: function dtd(pubID, sysID) {\n          var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n          doc = this.document();\n          doctype = new XMLDocType(doc, pubID, sysID);\n          ref1 = doc.children; // Replace DTD if exists\n\n          for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n            child = ref1[i];\n\n            if (child.type === NodeType.DocType) {\n              doc.children[i] = doctype;\n              return doctype;\n            }\n          }\n\n          ref2 = doc.children; // insert before root node if the root node exists\n\n          for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n            child = ref2[i];\n\n            if (child.isRoot) {\n              doc.children.splice(i, 0, doctype);\n              return doctype;\n            }\n          } // otherwise append to end\n\n\n          doc.children.push(doctype);\n          return doctype;\n        } // Gets the parent node\n\n      }, {\n        key: \"up\",\n        value: function up() {\n          if (this.isRoot) {\n            throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n          }\n\n          return this.parent;\n        } // Gets the root node\n\n      }, {\n        key: \"root\",\n        value: function root() {\n          var node;\n          node = this;\n\n          while (node) {\n            if (node.type === NodeType.Document) {\n              return node.rootObject;\n            } else if (node.isRoot) {\n              return node;\n            } else {\n              node = node.parent;\n            }\n          }\n        } // Gets the node representing the XML document\n\n      }, {\n        key: \"document\",\n        value: function document() {\n          var node;\n          node = this;\n\n          while (node) {\n            if (node.type === NodeType.Document) {\n              return node;\n            } else {\n              node = node.parent;\n            }\n          }\n        } // Ends the document and converts string\n\n      }, {\n        key: \"end\",\n        value: function end(options) {\n          return this.document().end(options);\n        } // Gets the previous node\n\n      }, {\n        key: \"prev\",\n        value: function prev() {\n          var i;\n          i = this.parent.children.indexOf(this);\n\n          if (i < 1) {\n            throw new Error(\"Already at the first node. \" + this.debugInfo());\n          }\n\n          return this.parent.children[i - 1];\n        } // Gets the next node\n\n      }, {\n        key: \"next\",\n        value: function next() {\n          var i;\n          i = this.parent.children.indexOf(this);\n\n          if (i === -1 || i === this.parent.children.length - 1) {\n            throw new Error(\"Already at the last node. \" + this.debugInfo());\n          }\n\n          return this.parent.children[i + 1];\n        } // Imports cloned root from another XML document\n        // `doc` the XML document to insert nodes from\n\n      }, {\n        key: \"importDocument\",\n        value: function importDocument(doc) {\n          var child, clonedRoot, j, len, ref1;\n          clonedRoot = doc.root().clone();\n          clonedRoot.parent = this;\n          clonedRoot.isRoot = false;\n          this.children.push(clonedRoot); // set properties if imported element becomes the root node\n\n          if (this.type === NodeType.Document) {\n            clonedRoot.isRoot = true;\n            clonedRoot.documentObject = this;\n            this.rootObject = clonedRoot; // set dtd name\n\n            if (this.children) {\n              ref1 = this.children;\n\n              for (j = 0, len = ref1.length; j < len; j++) {\n                child = ref1[j];\n\n                if (child.type === NodeType.DocType) {\n                  child.name = clonedRoot.name;\n                  break;\n                }\n              }\n            }\n          }\n\n          return this;\n        } // Returns debug string for this node\n\n      }, {\n        key: \"debugInfo\",\n        value: function debugInfo(name) {\n          var ref1, ref2;\n          name = name || this.name;\n\n          if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {\n            return \"\";\n          } else if (name == null) {\n            return \"parent: <\" + this.parent.name + \">\";\n          } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {\n            return \"node: <\" + name + \">\";\n          } else {\n            return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n          }\n        } // Aliases\n\n      }, {\n        key: \"ele\",\n        value: function ele(name, attributes, text) {\n          return this.element(name, attributes, text);\n        }\n      }, {\n        key: \"nod\",\n        value: function nod(name, attributes, text) {\n          return this.node(name, attributes, text);\n        }\n      }, {\n        key: \"txt\",\n        value: function txt(value) {\n          return this.text(value);\n        }\n      }, {\n        key: \"dat\",\n        value: function dat(value) {\n          return this.cdata(value);\n        }\n      }, {\n        key: \"com\",\n        value: function com(value) {\n          return this.comment(value);\n        }\n      }, {\n        key: \"ins\",\n        value: function ins(target, value) {\n          return this.instruction(target, value);\n        }\n      }, {\n        key: \"doc\",\n        value: function doc() {\n          return this.document();\n        }\n      }, {\n        key: \"dec\",\n        value: function dec(version, encoding, standalone) {\n          return this.declaration(version, encoding, standalone);\n        }\n      }, {\n        key: \"e\",\n        value: function e(name, attributes, text) {\n          return this.element(name, attributes, text);\n        }\n      }, {\n        key: \"n\",\n        value: function n(name, attributes, text) {\n          return this.node(name, attributes, text);\n        }\n      }, {\n        key: \"t\",\n        value: function t(value) {\n          return this.text(value);\n        }\n      }, {\n        key: \"d\",\n        value: function d(value) {\n          return this.cdata(value);\n        }\n      }, {\n        key: \"c\",\n        value: function c(value) {\n          return this.comment(value);\n        }\n      }, {\n        key: \"r\",\n        value: function r(value) {\n          return this.raw(value);\n        }\n      }, {\n        key: \"i\",\n        value: function i(target, value) {\n          return this.instruction(target, value);\n        }\n      }, {\n        key: \"u\",\n        value: function u() {\n          return this.up();\n        } // can be deprecated in a future release\n\n      }, {\n        key: \"importXMLBuilder\",\n        value: function importXMLBuilder(doc) {\n          return this.importDocument(doc);\n        } // Adds or modifies an attribute.\n        // `name` attribute name\n        // `value` attribute value\n\n      }, {\n        key: \"attribute\",\n        value: function attribute(name, value) {\n          throw new Error(\"attribute() applies to element nodes only.\");\n        }\n      }, {\n        key: \"att\",\n        value: function att(name, value) {\n          return this.attribute(name, value);\n        }\n      }, {\n        key: \"a\",\n        value: function a(name, value) {\n          return this.attribute(name, value);\n        } // Removes an attribute\n        // `name` attribute name\n\n      }, {\n        key: \"removeAttribute\",\n        value: function removeAttribute(name) {\n          throw new Error(\"attribute() applies to element nodes only.\");\n        } // DOM level 1 functions to be implemented later\n\n      }, {\n        key: \"replaceChild\",\n        value: function replaceChild(newChild, oldChild) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"removeChild\",\n        value: function removeChild(oldChild) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"appendChild\",\n        value: function appendChild(newChild) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"hasChildNodes\",\n        value: function hasChildNodes() {\n          return this.children.length !== 0;\n        }\n      }, {\n        key: \"cloneNode\",\n        value: function cloneNode(deep) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"normalize\",\n        value: function normalize() {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        } // DOM level 2\n\n      }, {\n        key: \"isSupported\",\n        value: function isSupported(feature, version) {\n          return true;\n        }\n      }, {\n        key: \"hasAttributes\",\n        value: function hasAttributes() {\n          return this.attribs.length !== 0;\n        } // DOM level 3 functions to be implemented later\n\n      }, {\n        key: \"compareDocumentPosition\",\n        value: function compareDocumentPosition(other) {\n          var ref, res;\n          ref = this;\n\n          if (ref === other) {\n            return 0;\n          } else if (this.document() !== other.document()) {\n            res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n\n            if (Math.random() < 0.5) {\n              res |= DocumentPosition.Preceding;\n            } else {\n              res |= DocumentPosition.Following;\n            }\n\n            return res;\n          } else if (ref.isAncestor(other)) {\n            return DocumentPosition.Contains | DocumentPosition.Preceding;\n          } else if (ref.isDescendant(other)) {\n            return DocumentPosition.Contains | DocumentPosition.Following;\n          } else if (ref.isPreceding(other)) {\n            return DocumentPosition.Preceding;\n          } else {\n            return DocumentPosition.Following;\n          }\n        }\n      }, {\n        key: \"isSameNode\",\n        value: function isSameNode(other) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"lookupPrefix\",\n        value: function lookupPrefix(namespaceURI) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"isDefaultNamespace\",\n        value: function isDefaultNamespace(namespaceURI) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"lookupNamespaceURI\",\n        value: function lookupNamespaceURI(prefix) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"isEqualNode\",\n        value: function isEqualNode(node) {\n          var i, j, ref1;\n\n          if (node.nodeType !== this.nodeType) {\n            return false;\n          }\n\n          if (node.children.length !== this.children.length) {\n            return false;\n          }\n\n          for (i = j = 0, ref1 = this.children.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n            if (!this.children[i].isEqualNode(node.children[i])) {\n              return false;\n            }\n          }\n\n          return true;\n        }\n      }, {\n        key: \"getFeature\",\n        value: function getFeature(feature, version) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"setUserData\",\n        value: function setUserData(key, data, handler) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        }\n      }, {\n        key: \"getUserData\",\n        value: function getUserData(key) {\n          throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n        } // Returns true if other is an inclusive descendant of node,\n        // and false otherwise.\n\n      }, {\n        key: \"contains\",\n        value: function contains(other) {\n          if (!other) {\n            return false;\n          }\n\n          return other === this || this.isDescendant(other);\n        } // An object A is called a descendant of an object B, if either A is \n        // a child of B or A is a child of an object C that is a descendant of B.\n\n      }, {\n        key: \"isDescendant\",\n        value: function isDescendant(node) {\n          var child, isDescendantChild, j, len, ref1;\n          ref1 = this.children;\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n\n            if (node === child) {\n              return true;\n            }\n\n            isDescendantChild = child.isDescendant(node);\n\n            if (isDescendantChild) {\n              return true;\n            }\n          }\n\n          return false;\n        } // An object A is called an ancestor of an object B if and only if\n        // B is a descendant of A.\n\n      }, {\n        key: \"isAncestor\",\n        value: function isAncestor(node) {\n          return node.isDescendant(this);\n        } // An object A is preceding an object B if A and B are in the \n        // same tree and A comes before B in tree order.\n\n      }, {\n        key: \"isPreceding\",\n        value: function isPreceding(node) {\n          var nodePos, thisPos;\n          nodePos = this.treePosition(node);\n          thisPos = this.treePosition(this);\n\n          if (nodePos === -1 || thisPos === -1) {\n            return false;\n          } else {\n            return nodePos < thisPos;\n          }\n        } // An object A is folllowing an object B if A and B are in the \n        // same tree and A comes after B in tree order.\n\n      }, {\n        key: \"isFollowing\",\n        value: function isFollowing(node) {\n          var nodePos, thisPos;\n          nodePos = this.treePosition(node);\n          thisPos = this.treePosition(this);\n\n          if (nodePos === -1 || thisPos === -1) {\n            return false;\n          } else {\n            return nodePos > thisPos;\n          }\n        } // Returns the preorder position of the given node in the tree, or -1\n        // if the node is not in the tree.\n\n      }, {\n        key: \"treePosition\",\n        value: function treePosition(node) {\n          var found, pos;\n          pos = 0;\n          found = false;\n          this.foreachTreeNode(this.document(), function (childNode) {\n            pos++;\n\n            if (!found && childNode === node) {\n              return found = true;\n            }\n          });\n\n          if (found) {\n            return pos;\n          } else {\n            return -1;\n          }\n        } // Depth-first preorder traversal through the XML tree\n\n      }, {\n        key: \"foreachTreeNode\",\n        value: function foreachTreeNode(node, func) {\n          var child, j, len, ref1, res;\n          node || (node = this.document());\n          ref1 = node.children;\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n\n            if (res = func(child)) {\n              return res;\n            } else {\n              res = this.foreachTreeNode(child, func);\n\n              if (res) {\n                return res;\n              }\n            }\n          }\n        }\n      }]);\n\n      return XMLNode;\n    }();\n\n    ; // DOM level 1\n\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function get() {\n        return this.name;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function get() {\n        return this.type;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function get() {\n        return this.value;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function get() {\n        return this.parent;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function get() {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n\n        return this.childNodeList;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function get() {\n        return this.children[0] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function get() {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function get() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function get() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function get() {\n        return this.document() || null;\n      }\n    }); // DOM level 3\n\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function get() {\n        var child, j, len, ref1, str;\n\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref1 = this.children;\n\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function set(value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n    return XMLNode;\n  }.call(this);\n}).call(this);","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/xmlbuilder/lib/XMLNode.js"],"names":["DocumentPosition","NodeType","XMLCData","XMLComment","XMLDeclaration","XMLDocType","XMLDummy","XMLElement","XMLNamedNodeMap","XMLNode","XMLNodeList","XMLProcessingInstruction","XMLRaw","XMLText","getValue","isEmpty","isFunction","isObject","hasProp","hasOwnProperty","splice","require","module","exports","parent1","parent","options","stringify","value","children","baseURI","child","j","len","ref1","results","length","push","setParent","name","attributes","text","childNode","item","k","key","lastChild","len1","val","Array","isArray","element","apply","call","ignoreDecorators","convertAttKey","indexOf","attribute","substr","separateArrayItems","dummy","keepNullNodes","convertTextKey","convertCDataKey","cdata","convertCommentKey","comment","convertRawKey","raw","convertPIKey","instruction","node","Error","debugInfo","i","newChild","refChild","removed","type","prototype","isRoot","concat","target","insTarget","insValue","version","encoding","standalone","doc","xmldec","document","unshift","Declaration","root","pubID","sysID","doctype","ref2","DocType","Document","rootObject","end","clonedRoot","clone","documentObject","declaration","up","importDocument","oldChild","deep","feature","attribs","other","ref","res","Disconnected","ImplementationSpecific","Math","random","Preceding","Following","isAncestor","Contains","isDescendant","isPreceding","namespaceURI","prefix","nodeType","isEqualNode","data","handler","isDescendantChild","nodePos","thisPos","treePosition","found","pos","foreachTreeNode","func","Object","defineProperty","get","childNodeList","nodes","str","Element","DocumentFragment","textContent","set"],"mappings":"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","sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject,\n    hasProp = {}.hasOwnProperty,\n    splice = [].splice;\n\n  ({isObject, isFunction, isEmpty, getValue} = require('./Utility'));\n\n  XMLElement = null;\n\n  XMLCData = null;\n\n  XMLComment = null;\n\n  XMLDeclaration = null;\n\n  XMLDocType = null;\n\n  XMLRaw = null;\n\n  XMLText = null;\n\n  XMLProcessingInstruction = null;\n\n  XMLDummy = null;\n\n  NodeType = null;\n\n  XMLNodeList = null;\n\n  XMLNamedNodeMap = null;\n\n  DocumentPosition = null;\n\n  // Represents a generic XMl element\n  module.exports = XMLNode = (function() {\n    class XMLNode {\n      // Initializes a new instance of `XMLNode`\n\n      // `parent` the parent node\n      constructor(parent1) {\n        this.parent = parent1;\n        if (this.parent) {\n          this.options = this.parent.options;\n          this.stringify = this.parent.stringify;\n        }\n        this.value = null;\n        this.children = [];\n        this.baseURI = null;\n        // first execution, load dependencies that are otherwise\n        // circular (so we can't load them at the top)\n        if (!XMLElement) {\n          XMLElement = require('./XMLElement');\n          XMLCData = require('./XMLCData');\n          XMLComment = require('./XMLComment');\n          XMLDeclaration = require('./XMLDeclaration');\n          XMLDocType = require('./XMLDocType');\n          XMLRaw = require('./XMLRaw');\n          XMLText = require('./XMLText');\n          XMLProcessingInstruction = require('./XMLProcessingInstruction');\n          XMLDummy = require('./XMLDummy');\n          NodeType = require('./NodeType');\n          XMLNodeList = require('./XMLNodeList');\n          XMLNamedNodeMap = require('./XMLNamedNodeMap');\n          DocumentPosition = require('./DocumentPosition');\n        }\n      }\n\n      \n      // Sets the parent node of this node and its children recursively\n\n      // `parent` the parent node\n      setParent(parent) {\n        var child, j, len, ref1, results;\n        this.parent = parent;\n        if (parent) {\n          this.options = parent.options;\n          this.stringify = parent.stringify;\n        }\n        ref1 = this.children;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          results.push(child.setParent(this));\n        }\n        return results;\n      }\n\n      // Creates a child element node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      element(name, attributes, text) {\n        var childNode, item, j, k, key, lastChild, len, len1, val;\n        lastChild = null;\n        if (attributes === null && (text == null)) {\n          [attributes, text] = [{}, null];\n        }\n        if (attributes == null) {\n          attributes = {};\n        }\n        attributes = getValue(attributes);\n        // swap argument order: text <-> attributes\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n        if (name != null) {\n          name = getValue(name);\n        }\n        // expand if array\n        if (Array.isArray(name)) {\n          for (j = 0, len = name.length; j < len; j++) {\n            item = name[j];\n            lastChild = this.element(item);\n          }\n        // evaluate if function\n        } else if (isFunction(name)) {\n          lastChild = this.element(name.apply());\n        // expand if object\n        } else if (isObject(name)) {\n          for (key in name) {\n            if (!hasProp.call(name, key)) continue;\n            val = name[key];\n            if (isFunction(val)) {\n              // evaluate if function\n              val = val.apply();\n            }\n            // assign attributes\n            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n            // skip empty arrays\n            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n              lastChild = this.dummy();\n            // empty objects produce one node\n            } else if (isObject(val) && isEmpty(val)) {\n              lastChild = this.element(key);\n            // skip null and undefined nodes\n            } else if (!this.options.keepNullNodes && (val == null)) {\n              lastChild = this.dummy();\n            \n            // expand list by creating child nodes\n            } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n              for (k = 0, len1 = val.length; k < len1; k++) {\n                item = val[k];\n                childNode = {};\n                childNode[key] = item;\n                lastChild = this.element(childNode);\n              }\n            \n            // expand child nodes under parent\n            } else if (isObject(val)) {\n              // if the key is #text expand child nodes under this node to support mixed content\n              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n                lastChild = this.element(val);\n              } else {\n                lastChild = this.element(key);\n                lastChild.element(val);\n              }\n            } else {\n              \n              // text node\n              lastChild = this.element(key, val);\n            }\n          }\n        // skip null nodes\n        } else if (!this.options.keepNullNodes && text === null) {\n          lastChild = this.dummy();\n        } else {\n          // text node\n          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n            lastChild = this.text(text);\n          // cdata node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n            lastChild = this.cdata(text);\n          // comment node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n            lastChild = this.comment(text);\n          // raw text node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n            lastChild = this.raw(text);\n          // processing instruction\n          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n          } else {\n            // element node\n            lastChild = this.node(name, attributes, text);\n          }\n        }\n        if (lastChild == null) {\n          throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n        }\n        return lastChild;\n      }\n\n      // Creates a child element node before the current node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      insertBefore(name, attributes, text) {\n        var child, i, newChild, refChild, removed;\n        // DOM level 1\n        // insertBefore(newChild, refChild) inserts the child node newChild before refChild\n        if (name != null ? name.type : void 0) {\n          newChild = name;\n          refChild = attributes;\n          newChild.setParent(this);\n          if (refChild) {\n            // temporarily remove children starting *with* refChild\n            i = children.indexOf(refChild);\n            removed = children.splice(i);\n            \n            // add the new child\n            children.push(newChild);\n            \n            // add back removed children after new child\n            Array.prototype.push.apply(children, removed);\n          } else {\n            children.push(newChild);\n          }\n          return newChild;\n        } else {\n          if (this.isRoot) {\n            throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n          }\n          \n          // temporarily remove children starting *with* this\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i);\n          \n          // add the new child\n          child = this.parent.element(name, attributes, text);\n          \n          // add back removed children after new child\n          Array.prototype.push.apply(this.parent.children, removed);\n          return child;\n        }\n      }\n\n      // Creates a child element node after the current node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      insertAfter(name, attributes, text) {\n        var child, i, removed;\n        if (this.isRoot) {\n          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n        }\n        \n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        \n        // add the new child\n        child = this.parent.element(name, attributes, text);\n        \n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return child;\n      }\n\n      // Deletes a child element node\n\n      remove() {\n        var i, ref1;\n        if (this.isRoot) {\n          throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n        }\n        i = this.parent.children.indexOf(this);\n        splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n        return this.parent;\n      }\n\n      // Creates a node\n\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      node(name, attributes, text) {\n        var child;\n        if (name != null) {\n          name = getValue(name);\n        }\n        attributes || (attributes = {});\n        attributes = getValue(attributes);\n        // swap argument order: text <-> attributes\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n        child = new XMLElement(this, name, attributes);\n        if (text != null) {\n          child.text(text);\n        }\n        this.children.push(child);\n        return child;\n      }\n\n      // Creates a text node\n\n      // `value` element text\n      text(value) {\n        var child;\n        if (isObject(value)) {\n          this.element(value);\n        }\n        child = new XMLText(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a CDATA node\n\n      // `value` element text without CDATA delimiters\n      cdata(value) {\n        var child;\n        child = new XMLCData(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a comment node\n\n      // `value` comment text\n      comment(value) {\n        var child;\n        child = new XMLComment(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a comment node before the current node\n\n      // `value` comment text\n      commentBefore(value) {\n        var child, i, removed;\n        // temporarily remove children starting *with* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        // add the new child\n        child = this.parent.comment(value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates a comment node after the current node\n\n      // `value` comment text\n      commentAfter(value) {\n        var child, i, removed;\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        // add the new child\n        child = this.parent.comment(value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Adds unescaped raw text\n\n      // `value` text\n      raw(value) {\n        var child;\n        child = new XMLRaw(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Adds a dummy node\n      dummy() {\n        var child;\n        child = new XMLDummy(this);\n        // Normally when a new node is created it is added to the child node collection.\n        // However, dummy nodes are never added to the XML tree. They are created while\n        // converting JS objects to XML nodes in order not to break the recursive function\n        // chain. They can be thought of as invisible nodes. They can be traversed through\n        // by using prev(), next(), up(), etc. functions but they do not exists in the tree.\n\n        // @children.push child\n        return child;\n      }\n\n      // Adds a processing instruction\n\n      // `target` instruction target\n      // `value` instruction value\n      instruction(target, value) {\n        var insTarget, insValue, instruction, j, len;\n        if (target != null) {\n          target = getValue(target);\n        }\n        if (value != null) {\n          value = getValue(value);\n        }\n        if (Array.isArray(target)) { // expand if array\n          for (j = 0, len = target.length; j < len; j++) {\n            insTarget = target[j];\n            this.instruction(insTarget);\n          }\n        } else if (isObject(target)) { // expand if object\n          for (insTarget in target) {\n            if (!hasProp.call(target, insTarget)) continue;\n            insValue = target[insTarget];\n            this.instruction(insTarget, insValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n          instruction = new XMLProcessingInstruction(this, target, value);\n          this.children.push(instruction);\n        }\n        return this;\n      }\n\n      // Creates a processing instruction node before the current node\n\n      // `target` instruction target\n      // `value` instruction value\n      instructionBefore(target, value) {\n        var child, i, removed;\n        // temporarily remove children starting *with* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        // add the new child\n        child = this.parent.instruction(target, value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates a processing instruction node after the current node\n\n      // `target` instruction target\n      // `value` instruction value\n      instructionAfter(target, value) {\n        var child, i, removed;\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        // add the new child\n        child = this.parent.instruction(target, value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates the xml declaration\n\n      // `version` A version number string, e.g. 1.0\n      // `encoding` Encoding declaration, e.g. UTF-8\n      // `standalone` standalone document declaration: true or false\n      declaration(version, encoding, standalone) {\n        var doc, xmldec;\n        doc = this.document();\n        xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n        // Replace XML declaration if exists, otherwise insert at top\n        if (doc.children.length === 0) {\n          doc.children.unshift(xmldec);\n        } else if (doc.children[0].type === NodeType.Declaration) {\n          doc.children[0] = xmldec;\n        } else {\n          doc.children.unshift(xmldec);\n        }\n        return doc.root() || doc;\n      }\n\n      // Creates the document type declaration\n\n      // `pubID` the public identifier of the external subset\n      // `sysID` the system identifier of the external subset\n      dtd(pubID, sysID) {\n        var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n        doc = this.document();\n        doctype = new XMLDocType(doc, pubID, sysID);\n        ref1 = doc.children;\n        // Replace DTD if exists\n        for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n          child = ref1[i];\n          if (child.type === NodeType.DocType) {\n            doc.children[i] = doctype;\n            return doctype;\n          }\n        }\n        ref2 = doc.children;\n        // insert before root node if the root node exists\n        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n          child = ref2[i];\n          if (child.isRoot) {\n            doc.children.splice(i, 0, doctype);\n            return doctype;\n          }\n        }\n        // otherwise append to end\n        doc.children.push(doctype);\n        return doctype;\n      }\n\n      // Gets the parent node\n      up() {\n        if (this.isRoot) {\n          throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n        }\n        return this.parent;\n      }\n\n      // Gets the root node\n      root() {\n        var node;\n        node = this;\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node.rootObject;\n          } else if (node.isRoot) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      }\n\n      // Gets the node representing the XML document\n      document() {\n        var node;\n        node = this;\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      }\n\n      // Ends the document and converts string\n      end(options) {\n        return this.document().end(options);\n      }\n\n      // Gets the previous node\n      prev() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        if (i < 1) {\n          throw new Error(\"Already at the first node. \" + this.debugInfo());\n        }\n        return this.parent.children[i - 1];\n      }\n\n      // Gets the next node\n      next() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        if (i === -1 || i === this.parent.children.length - 1) {\n          throw new Error(\"Already at the last node. \" + this.debugInfo());\n        }\n        return this.parent.children[i + 1];\n      }\n\n      // Imports cloned root from another XML document\n\n      // `doc` the XML document to insert nodes from\n      importDocument(doc) {\n        var child, clonedRoot, j, len, ref1;\n        clonedRoot = doc.root().clone();\n        clonedRoot.parent = this;\n        clonedRoot.isRoot = false;\n        this.children.push(clonedRoot);\n        // set properties if imported element becomes the root node\n        if (this.type === NodeType.Document) {\n          clonedRoot.isRoot = true;\n          clonedRoot.documentObject = this;\n          this.rootObject = clonedRoot;\n          // set dtd name\n          if (this.children) {\n            ref1 = this.children;\n            for (j = 0, len = ref1.length; j < len; j++) {\n              child = ref1[j];\n              if (child.type === NodeType.DocType) {\n                child.name = clonedRoot.name;\n                break;\n              }\n            }\n          }\n        }\n        return this;\n      }\n\n      \n      // Returns debug string for this node\n      debugInfo(name) {\n        var ref1, ref2;\n        name = name || this.name;\n        if ((name == null) && !((ref1 = this.parent) != null ? ref1.name : void 0)) {\n          return \"\";\n        } else if (name == null) {\n          return \"parent: <\" + this.parent.name + \">\";\n        } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {\n          return \"node: <\" + name + \">\";\n        } else {\n          return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n        }\n      }\n\n      // Aliases\n      ele(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      nod(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      txt(value) {\n        return this.text(value);\n      }\n\n      dat(value) {\n        return this.cdata(value);\n      }\n\n      com(value) {\n        return this.comment(value);\n      }\n\n      ins(target, value) {\n        return this.instruction(target, value);\n      }\n\n      doc() {\n        return this.document();\n      }\n\n      dec(version, encoding, standalone) {\n        return this.declaration(version, encoding, standalone);\n      }\n\n      e(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      n(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      t(value) {\n        return this.text(value);\n      }\n\n      d(value) {\n        return this.cdata(value);\n      }\n\n      c(value) {\n        return this.comment(value);\n      }\n\n      r(value) {\n        return this.raw(value);\n      }\n\n      i(target, value) {\n        return this.instruction(target, value);\n      }\n\n      u() {\n        return this.up();\n      }\n\n      // can be deprecated in a future release\n      importXMLBuilder(doc) {\n        return this.importDocument(doc);\n      }\n\n      // Adds or modifies an attribute.\n\n      // `name` attribute name\n      // `value` attribute value\n      attribute(name, value) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      att(name, value) {\n        return this.attribute(name, value);\n      }\n\n      a(name, value) {\n        return this.attribute(name, value);\n      }\n\n      // Removes an attribute\n\n      // `name` attribute name\n      removeAttribute(name) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      // DOM level 1 functions to be implemented later\n      replaceChild(newChild, oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      removeChild(oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      appendChild(newChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      hasChildNodes() {\n        return this.children.length !== 0;\n      }\n\n      cloneNode(deep) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      normalize() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      // DOM level 2\n      isSupported(feature, version) {\n        return true;\n      }\n\n      hasAttributes() {\n        return this.attribs.length !== 0;\n      }\n\n      // DOM level 3 functions to be implemented later\n      compareDocumentPosition(other) {\n        var ref, res;\n        ref = this;\n        if (ref === other) {\n          return 0;\n        } else if (this.document() !== other.document()) {\n          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n          if (Math.random() < 0.5) {\n            res |= DocumentPosition.Preceding;\n          } else {\n            res |= DocumentPosition.Following;\n          }\n          return res;\n        } else if (ref.isAncestor(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Preceding;\n        } else if (ref.isDescendant(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Following;\n        } else if (ref.isPreceding(other)) {\n          return DocumentPosition.Preceding;\n        } else {\n          return DocumentPosition.Following;\n        }\n      }\n\n      isSameNode(other) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupPrefix(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isDefaultNamespace(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupNamespaceURI(prefix) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isEqualNode(node) {\n        var i, j, ref1;\n        if (node.nodeType !== this.nodeType) {\n          return false;\n        }\n        if (node.children.length !== this.children.length) {\n          return false;\n        }\n        for (i = j = 0, ref1 = this.children.length - 1; (0 <= ref1 ? j <= ref1 : j >= ref1); i = 0 <= ref1 ? ++j : --j) {\n          if (!this.children[i].isEqualNode(node.children[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      getFeature(feature, version) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      setUserData(key, data, handler) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      getUserData(key) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      // Returns true if other is an inclusive descendant of node,\n      // and false otherwise.\n      contains(other) {\n        if (!other) {\n          return false;\n        }\n        return other === this || this.isDescendant(other);\n      }\n\n      // An object A is called a descendant of an object B, if either A is \n      // a child of B or A is a child of an object C that is a descendant of B.\n      isDescendant(node) {\n        var child, isDescendantChild, j, len, ref1;\n        ref1 = this.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (node === child) {\n            return true;\n          }\n          isDescendantChild = child.isDescendant(node);\n          if (isDescendantChild) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      // An object A is called an ancestor of an object B if and only if\n      // B is a descendant of A.\n      isAncestor(node) {\n        return node.isDescendant(this);\n      }\n\n      // An object A is preceding an object B if A and B are in the \n      // same tree and A comes before B in tree order.\n      isPreceding(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos < thisPos;\n        }\n      }\n\n      // An object A is folllowing an object B if A and B are in the \n      // same tree and A comes after B in tree order.\n      isFollowing(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos > thisPos;\n        }\n      }\n\n      // Returns the preorder position of the given node in the tree, or -1\n      // if the node is not in the tree.\n      treePosition(node) {\n        var found, pos;\n        pos = 0;\n        found = false;\n        this.foreachTreeNode(this.document(), function(childNode) {\n          pos++;\n          if (!found && childNode === node) {\n            return found = true;\n          }\n        });\n        if (found) {\n          return pos;\n        } else {\n          return -1;\n        }\n      }\n\n      \n      // Depth-first preorder traversal through the XML tree\n      foreachTreeNode(node, func) {\n        var child, j, len, ref1, res;\n        node || (node = this.document());\n        ref1 = node.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (res = func(child)) {\n            return res;\n          } else {\n            res = this.foreachTreeNode(child, func);\n            if (res) {\n              return res;\n            }\n          }\n        }\n      }\n\n    };\n\n    // DOM level 1\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function() {\n        return this.type;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function() {\n        return this.value;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function() {\n        return this.parent;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function() {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n        return this.childNodeList;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function() {\n        return this.children[0] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function() {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function() {\n        return this.document() || null;\n      }\n    });\n\n    // DOM level 3\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function() {\n        var child, j, len, ref1, str;\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref1 = this.children;\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function(value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    return XMLNode;\n\n  }).call(this);\n\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}