{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compare = void 0;\n\nvar util_1 = require(\"./util\");\n/**\nEvaluate `left === right`, treating `left` and `right` as ordered lists.\n\n@returns true iff `left` and `right` have identical lengths, and every element\n         of `left` is equal to the corresponding element of `right`. Equality is\n         determined recursivly, via `compare`.\n*/\n\n\nfunction compareArrays(left, right) {\n  var length = left.length;\n\n  if (length !== right.length) {\n    return false;\n  }\n\n  for (var i = 0; i < length; i++) {\n    if (!compare(left[i], right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\nEvaluate `left === right`, treating `left` and `right` as property maps.\n\n@returns true iff every property in `left` has a value equal to the value of the\n         corresponding property in `right`, and vice-versa, stopping as soon as\n         possible. Equality is determined recursivly, via `compare`.\n*/\n\n\nfunction compareObjects(left, right) {\n  var left_keys = Object.keys(left);\n  var right_keys = Object.keys(right);\n  var length = left_keys.length; // quick exit if the number of keys don't match up\n\n  if (length !== right_keys.length) {\n    return false;\n  } // we don't know for sure that Set(left_keys) is equal to Set(right_keys),\n  // much less that their values in left and right are equal, but if right\n  // contains each key in left, we know it can't have any additional keys\n\n\n  for (var i = 0; i < length; i++) {\n    var key = left_keys[i];\n\n    if (!util_1.hasOwnProperty.call(right, key) || !compare(left[key], right[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n`compare()` returns true if `left` and `right` are materially equal\n(i.e., would produce equivalent JSON), false otherwise.\n\n> Here, \"equal\" means that the value at the target location and the\n> value conveyed by \"value\" are of the same JSON type, and that they\n> are considered equal by the following rules for that type:\n> o  strings: are considered equal if they contain the same number of\n>    Unicode characters and their code points are byte-by-byte equal.\n> o  numbers: are considered equal if their values are numerically\n>    equal.\n> o  arrays: are considered equal if they contain the same number of\n>    values, and if each value can be considered equal to the value at\n>    the corresponding position in the other array, using this list of\n>    type-specific rules.\n> o  objects: are considered equal if they contain the same number of\n>    members, and if each member can be considered equal to a member in\n>    the other object, by comparing their keys (as strings) and their\n>    values (using this list of type-specific rules).\n> o  literals (false, true, and null): are considered equal if they are\n>    the same.\n*/\n\n\nfunction compare(left, right) {\n  // strict equality handles literals, numbers, and strings (a sufficient but not necessary cause)\n  if (left === right) {\n    return true;\n  }\n\n  var left_type = util_1.objectType(left);\n  var right_type = util_1.objectType(right); // check arrays\n\n  if (left_type == 'array' && right_type == 'array') {\n    return compareArrays(left, right);\n  } // check objects\n\n\n  if (left_type == 'object' && right_type == 'object') {\n    return compareObjects(left, right);\n  } // mismatched arrays & objects, etc., are always inequal\n\n\n  return false;\n}\n\nexports.compare = compare;","map":{"version":3,"sources":["/Users/stefanpjanic/Desktop/mango_dev/node_modules/rfc6902/equal.js"],"names":["Object","defineProperty","exports","value","compare","util_1","require","compareArrays","left","right","length","i","compareObjects","left_keys","keys","right_keys","key","hasOwnProperty","call","left_type","objectType","right_type"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AACA,IAAIC,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,KAA7B,EAAoC;AAChC,MAAIC,MAAM,GAAGF,IAAI,CAACE,MAAlB;;AACA,MAAIA,MAAM,KAAKD,KAAK,CAACC,MAArB,EAA6B;AACzB,WAAO,KAAP;AACH;;AACD,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAiC;AAC7B,QAAI,CAACP,OAAO,CAACI,IAAI,CAACG,CAAD,CAAL,EAAUF,KAAK,CAACE,CAAD,CAAf,CAAZ,EAAiC;AAC7B,aAAO,KAAP;AACH;AACJ;;AACD,SAAO,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBJ,IAAxB,EAA8BC,KAA9B,EAAqC;AACjC,MAAII,SAAS,GAAGb,MAAM,CAACc,IAAP,CAAYN,IAAZ,CAAhB;AACA,MAAIO,UAAU,GAAGf,MAAM,CAACc,IAAP,CAAYL,KAAZ,CAAjB;AACA,MAAIC,MAAM,GAAGG,SAAS,CAACH,MAAvB,CAHiC,CAIjC;;AACA,MAAIA,MAAM,KAAKK,UAAU,CAACL,MAA1B,EAAkC;AAC9B,WAAO,KAAP;AACH,GAPgC,CAQjC;AACA;AACA;;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAiC;AAC7B,QAAIK,GAAG,GAAGH,SAAS,CAACF,CAAD,CAAnB;;AACA,QAAI,CAACN,MAAM,CAACY,cAAP,CAAsBC,IAAtB,CAA2BT,KAA3B,EAAkCO,GAAlC,CAAD,IAA2C,CAACZ,OAAO,CAACI,IAAI,CAACQ,GAAD,CAAL,EAAYP,KAAK,CAACO,GAAD,CAAjB,CAAvD,EAAgF;AAC5E,aAAO,KAAP;AACH;AACJ;;AACD,SAAO,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASZ,OAAT,CAAiBI,IAAjB,EAAuBC,KAAvB,EAA8B;AAC1B;AACA,MAAID,IAAI,KAAKC,KAAb,EAAoB;AAChB,WAAO,IAAP;AACH;;AACD,MAAIU,SAAS,GAAGd,MAAM,CAACe,UAAP,CAAkBZ,IAAlB,CAAhB;AACA,MAAIa,UAAU,GAAGhB,MAAM,CAACe,UAAP,CAAkBX,KAAlB,CAAjB,CAN0B,CAO1B;;AACA,MAAIU,SAAS,IAAI,OAAb,IAAwBE,UAAU,IAAI,OAA1C,EAAmD;AAC/C,WAAOd,aAAa,CAACC,IAAD,EAAOC,KAAP,CAApB;AACH,GAVyB,CAW1B;;;AACA,MAAIU,SAAS,IAAI,QAAb,IAAyBE,UAAU,IAAI,QAA3C,EAAqD;AACjD,WAAOT,cAAc,CAACJ,IAAD,EAAOC,KAAP,CAArB;AACH,GAdyB,CAe1B;;;AACA,SAAO,KAAP;AACH;;AACDP,OAAO,CAACE,OAAR,GAAkBA,OAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compare = void 0;\nvar util_1 = require(\"./util\");\n/**\nEvaluate `left === right`, treating `left` and `right` as ordered lists.\n\n@returns true iff `left` and `right` have identical lengths, and every element\n         of `left` is equal to the corresponding element of `right`. Equality is\n         determined recursivly, via `compare`.\n*/\nfunction compareArrays(left, right) {\n    var length = left.length;\n    if (length !== right.length) {\n        return false;\n    }\n    for (var i = 0; i < length; i++) {\n        if (!compare(left[i], right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\nEvaluate `left === right`, treating `left` and `right` as property maps.\n\n@returns true iff every property in `left` has a value equal to the value of the\n         corresponding property in `right`, and vice-versa, stopping as soon as\n         possible. Equality is determined recursivly, via `compare`.\n*/\nfunction compareObjects(left, right) {\n    var left_keys = Object.keys(left);\n    var right_keys = Object.keys(right);\n    var length = left_keys.length;\n    // quick exit if the number of keys don't match up\n    if (length !== right_keys.length) {\n        return false;\n    }\n    // we don't know for sure that Set(left_keys) is equal to Set(right_keys),\n    // much less that their values in left and right are equal, but if right\n    // contains each key in left, we know it can't have any additional keys\n    for (var i = 0; i < length; i++) {\n        var key = left_keys[i];\n        if (!util_1.hasOwnProperty.call(right, key) || !compare(left[key], right[key])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n`compare()` returns true if `left` and `right` are materially equal\n(i.e., would produce equivalent JSON), false otherwise.\n\n> Here, \"equal\" means that the value at the target location and the\n> value conveyed by \"value\" are of the same JSON type, and that they\n> are considered equal by the following rules for that type:\n> o  strings: are considered equal if they contain the same number of\n>    Unicode characters and their code points are byte-by-byte equal.\n> o  numbers: are considered equal if their values are numerically\n>    equal.\n> o  arrays: are considered equal if they contain the same number of\n>    values, and if each value can be considered equal to the value at\n>    the corresponding position in the other array, using this list of\n>    type-specific rules.\n> o  objects: are considered equal if they contain the same number of\n>    members, and if each member can be considered equal to a member in\n>    the other object, by comparing their keys (as strings) and their\n>    values (using this list of type-specific rules).\n> o  literals (false, true, and null): are considered equal if they are\n>    the same.\n*/\nfunction compare(left, right) {\n    // strict equality handles literals, numbers, and strings (a sufficient but not necessary cause)\n    if (left === right) {\n        return true;\n    }\n    var left_type = util_1.objectType(left);\n    var right_type = util_1.objectType(right);\n    // check arrays\n    if (left_type == 'array' && right_type == 'array') {\n        return compareArrays(left, right);\n    }\n    // check objects\n    if (left_type == 'object' && right_type == 'object') {\n        return compareObjects(left, right);\n    }\n    // mismatched arrays & objects, etc., are always inequal\n    return false;\n}\nexports.compare = compare;\n"]},"metadata":{},"sourceType":"script"}